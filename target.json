{
  "id": "arcade",
  "name": "arcade",
  "title": "MakeCode Arcade",
  "corepkg": "core",
  "cloud": {
    "workspace": false,
    "sharing": true,
    "importing": true,
    "packages": true,
    "publishing": true,
    "githubPackages": true
  },
  "bundleddirs": [
    "libs/animation",
    "libs/base",
    "libs/core",
    "libs/core---samd51",
    "libs/core---stm32f401re",
    "libs/core---linux",
    "libs/corgio",
    "libs/darts",
    "libs/hw",
    "libs/hw---rpi",
    "libs/hw---stm32f401",
    "libs/hw---samd51",
    "libs/screen",
    "libs/screen---st7735",
    "libs/screen---linux",
    "libs/game",
    "libs/controller",
    "libs/controller---hw",
    "libs/buttons",
    "libs/music",
    "libs/music---pwm",
    "libs/music---linux",
    "libs/local-multiplayer",
    "libs/device",
    "libs/jacdac"
  ],
  "compile": {
    "useUF2": true,
    "webUSB": false,
    "deployDrives": ".*",
    "deployFileMarker": "INFO_UF2.TXT",
    "driveName": "ARCADE",
    "floatingPoint": true,
    "taggedInts": true,
    "saveAsPNG": true,
    "nativeType": "thumb",
    "gc": true,
    "upgrades": [],
    "switches": {},
    "jsRefCounting": false,
    "vtableShift": 2
  },
  "compileService": {
    "buildEngine": "codal",
    "githubCorePackage": "lancaster-university/codal",
    "gittag": "v0.5.0",
    "dockerImage": "pext/yotta:latest"
  },
  "variants": {
    "stm32f401": {
      "compile": {
        "hasHex": true,
        "openocdScript": "source [find interface/stlink-v2.cfg]; source [find target/stm32f4x.cfg]",
        "vtableShift": 4
      },
      "compileService": {
        "codalTarget": {
          "name": "codal-big-brainpad",
          "url": "https://github.com/lancaster-university/codal-big-brainpad",
          "branch": "v1.0.11",
          "type": "git"
        },
        "codalBinary": "STM32",
        "serviceId": "codal2stm32",
        "dockerImage": "pext/yotta:latest"
      }
    },
    "samd51": {
      "compile": {
        "hasHex": true,
        "openocdScriptAlt": "source [find interface/cmsis-dap.cfg]; set CHIPNAME at91samd51g19; source [find target/at91samdXX.cfg]",
        "openocdScript": "source [find interface/stlink-v2.cfg]; set CPUTAPID 0x2ba01477; set CHIPNAME at91samd51g19; source [find target/at91samdXX.cfg]",
        "ramSize": 196608,
        "vtableShift": 4
      },
      "compileService": {
        "codalTarget": {
          "name": "codal-itsybitsy-m4",
          "url": "https://github.com/lancaster-university/codal-itsybitsy-m4",
          "branch": "v0.0.8",
          "type": "git"
        },
        "codalBinary": "ITSYBITSY_M4",
        "serviceId": "codal2samd51",
        "dockerImage": "pext/yotta:latest"
      }
    },
    "rpi": {
      "compile": {
        "hasHex": true,
        "useELF": true,
        "runtimeIsARM": true,
        "vtableShift": 4,
        "flashCodeAlign": 256,
        "stackAlign": 2
      },
      "compileService": {
        "buildEngine": "dockermake",
        "dockerImage": "pext/rpi:latest",
        "serviceId": "rpi"
      }
    }
  },
  "serial": {
    "useEditor": true,
    "log": true,
    "editorTheme": {
      "graphBackground": "#d9d9d9",
      "lineColors": [
        "#009DDC",
        "#FB48C7",
        "#40bf4a",
        "#8073E5",
        "#d25b33"
      ]
    }
  },
  "runtime": {
    "mathBlocks": true,
    "loopsBlocks": true,
    "logicBlocks": true,
    "variablesBlocks": true,
    "textBlocks": true,
    "functionBlocks": true,
    "listsBlocks": true,
    "bannedCategories": [
      "pins",
      "console",
      "control"
    ]
  },
  "simulator": {
    "autoRun": false,
    "headless": true,
    "aspectRatio": 0.85,
    "dynamicBoardDefinition": true
  },
  "appTheme": {
    "logoUrl": "https://github.com/Microsoft/pxt-32",
    "logo": "docs/static/logo.svg",
    "docsLogo": "docs/static/logo.svg",
    "portraitLogo": "docs/static/logo.svg",
    "footerLogo": "docs/static/logo.svg",
    "organization": "Microsoft MakeCode",
    "organizationUrl": "https://makecode.com/org",
    "organizationLogo": false,
    "organizationWideLogo": false,
    "homeUrl": "/arcade/",
    "embedUrl": "https://zq-jhon.github.io",
    "privacyUrl": "https://zq-jhon.github.io",
    "termsOfUseUrl": "https://zq-jhon.github.io",
    "betaUrl": false,
    "githubUrl": "https://zq-jhon.github.io",
    "boardName": "ZQ-JHON",
    "socialOptions": {
      "related": false,
      "discourse": false
    },
    "defaultLocale": "zh-CN",
    "disableLiveTranslations": true,
    "hideMenubarLogo": true,
    "highContrastLogo": true,
    "simScreenshot": false,
    "docMenu": [
      {
        "name": "关于",
        "path": "/arcade/docs/about"
      },
      {
        "name": "文档",
        "path": "/arcade/docs/docs"
      }
    ],
    "coloredToolbox": true,
    "monacoToolbox": true,
    "invertedMenu": true,
    "showHomeScreen": true,
    "highContrast": true,
    "debugger": true,
    "print": true,
    "hasAudio": true,
    "allowPackageExtensions": true,
    "homeScreenHero": "docs/static/hero.png",
    "blocklyOptions": {
      "grid": {
        "spacing": 20,
        "length": 100,
        "colour": "rgba(107, 79, 118, 0.10)",
        "snap": true
      }
    },
    "blockColors": {
      "loops": "#20BF6B",
      "logic": "#45AAF2",
      "math": "#A55EEA",
      "variables": "#EC3B59",
      "text": "#F5D547",
      "arrays": "#FF8F08",
      "functions": "#1446A0"
    },
    "availableLocales": [
      "zh-CN",
      "en"
    ],
    "simAnimationEnter": "fly right in",
    "simAnimationExit": "fly right out",
    "crowdinProject": "kindscript",
    "monacoColors": {
      "editor.background": "#FFFAE7"
    },
    "python": true,
    "TOC": [
      {
        "name": "About",
        "subitems": [],
        "path": "/about",
        "nextName": "FAQ",
        "nextPath": "/faq"
      },
      {
        "name": "FAQ",
        "subitems": [],
        "path": "/faq",
        "prevName": "About",
        "prevPath": "/about",
        "nextName": "Lessons",
        "nextPath": "/lessons"
      },
      {
        "name": "Lessons",
        "subitems": [
          {
            "name": "Cherry Pickr",
            "subitems": [],
            "path": "/lessons/cherry-pickr",
            "prevName": "Lessons",
            "prevPath": "/lessons",
            "nextName": "Barrel Dodger",
            "nextPath": "/lessons/barrel-dodger"
          },
          {
            "name": "Barrel Dodger",
            "subitems": [],
            "path": "/lessons/barrel-dodger",
            "prevName": "Cherry Pickr",
            "prevPath": "/lessons/cherry-pickr",
            "nextName": "Classics",
            "nextPath": "/classics"
          }
        ],
        "path": "/lessons",
        "prevName": "FAQ",
        "prevPath": "/faq",
        "nextName": "Cherry Pickr",
        "nextPath": "/lessons/cherry-pickr"
      },
      {
        "name": "Classics",
        "subitems": [
          {
            "name": "Ping Pong",
            "subitems": [],
            "path": "/examples/ping-pong",
            "prevName": "Classics",
            "prevPath": "/classics",
            "nextName": "Eater Princess",
            "nextPath": "/examples/eater-princess"
          },
          {
            "name": "Eater Princess",
            "subitems": [],
            "path": "/examples/eater-princess",
            "prevName": "Ping Pong",
            "prevPath": "/examples/ping-pong",
            "nextName": "Food Machine",
            "nextPath": "/examples/food-machine"
          },
          {
            "name": "Food Machine",
            "subitems": [],
            "path": "/examples/food-machine",
            "prevName": "Eater Princess",
            "prevPath": "/examples/eater-princess",
            "nextName": "Treasure Hunt",
            "nextPath": "/examples/treasure-hunt"
          },
          {
            "name": "Treasure Hunt",
            "subitems": [],
            "path": "/examples/treasure-hunt",
            "prevName": "Food Machine",
            "prevPath": "/examples/food-machine",
            "nextName": "Jewels",
            "nextPath": "/examples/jewels"
          },
          {
            "name": "Jewels",
            "subitems": [],
            "path": "/examples/jewels",
            "prevName": "Treasure Hunt",
            "prevPath": "/examples/treasure-hunt",
            "nextName": "Courses",
            "nextPath": "/courses"
          }
        ],
        "path": "/classics",
        "prevName": "Barrel Dodger",
        "prevPath": "/lessons/barrel-dodger",
        "nextName": "Ping Pong",
        "nextPath": "/examples/ping-pong"
      },
      {
        "name": "Courses",
        "subitems": [
          {
            "name": "CS Intro 1",
            "subitems": [
              {
                "name": "About",
                "subitems": [
                  {
                    "name": "Programming Language",
                    "subitems": [],
                    "path": "/courses/csintro1/about/script",
                    "prevName": "About",
                    "prevPath": "/courses/csintro1/about",
                    "nextName": "For Teachers",
                    "nextPath": "/courses/csintro1/about/teachers"
                  },
                  {
                    "name": "For Teachers",
                    "subitems": [],
                    "path": "/courses/csintro1/about/teachers",
                    "prevName": "Programming Language",
                    "prevPath": "/courses/csintro1/about/script",
                    "nextName": "Authors",
                    "nextPath": "/courses/csintro1/about/authors"
                  },
                  {
                    "name": "Authors",
                    "subitems": [],
                    "path": "/courses/csintro1/about/authors",
                    "prevName": "For Teachers",
                    "prevPath": "/courses/csintro1/about/teachers",
                    "nextName": "Intro",
                    "nextPath": "/courses/csintro1/intro"
                  }
                ],
                "path": "/courses/csintro1/about",
                "prevName": "CS Intro 1",
                "prevPath": "/courses/csintro1",
                "nextName": "Programming Language",
                "nextPath": "/courses/csintro1/about/script"
              },
              {
                "name": "Intro",
                "subitems": [
                  {
                    "name": "Orientation to Makecode",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/makecode-orientation",
                    "prevName": "Intro",
                    "prevPath": "/courses/csintro1/intro",
                    "nextName": "Birthday Algorithm",
                    "nextPath": "/courses/csintro1/intro/birthday-algorithm"
                  },
                  {
                    "name": "Birthday Algorithm",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/birthday-algorithm",
                    "prevName": "Orientation to Makecode",
                    "prevPath": "/courses/csintro1/intro/makecode-orientation",
                    "nextName": "Sprites",
                    "nextPath": "/courses/csintro1/intro/sprites"
                  },
                  {
                    "name": "Sprites",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/sprites",
                    "prevName": "Birthday Algorithm",
                    "prevPath": "/courses/csintro1/intro/birthday-algorithm",
                    "nextName": "Unplugged: Rock Paper Scissors",
                    "nextPath": "/courses/csintro1/intro/unplugged"
                  },
                  {
                    "name": "Unplugged: Rock Paper Scissors",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/unplugged",
                    "prevName": "Sprites",
                    "prevPath": "/courses/csintro1/intro/sprites",
                    "nextName": "Variable Math",
                    "nextPath": "/courses/csintro1/intro/variable-math"
                  },
                  {
                    "name": "Variable Math",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/variable-math",
                    "prevName": "Unplugged: Rock Paper Scissors",
                    "prevPath": "/courses/csintro1/intro/unplugged",
                    "nextName": "Info Variables",
                    "nextPath": "/courses/csintro1/intro/info"
                  },
                  {
                    "name": "Info Variables",
                    "subitems": [],
                    "path": "/courses/csintro1/intro/info",
                    "prevName": "Variable Math",
                    "prevPath": "/courses/csintro1/intro/variable-math",
                    "nextName": "Sprites",
                    "nextPath": "/courses/csintro1/sprites"
                  }
                ],
                "path": "/courses/csintro1/intro",
                "prevName": "Authors",
                "prevPath": "/courses/csintro1/about/authors",
                "nextName": "Orientation to Makecode",
                "nextPath": "/courses/csintro1/intro/makecode-orientation"
              },
              {
                "name": "Sprites",
                "subitems": [
                  {
                    "name": "Unplugged: Sink a Ship",
                    "subitems": [],
                    "path": "/courses/csintro1/sprites/unplugged",
                    "prevName": "Sprites",
                    "prevPath": "/courses/csintro1/sprites",
                    "nextName": "Coordinate Walker",
                    "nextPath": "/courses/csintro1/sprites/coordinate-walker"
                  },
                  {
                    "name": "Coordinate Walker",
                    "subitems": [],
                    "path": "/courses/csintro1/sprites/coordinate-walker",
                    "prevName": "Unplugged: Sink a Ship",
                    "prevPath": "/courses/csintro1/sprites/unplugged",
                    "nextName": "Collage",
                    "nextPath": "/courses/csintro1/sprites/collage"
                  },
                  {
                    "name": "Collage",
                    "subitems": [],
                    "path": "/courses/csintro1/sprites/collage",
                    "prevName": "Coordinate Walker",
                    "prevPath": "/courses/csintro1/sprites/coordinate-walker",
                    "nextName": "Hello Sprite",
                    "nextPath": "/courses/csintro1/sprites/hello-sprite"
                  },
                  {
                    "name": "Hello Sprite",
                    "subitems": [],
                    "path": "/courses/csintro1/sprites/hello-sprite",
                    "prevName": "Collage",
                    "prevPath": "/courses/csintro1/sprites/collage",
                    "nextName": "Characters and Stories",
                    "nextPath": "/courses/csintro1/sprites/characters"
                  },
                  {
                    "name": "Characters and Stories",
                    "subitems": [],
                    "path": "/courses/csintro1/sprites/characters",
                    "prevName": "Hello Sprite",
                    "prevPath": "/courses/csintro1/sprites/hello-sprite",
                    "nextName": "Motion",
                    "nextPath": "/courses/csintro1/motion"
                  }
                ],
                "path": "/courses/csintro1/sprites",
                "prevName": "Info Variables",
                "prevPath": "/courses/csintro1/intro/info",
                "nextName": "Unplugged: Sink a Ship",
                "nextPath": "/courses/csintro1/sprites/unplugged"
              },
              {
                "name": "Motion",
                "subitems": [
                  {
                    "name": "Unplugged: Using a Controller",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/unplugged",
                    "prevName": "Motion",
                    "prevPath": "/courses/csintro1/motion",
                    "nextName": "Sprite Motion Event",
                    "nextPath": "/courses/csintro1/motion/sprite-motion-event"
                  },
                  {
                    "name": "Sprite Motion Event",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/sprite-motion-event",
                    "prevName": "Unplugged: Using a Controller",
                    "prevPath": "/courses/csintro1/motion/unplugged",
                    "nextName": "Overlap Section 1",
                    "nextPath": "/courses/csintro1/motion/overlap1"
                  },
                  {
                    "name": "Overlap Section 1",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/overlap1",
                    "prevName": "Sprite Motion Event",
                    "prevPath": "/courses/csintro1/motion/sprite-motion-event",
                    "nextName": "Random",
                    "nextPath": "/courses/csintro1/motion/random"
                  },
                  {
                    "name": "Random",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/random",
                    "prevName": "Overlap Section 1",
                    "prevPath": "/courses/csintro1/motion/overlap1",
                    "nextName": "Overlap Section 2",
                    "nextPath": "/courses/csintro1/motion/overlap2"
                  },
                  {
                    "name": "Overlap Section 2",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/overlap2",
                    "prevName": "Random",
                    "prevPath": "/courses/csintro1/motion/random",
                    "nextName": "Create Sprite & On Create",
                    "nextPath": "/courses/csintro1/motion/create-on-create-sprites"
                  },
                  {
                    "name": "Create Sprite & On Create",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/create-on-create-sprites",
                    "prevName": "Overlap Section 2",
                    "prevPath": "/courses/csintro1/motion/overlap2",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro1/motion/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro1/motion/project",
                    "prevName": "Create Sprite & On Create",
                    "prevPath": "/courses/csintro1/motion/create-on-create-sprites",
                    "nextName": "Loops",
                    "nextPath": "/courses/csintro1/loops"
                  }
                ],
                "path": "/courses/csintro1/motion",
                "prevName": "Characters and Stories",
                "prevPath": "/courses/csintro1/sprites/characters",
                "nextName": "Unplugged: Using a Controller",
                "nextPath": "/courses/csintro1/motion/unplugged"
              },
              {
                "name": "Loops",
                "subitems": [
                  {
                    "name": "Intro",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/intro",
                    "prevName": "Loops",
                    "prevPath": "/courses/csintro1/loops",
                    "nextName": "Unplugged: Circle a Chair",
                    "nextPath": "/courses/csintro1/loops/unplugged"
                  },
                  {
                    "name": "Unplugged: Circle a Chair",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/unplugged",
                    "prevName": "Intro",
                    "prevPath": "/courses/csintro1/loops/intro",
                    "nextName": "Increment Loop",
                    "nextPath": "/courses/csintro1/loops/increment-loop"
                  },
                  {
                    "name": "Increment Loop",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/increment-loop",
                    "prevName": "Unplugged: Circle a Chair",
                    "prevPath": "/courses/csintro1/loops/unplugged",
                    "nextName": "Projectiles",
                    "nextPath": "/courses/csintro1/loops/projectiles"
                  },
                  {
                    "name": "Projectiles",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/projectiles",
                    "prevName": "Increment Loop",
                    "prevPath": "/courses/csintro1/loops/increment-loop",
                    "nextName": "Projectiles from Sprites",
                    "nextPath": "/courses/csintro1/loops/projectile-from"
                  },
                  {
                    "name": "Projectiles from Sprites",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/projectile-from",
                    "prevName": "Projectiles",
                    "prevPath": "/courses/csintro1/loops/projectiles",
                    "nextName": "Physics",
                    "nextPath": "/courses/csintro1/loops/physics"
                  },
                  {
                    "name": "Physics",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/physics",
                    "prevName": "Projectiles from Sprites",
                    "prevPath": "/courses/csintro1/loops/projectile-from",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro1/loops/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro1/loops/project",
                    "prevName": "Physics",
                    "prevPath": "/courses/csintro1/loops/physics",
                    "nextName": "Review",
                    "nextPath": "/courses/csintro1/review"
                  }
                ],
                "path": "/courses/csintro1/loops",
                "prevName": "Project",
                "prevPath": "/courses/csintro1/motion/project",
                "nextName": "Intro",
                "nextPath": "/courses/csintro1/loops/intro"
              },
              {
                "name": "Review",
                "subitems": [
                  {
                    "name": "Extend \"touch the button\"",
                    "subitems": [],
                    "path": "/courses/csintro1/review/touch-the-button",
                    "prevName": "Review",
                    "prevPath": "/courses/csintro1/review",
                    "nextName": "Paparazzi",
                    "nextPath": "/courses/csintro1/review/paparazzi"
                  },
                  {
                    "name": "Paparazzi",
                    "subitems": [],
                    "path": "/courses/csintro1/review/paparazzi",
                    "prevName": "Extend \"touch the button\"",
                    "prevPath": "/courses/csintro1/review/touch-the-button",
                    "nextName": "Asteroid Blaster",
                    "nextPath": "/courses/csintro1/review/asteroid-blaster"
                  },
                  {
                    "name": "Asteroid Blaster",
                    "subitems": [],
                    "path": "/courses/csintro1/review/asteroid-blaster",
                    "prevName": "Paparazzi",
                    "prevPath": "/courses/csintro1/review/paparazzi",
                    "nextName": "Baseball Catching",
                    "nextPath": "/courses/csintro1/review/baseball-catching"
                  },
                  {
                    "name": "Baseball Catching",
                    "subitems": [],
                    "path": "/courses/csintro1/review/baseball-catching",
                    "prevName": "Asteroid Blaster",
                    "prevPath": "/courses/csintro1/review/asteroid-blaster",
                    "nextName": "Dodgey Duck",
                    "nextPath": "/courses/csintro1/review/dodgey-duck"
                  },
                  {
                    "name": "Dodgey Duck",
                    "subitems": [],
                    "path": "/courses/csintro1/review/dodgey-duck",
                    "prevName": "Baseball Catching",
                    "prevPath": "/courses/csintro1/review/baseball-catching",
                    "nextName": "Final Project",
                    "nextPath": "/courses/csintro1/project/final"
                  }
                ],
                "path": "/courses/csintro1/review",
                "prevName": "Project",
                "prevPath": "/courses/csintro1/loops/project",
                "nextName": "Extend \"touch the button\"",
                "nextPath": "/courses/csintro1/review/touch-the-button"
              },
              {
                "name": "Final Project",
                "subitems": [],
                "path": "/courses/csintro1/project/final",
                "prevName": "Dodgey Duck",
                "prevPath": "/courses/csintro1/review/dodgey-duck",
                "nextName": "CS Intro 2",
                "nextPath": "/courses/csintro2"
              }
            ],
            "path": "/courses/csintro1",
            "prevName": "Courses",
            "prevPath": "/courses",
            "nextName": "About",
            "nextPath": "/courses/csintro1/about"
          },
          {
            "name": "CS Intro 2",
            "subitems": [
              {
                "name": "About",
                "subitems": [
                  {
                    "name": "Programming Language",
                    "subitems": [],
                    "path": "/courses/csintro2/about/script",
                    "prevName": "About",
                    "prevPath": "/courses/csintro2/about",
                    "nextName": "For Teachers",
                    "nextPath": "/courses/csintro2/about/teachers"
                  },
                  {
                    "name": "For Teachers",
                    "subitems": [],
                    "path": "/courses/csintro2/about/teachers",
                    "prevName": "Programming Language",
                    "prevPath": "/courses/csintro2/about/script",
                    "nextName": "Authors",
                    "nextPath": "/courses/csintro2/about/authors"
                  },
                  {
                    "name": "Authors",
                    "subitems": [],
                    "path": "/courses/csintro2/about/authors",
                    "prevName": "For Teachers",
                    "prevPath": "/courses/csintro2/about/teachers",
                    "nextName": "Functions",
                    "nextPath": "/courses/csintro2/functions"
                  }
                ],
                "path": "/courses/csintro2/about",
                "prevName": "CS Intro 2",
                "prevPath": "/courses/csintro2",
                "nextName": "Programming Language",
                "nextPath": "/courses/csintro2/about/script"
              },
              {
                "name": "Functions",
                "subitems": [
                  {
                    "name": "Unplugged: Making a Sandwich",
                    "subitems": [],
                    "path": "/courses/csintro2/functions/unplugged",
                    "prevName": "Functions",
                    "prevPath": "/courses/csintro2/functions",
                    "nextName": "Intro to Functions",
                    "nextPath": "/courses/csintro2/functions/intro"
                  },
                  {
                    "name": "Intro to Functions",
                    "subitems": [],
                    "path": "/courses/csintro2/functions/intro",
                    "prevName": "Unplugged: Making a Sandwich",
                    "prevPath": "/courses/csintro2/functions/unplugged",
                    "nextName": "Reducing Redundancy with Functions",
                    "nextPath": "/courses/csintro2/functions/redundancy"
                  },
                  {
                    "name": "Reducing Redundancy with Functions",
                    "subitems": [],
                    "path": "/courses/csintro2/functions/redundancy",
                    "prevName": "Intro to Functions",
                    "prevPath": "/courses/csintro2/functions/intro",
                    "nextName": "Using Extensions",
                    "nextPath": "/courses/csintro2/functions/extensions"
                  },
                  {
                    "name": "Using Extensions",
                    "subitems": [],
                    "path": "/courses/csintro2/functions/extensions",
                    "prevName": "Reducing Redundancy with Functions",
                    "prevPath": "/courses/csintro2/functions/redundancy",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro2/functions/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro2/functions/project",
                    "prevName": "Using Extensions",
                    "prevPath": "/courses/csintro2/functions/extensions",
                    "nextName": "Tilemap",
                    "nextPath": "/courses/csintro2/tilemap"
                  }
                ],
                "path": "/courses/csintro2/functions",
                "prevName": "Authors",
                "prevPath": "/courses/csintro2/about/authors",
                "nextName": "Unplugged: Making a Sandwich",
                "nextPath": "/courses/csintro2/functions/unplugged"
              },
              {
                "name": "Tilemap",
                "subitems": [
                  {
                    "name": "Intro",
                    "subitems": [],
                    "path": "/courses/csintro2/tilemap/intro",
                    "prevName": "Tilemap",
                    "prevPath": "/courses/csintro2/tilemap",
                    "nextName": "Interactions",
                    "nextPath": "/courses/csintro2/tilemap/interactions"
                  },
                  {
                    "name": "Interactions",
                    "subitems": [],
                    "path": "/courses/csintro2/tilemap/interactions",
                    "prevName": "Intro",
                    "prevPath": "/courses/csintro2/tilemap/intro",
                    "nextName": "Using Corgi Extension",
                    "nextPath": "/courses/csintro2/tilemap/extensions"
                  },
                  {
                    "name": "Using Corgi Extension",
                    "subitems": [],
                    "path": "/courses/csintro2/tilemap/extensions",
                    "prevName": "Interactions",
                    "prevPath": "/courses/csintro2/tilemap/interactions",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro2/tilemap/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro2/tilemap/project",
                    "prevName": "Using Corgi Extension",
                    "prevPath": "/courses/csintro2/tilemap/extensions",
                    "nextName": "Logic",
                    "nextPath": "/courses/csintro2/logic"
                  }
                ],
                "path": "/courses/csintro2/tilemap",
                "prevName": "Project",
                "prevPath": "/courses/csintro2/functions/project",
                "nextName": "Intro",
                "nextPath": "/courses/csintro2/tilemap/intro"
              },
              {
                "name": "Logic",
                "subitems": [
                  {
                    "name": "Introduction",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/intro",
                    "prevName": "Logic",
                    "prevPath": "/courses/csintro2/logic",
                    "nextName": "If and Else",
                    "nextPath": "/courses/csintro2/logic/if-else"
                  },
                  {
                    "name": "If and Else",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/if-else",
                    "prevName": "Introduction",
                    "prevPath": "/courses/csintro2/logic/intro",
                    "nextName": "Multiplayer",
                    "nextPath": "/courses/csintro2/logic/multiplayer"
                  },
                  {
                    "name": "Multiplayer",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/multiplayer",
                    "prevName": "If and Else",
                    "prevPath": "/courses/csintro2/logic/if-else",
                    "nextName": "Booleans",
                    "nextPath": "/courses/csintro2/logic/booleans"
                  },
                  {
                    "name": "Booleans",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/booleans",
                    "prevName": "Multiplayer",
                    "prevPath": "/courses/csintro2/logic/multiplayer",
                    "nextName": "Validating User Input",
                    "nextPath": "/courses/csintro2/logic/user-input"
                  },
                  {
                    "name": "Validating User Input",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/user-input",
                    "prevName": "Booleans",
                    "prevPath": "/courses/csintro2/logic/booleans",
                    "nextName": "Logic in Loops",
                    "nextPath": "/courses/csintro2/logic/while"
                  },
                  {
                    "name": "Logic in Loops",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/while",
                    "prevName": "Validating User Input",
                    "prevPath": "/courses/csintro2/logic/user-input",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro2/logic/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro2/logic/project",
                    "prevName": "Logic in Loops",
                    "prevPath": "/courses/csintro2/logic/while",
                    "nextName": "Arrays",
                    "nextPath": "/courses/csintro2/arrays"
                  }
                ],
                "path": "/courses/csintro2/logic",
                "prevName": "Project",
                "prevPath": "/courses/csintro2/tilemap/project",
                "nextName": "Introduction",
                "nextPath": "/courses/csintro2/logic/intro"
              },
              {
                "name": "Arrays",
                "subitems": [
                  {
                    "name": "Intro",
                    "subitems": [],
                    "path": "/courses/csintro2/arrays/intro",
                    "prevName": "Arrays",
                    "prevPath": "/courses/csintro2/arrays",
                    "nextName": "String Arrays",
                    "nextPath": "/courses/csintro2/arrays/string"
                  },
                  {
                    "name": "String Arrays",
                    "subitems": [],
                    "path": "/courses/csintro2/arrays/string",
                    "prevName": "Intro",
                    "prevPath": "/courses/csintro2/arrays/intro",
                    "nextName": "Sprite Arrays",
                    "nextPath": "/courses/csintro2/arrays/sprites"
                  },
                  {
                    "name": "Sprite Arrays",
                    "subitems": [],
                    "path": "/courses/csintro2/arrays/sprites",
                    "prevName": "String Arrays",
                    "prevPath": "/courses/csintro2/arrays/string",
                    "nextName": "Tile Arrays",
                    "nextPath": "/courses/csintro2/arrays/tilemap"
                  },
                  {
                    "name": "Tile Arrays",
                    "subitems": [],
                    "path": "/courses/csintro2/arrays/tilemap",
                    "prevName": "Sprite Arrays",
                    "prevPath": "/courses/csintro2/arrays/sprites",
                    "nextName": "Project",
                    "nextPath": "/courses/csintro2/arrays/project"
                  },
                  {
                    "name": "Project",
                    "subitems": [],
                    "path": "/courses/csintro2/arrays/project",
                    "prevName": "Tile Arrays",
                    "prevPath": "/courses/csintro2/arrays/tilemap",
                    "nextName": "Review",
                    "nextPath": "/courses/csintro2/review"
                  }
                ],
                "path": "/courses/csintro2/arrays",
                "prevName": "Project",
                "prevPath": "/courses/csintro2/logic/project",
                "nextName": "Intro",
                "nextPath": "/courses/csintro2/arrays/intro"
              },
              {
                "name": "Review",
                "subitems": [
                  {
                    "name": "Side Scroller",
                    "subitems": [],
                    "path": "/courses/csintro2/review/side-scroller",
                    "prevName": "Review",
                    "prevPath": "/courses/csintro2/review",
                    "nextName": "Blockbuster Film",
                    "nextPath": "/courses/csintro2/review/blockbuster"
                  },
                  {
                    "name": "Blockbuster Film",
                    "subitems": [],
                    "path": "/courses/csintro2/review/blockbuster",
                    "prevName": "Side Scroller",
                    "prevPath": "/courses/csintro2/review/side-scroller",
                    "nextName": "Functionally the Same",
                    "nextPath": "/courses/csintro2/review/functions"
                  },
                  {
                    "name": "Functionally the Same",
                    "subitems": [],
                    "path": "/courses/csintro2/review/functions",
                    "prevName": "Blockbuster Film",
                    "prevPath": "/courses/csintro2/review/blockbuster",
                    "nextName": "Final Project",
                    "nextPath": "/courses/csintro2/final-project"
                  }
                ],
                "path": "/courses/csintro2/review",
                "prevName": "Project",
                "prevPath": "/courses/csintro2/arrays/project",
                "nextName": "Side Scroller",
                "nextPath": "/courses/csintro2/review/side-scroller"
              },
              {
                "name": "Final Project",
                "subitems": [],
                "path": "/courses/csintro2/final-project",
                "prevName": "Functionally the Same",
                "prevPath": "/courses/csintro2/review/functions",
                "nextName": "JavaScript Games",
                "nextPath": "/javascript-games"
              }
            ],
            "path": "/courses/csintro2",
            "prevName": "Final Project",
            "prevPath": "/courses/csintro1/project/final",
            "nextName": "About",
            "nextPath": "/courses/csintro2/about"
          }
        ],
        "path": "/courses",
        "prevName": "Jewels",
        "prevPath": "/examples/jewels",
        "nextName": "CS Intro 1",
        "nextPath": "/courses/csintro1"
      },
      {
        "name": "JavaScript Games",
        "subitems": [
          {
            "name": "Asteroids",
            "subitems": [],
            "path": "/examples/asteroids",
            "prevName": "JavaScript Games",
            "prevPath": "/javascript-games",
            "nextName": "Bouncer Bucket",
            "nextPath": "/examples/bouncer-bucket"
          },
          {
            "name": "Bouncer Bucket",
            "subitems": [],
            "path": "/examples/bouncer-bucket",
            "prevName": "Asteroids",
            "prevPath": "/examples/asteroids",
            "nextName": "Car Race",
            "nextPath": "/examples/car-race"
          },
          {
            "name": "Car Race",
            "subitems": [],
            "path": "/examples/car-race",
            "prevName": "Bouncer Bucket",
            "prevPath": "/examples/bouncer-bucket",
            "nextName": "Collisions",
            "nextPath": "/examples/collisions"
          },
          {
            "name": "Collisions",
            "subitems": [],
            "path": "/examples/collisions",
            "prevName": "Car Race",
            "prevPath": "/examples/car-race",
            "nextName": "Duck",
            "nextPath": "/examples/duck"
          },
          {
            "name": "Duck",
            "subitems": [],
            "path": "/examples/duck",
            "prevName": "Collisions",
            "prevPath": "/examples/collisions",
            "nextName": "Guess the Letter",
            "nextPath": "/examples/guess-the-letter"
          },
          {
            "name": "Guess the Letter",
            "subitems": [],
            "path": "/examples/guess-the-letter",
            "prevName": "Duck",
            "prevPath": "/examples/duck",
            "nextName": "Jumper",
            "nextPath": "/examples/jumper"
          },
          {
            "name": "Jumper",
            "subitems": [],
            "path": "/examples/jumper",
            "prevName": "Guess the Letter",
            "prevPath": "/examples/guess-the-letter",
            "nextName": "Mega Bounce",
            "nextPath": "/examples/mega-bounce"
          },
          {
            "name": "Mega Bounce",
            "subitems": [],
            "path": "/examples/mega-bounce",
            "prevName": "Jumper",
            "prevPath": "/examples/jumper",
            "nextName": "Pallete",
            "nextPath": "/examples/palette"
          },
          {
            "name": "Pallete",
            "subitems": [],
            "path": "/examples/palette",
            "prevName": "Mega Bounce",
            "prevPath": "/examples/mega-bounce",
            "nextName": "Runner",
            "nextPath": "/examples/runner"
          },
          {
            "name": "Runner",
            "subitems": [],
            "path": "/examples/runner",
            "prevName": "Pallete",
            "prevPath": "/examples/palette",
            "nextName": "Snake",
            "nextPath": "/examples/snake"
          },
          {
            "name": "Snake",
            "subitems": [],
            "path": "/examples/snake",
            "prevName": "Runner",
            "prevPath": "/examples/runner",
            "nextName": "Sorting",
            "nextPath": "/examples/sorting"
          },
          {
            "name": "Sorting",
            "subitems": [],
            "path": "/examples/sorting",
            "prevName": "Snake",
            "prevPath": "/examples/snake",
            "nextName": "Reference",
            "nextPath": "/reference"
          }
        ],
        "path": "/javascript-games",
        "prevName": "Final Project",
        "prevPath": "/courses/csintro2/final-project",
        "nextName": "Asteroids",
        "nextPath": "/examples/asteroids"
      },
      {
        "name": "Reference",
        "subitems": [
          {
            "name": "game",
            "subitems": [],
            "path": "/reference/game",
            "prevName": "Reference",
            "prevPath": "/reference",
            "nextName": "sprites",
            "nextPath": "/reference/sprites"
          },
          {
            "name": "sprites",
            "subitems": [],
            "path": "/reference/sprites",
            "prevName": "game",
            "prevPath": "/reference/game",
            "nextName": "controller",
            "nextPath": "/reference/controller"
          },
          {
            "name": "controller",
            "subitems": [],
            "path": "/reference/controller",
            "prevName": "sprites",
            "prevPath": "/reference/sprites",
            "nextName": "music",
            "nextPath": "/reference/music"
          },
          {
            "name": "music",
            "subitems": [],
            "path": "/reference/music",
            "prevName": "controller",
            "prevPath": "/reference/controller",
            "nextName": "scene",
            "nextPath": "/reference/scene"
          },
          {
            "name": "scene",
            "subitems": [],
            "path": "/reference/scene",
            "prevName": "music",
            "prevPath": "/reference/music",
            "nextName": "info",
            "nextPath": "/reference/info"
          },
          {
            "name": "info",
            "subitems": [],
            "path": "/reference/info",
            "prevName": "scene",
            "prevPath": "/reference/scene",
            "nextName": "images",
            "nextPath": "/reference/images"
          },
          {
            "name": "images",
            "subitems": [],
            "path": "/reference/images",
            "prevName": "info",
            "prevPath": "/reference/info",
            "nextName": "Blocks",
            "nextPath": "/blocks"
          }
        ],
        "path": "/reference",
        "prevName": "Sorting",
        "prevPath": "/examples/sorting",
        "nextName": "game",
        "nextPath": "/reference/game"
      },
      {
        "name": "Blocks",
        "subitems": [
          {
            "name": "On Start",
            "subitems": [],
            "path": "/blocks/on-start",
            "prevName": "Blocks",
            "prevPath": "/blocks",
            "nextName": "Loops",
            "nextPath": "/blocks/loops"
          },
          {
            "name": "Loops",
            "subitems": [
              {
                "name": "repeat",
                "subitems": [],
                "path": "/blocks/loops/repeat",
                "prevName": "Loops",
                "prevPath": "/blocks/loops",
                "nextName": "for",
                "nextPath": "/blocks/loops/for"
              },
              {
                "name": "for",
                "subitems": [],
                "path": "/blocks/loops/for",
                "prevName": "repeat",
                "prevPath": "/blocks/loops/repeat",
                "nextName": "while",
                "nextPath": "/blocks/loops/while"
              },
              {
                "name": "while",
                "subitems": [],
                "path": "/blocks/loops/while",
                "prevName": "for",
                "prevPath": "/blocks/loops/for",
                "nextName": "Logic",
                "nextPath": "/blocks/logic"
              }
            ],
            "path": "/blocks/loops",
            "prevName": "On Start",
            "prevPath": "/blocks/on-start",
            "nextName": "repeat",
            "nextPath": "/blocks/loops/repeat"
          },
          {
            "name": "Logic",
            "subitems": [
              {
                "name": "if",
                "subitems": [],
                "path": "/blocks/logic/if",
                "prevName": "Logic",
                "prevPath": "/blocks/logic",
                "nextName": "Boolean",
                "nextPath": "/blocks/logic/boolean"
              },
              {
                "name": "Boolean",
                "subitems": [],
                "path": "/blocks/logic/boolean",
                "prevName": "if",
                "prevPath": "/blocks/logic/if",
                "nextName": "Variables",
                "nextPath": "/blocks/variables"
              }
            ],
            "path": "/blocks/logic",
            "prevName": "while",
            "prevPath": "/blocks/loops/while",
            "nextName": "if",
            "nextPath": "/blocks/logic/if"
          },
          {
            "name": "Variables",
            "subitems": [
              {
                "name": "assign",
                "subitems": [],
                "path": "/blocks/variables/assign",
                "prevName": "Variables",
                "prevPath": "/blocks/variables",
                "nextName": "change var",
                "nextPath": "/blocks/variables/change"
              },
              {
                "name": "change var",
                "subitems": [],
                "path": "/blocks/variables/change",
                "prevName": "assign",
                "prevPath": "/blocks/variables/assign",
                "nextName": "var",
                "nextPath": "/blocks/variables/var"
              },
              {
                "name": "var",
                "subitems": [],
                "path": "/blocks/variables/var",
                "prevName": "change var",
                "prevPath": "/blocks/variables/change",
                "nextName": "Math",
                "nextPath": "/blocks/math"
              }
            ],
            "path": "/blocks/variables",
            "prevName": "Boolean",
            "prevPath": "/blocks/logic/boolean",
            "nextName": "assign",
            "nextPath": "/blocks/variables/assign"
          },
          {
            "name": "Math",
            "subitems": [],
            "path": "/blocks/math",
            "prevName": "var",
            "prevPath": "/blocks/variables/var",
            "nextName": "JavaScript blocks",
            "nextPath": "/blocks/javascript-blocks"
          },
          {
            "name": "JavaScript blocks",
            "subitems": [],
            "path": "/blocks/javascript-blocks",
            "prevName": "Math",
            "prevPath": "/blocks/math",
            "nextName": "Custom blocks",
            "nextPath": "/blocks/custom"
          },
          {
            "name": "Custom blocks",
            "subitems": [],
            "path": "/blocks/custom",
            "prevName": "JavaScript blocks",
            "prevPath": "/blocks/javascript-blocks",
            "nextName": "JavaScript",
            "nextPath": "/javascript"
          }
        ],
        "path": "/blocks",
        "prevName": "images",
        "prevPath": "/reference/images",
        "nextName": "On Start",
        "nextPath": "/blocks/on-start"
      },
      {
        "name": "JavaScript",
        "subitems": [
          {
            "name": "Calling",
            "subitems": [],
            "path": "/javascript/call",
            "prevName": "JavaScript",
            "prevPath": "/javascript",
            "nextName": "Sequencing",
            "nextPath": "/javascript/sequence"
          },
          {
            "name": "Sequencing",
            "subitems": [],
            "path": "/javascript/sequence",
            "prevName": "Calling",
            "prevPath": "/javascript/call",
            "nextName": "Variables",
            "nextPath": "/javascript/variables"
          },
          {
            "name": "Variables",
            "subitems": [],
            "path": "/javascript/variables",
            "prevName": "Sequencing",
            "prevPath": "/javascript/sequence",
            "nextName": "Operators",
            "nextPath": "/javascript/operators"
          },
          {
            "name": "Operators",
            "subitems": [],
            "path": "/javascript/operators",
            "prevName": "Variables",
            "prevPath": "/javascript/variables",
            "nextName": "Statements",
            "nextPath": "/javascript/statements"
          },
          {
            "name": "Statements",
            "subitems": [],
            "path": "/javascript/statements",
            "prevName": "Operators",
            "prevPath": "/javascript/operators",
            "nextName": "Functions",
            "nextPath": "/javascript/functions"
          },
          {
            "name": "Functions",
            "subitems": [],
            "path": "/javascript/functions",
            "prevName": "Statements",
            "prevPath": "/javascript/statements",
            "nextName": "Types",
            "nextPath": "/javascript/types"
          },
          {
            "name": "Types",
            "subitems": [],
            "path": "/javascript/types",
            "prevName": "Functions",
            "prevPath": "/javascript/functions",
            "nextName": "Classes",
            "nextPath": "/javascript/classes"
          },
          {
            "name": "Classes",
            "subitems": [],
            "path": "/javascript/classes",
            "prevName": "Types",
            "prevPath": "/javascript/types",
            "nextName": "Interfaces",
            "nextPath": "/javascript/interfaces"
          },
          {
            "name": "Interfaces",
            "subitems": [],
            "path": "/javascript/interfaces",
            "prevName": "Classes",
            "prevPath": "/javascript/classes",
            "nextName": "Generics",
            "nextPath": "/javascript/generics"
          },
          {
            "name": "Generics",
            "subitems": [],
            "path": "/javascript/generics",
            "prevName": "Interfaces",
            "prevPath": "/javascript/interfaces",
            "nextName": "Types",
            "nextPath": "/types"
          }
        ],
        "path": "/javascript",
        "prevName": "Custom blocks",
        "prevPath": "/blocks/custom",
        "nextName": "Calling",
        "nextPath": "/javascript/call"
      },
      {
        "name": "Types",
        "subitems": [
          {
            "name": "Number",
            "subitems": [],
            "path": "/types/number",
            "prevName": "Types",
            "prevPath": "/types",
            "nextName": "String",
            "nextPath": "/types/string"
          },
          {
            "name": "String",
            "subitems": [],
            "path": "/types/string",
            "prevName": "Number",
            "prevPath": "/types/number",
            "nextName": "Boolean",
            "nextPath": "/types/boolean"
          },
          {
            "name": "Boolean",
            "subitems": [],
            "path": "/types/boolean",
            "prevName": "String",
            "prevPath": "/types/string",
            "nextName": "Array",
            "nextPath": "/types/array"
          },
          {
            "name": "Array",
            "subitems": [],
            "path": "/types/array",
            "prevName": "Boolean",
            "prevPath": "/types/boolean",
            "nextName": "Function",
            "nextPath": "/types/function"
          },
          {
            "name": "Function",
            "subitems": [],
            "path": "/types/function",
            "prevName": "Array",
            "prevPath": "/types/array",
            "nextName": "Image",
            "nextPath": "/types/image"
          },
          {
            "name": "Image",
            "subitems": [],
            "path": "/types/image",
            "prevName": "Function",
            "prevPath": "/types/function",
            "nextName": "Sprite",
            "nextPath": "/types/sprite"
          },
          {
            "name": "Sprite",
            "subitems": [],
            "path": "/types/sprite",
            "prevName": "Image",
            "prevPath": "/types/image",
            "nextName": "About",
            "nextPath": "/about"
          }
        ],
        "path": "/types",
        "prevName": "Generics",
        "prevPath": "/javascript/generics",
        "nextName": "Number",
        "nextPath": "/types/number"
      },
      {
        "name": "",
        "subitems": [
          {
            "name": "About",
            "subitems": [],
            "path": "/about",
            "prevName": "Sprite",
            "prevPath": "/types/sprite",
            "nextName": "Support",
            "nextPath": "/support"
          },
          {
            "name": "Support",
            "subitems": [],
            "path": "/support",
            "prevName": "About",
            "prevPath": "/about",
            "nextName": "Translate",
            "nextPath": "/translate"
          },
          {
            "name": "Translate",
            "subitems": [],
            "path": "/translate",
            "prevName": "Support",
            "prevPath": "/support",
            "nextName": "Sharing projects",
            "nextPath": "/share"
          },
          {
            "name": "Sharing projects",
            "subitems": [],
            "path": "/share",
            "prevName": "Translate",
            "prevPath": "/translate",
            "nextName": "Offline support",
            "nextPath": "/offline"
          },
          {
            "name": "Offline support",
            "subitems": [],
            "path": "/offline",
            "prevName": "Sharing projects",
            "prevPath": "/share",
            "nextName": "Save",
            "nextPath": "/save"
          },
          {
            "name": "Save",
            "subitems": [],
            "path": "/save",
            "prevName": "Offline support",
            "prevPath": "/offline",
            "nextName": "Command Line Interface",
            "nextPath": "/cli"
          }
        ],
        "prevName": "Sprite",
        "prevPath": "/types/sprite"
      },
      {
        "name": "",
        "subitems": [
          {
            "name": "Command Line Interface",
            "subitems": [],
            "path": "/cli",
            "prevName": "Save",
            "prevPath": "/save",
            "nextName": "Visual Studio Code support",
            "nextPath": "/code"
          },
          {
            "name": "Visual Studio Code support",
            "subitems": [],
            "path": "/code",
            "prevName": "Command Line Interface",
            "prevPath": "/cli",
            "nextName": "Blocks Embed",
            "nextPath": "/blocks-embed"
          },
          {
            "name": "Blocks Embed",
            "subitems": [],
            "path": "/blocks-embed",
            "prevName": "Visual Studio Code support",
            "prevPath": "/code"
          }
        ],
        "prevName": "Save",
        "prevPath": "/save"
      }
    ],
    "id": "arcade",
    "title": "MakeCode Arcade",
    "name": "arcade",
    "htmlDocIncludes": {}
  },
  "versions": {
    "target": "0.1.0",
    "pxt": "5.0.1"
  },
  "blocksprj": {
    "id": "blocksprj",
    "config": {
      "name": "{0}",
      "dependencies": {
        "device": "*"
      },
      "description": "",
      "files": [
        "main.blocks",
        "main.ts",
        "README.md"
      ],
      "additionalFilePaths": []
    },
    "files": {
      "main.blocks": "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n  <block type=\"gameupdate\" x=\"180\" y=\"0\"></block>\n</xml>",
      "main.ts": " ",
      "README.md": " "
    }
  },
  "tsprj": {
    "id": "tsprj",
    "config": {
      "name": "{0}",
      "dependencies": {
        "device": "*"
      },
      "description": "",
      "files": [
        "main.ts",
        "README.md"
      ],
      "additionalFilePaths": []
    },
    "files": {
      "main.ts": " ",
      "README.md": " "
    }
  },
  "bundledpkgs": {
    "animation": {
      "README.md": "# Animations\n\nA small animation library.",
      "animation.ts": "/*\n    Animation library for sprites\n*/\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace animation {\n    //Handles all the updates\n    let _onAnimUpdate: (() => void)[] = null;\n    let _onSpriteUpdate: (() => void)[] = null;\n\n    export class Animation {\n\n        frames: Image[];\n        index: number;\n        interval: number;\n        action: number;\n        lastTime: number;\n\n        constructor(action: number, interval: number) {\n            this.interval = interval;\n            this.index = -1;\n            this.action = action;\n            this.frames = [];\n            this.lastTime = control.millis();\n\n            this._init();\n        }\n\n        _init() {\n            if (!_onAnimUpdate) {\n                _onAnimUpdate = [];\n                game.eventContext().registerFrameHandler(15, () => {\n                    _onAnimUpdate.forEach(element => {\n                        element();\n                    });\n                });\n            }\n            _onAnimUpdate.push(() => this.update());\n        }\n\n        update() {\n            let currentTime = control.millis();\n            let dt = currentTime - this.lastTime;\n            if (dt >= this.interval && this.frames.length) {\n                this.index = (this.index + 1) % this.frames.length;\n                this.lastTime = currentTime;\n            }\n        }\n\n        getImage() {\n            return this.frames[this.index];\n        }\n\n        getAction() {\n            return this.action;\n        }\n\n        getInterval() {\n            return this.interval;\n        }\n\n        setInterval(interval: number) {\n            this.interval = interval;\n        }\n\n        /**\n        * Add an image frame to an animation\n        */\n        //% blockId=addAnimationFrame\n        //% block=\"add frame $frame=screen_image_picker to $this=variables_get(anim)\"\n        //% weight=40\n        //% help=animation/add-animation\n        addAnimationFrame(frame: Image) {\n            this.frames[++this.index] = frame;\n        }\n\n    }\n\n    //% shim=ENUM_GET\n    //% blockId=action_enum_shim\n    //% block=\"%arg\"\n    //% enumName=\"ActionKind\"\n    //% enumMemberName=\"action\"\n    //% enumPromptHint=\"e.g. Walking, Idle, Jumping, ...\"\n    //% enumInitialMembers=\"Walking, Idle, Jumping\"\n    //% weight=10\n    export function _actionEnumShim(arg: number) {\n        // This function should do nothing, but must take in a single\n        // argument of type number and return a number value.\n        return arg;\n    }\n\n    /**\n     * Create an animation\n     */\n    //% blockId=createAnimation\n    //% block=\"create animation of $action=action_enum_shim with interval $interval ms\"\n    //% interval.defl=1000\n    //% blockSetVariable=\"anim\"\n    //% weight=50\n    //% help=animation/create-animation\n    export function createAnimation(action: number, interval: number) {\n        return new Animation(action, interval);\n    }\n\n    /**\n     * Attach an animation to a sprite\n     */\n    //% blockId=attachAnimation\n    //% block=\"attach animation $set=variables_get(anim) to sprite $sprite=variables_get(mySprite)\"\n    //% weight=30\n    //% help=animation/attach-animation\n    export function attachAnimation(sprite: Sprite, set: Animation) {\n        if (!_onSpriteUpdate) {\n            //First attach register the update call back.\n            //Priority 16 is slightly lower than 15 for animation update loop.\n            //This is allow the animation to complete, so we have the new display ready to go.\n            _onSpriteUpdate = [];\n            game.eventContext().registerFrameHandler(16, () => {\n                _onSpriteUpdate.forEach(element => {\n                    element();\n                });\n            });\n        }\n\n        _onSpriteUpdate.push(() => {\n            if (sprite._action === set.action) {\n                let newImage = set.getImage();\n                //Update only if the image has changed\n                if (sprite.image !== newImage) {\n                    sprite.setImage(newImage)\n                }\n            }\n        })\n    }\n\n    /**\n     * Set an animation action to a sprite\n     */\n    //% blockId=setAction\n    //% block=\"activate animation $action=action_enum_shim on $sprite=variables_get(mySprite)\"\n    //% weight=20\n    //% help=animation/set-action\n    export function setAction(sprite: Sprite, action: number) {\n        sprite._action = action;\n    }\n\n}",
      "pxt.json": "{\n    \"name\": \"animation\",\n    \"description\": \"An animation library for sprite\",\n    \"files\": [\n        \"README.md\",\n        \"animation.ts\",\n        \"targetoverrides.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"game\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    },\n    \"icon\": \"/arcade/docs/static/libs/animation.png\"\n}",
      "targetoverrides.ts": "// TODO any platform specific overrides"
    },
    "base": {
      "README.md": "# base\n\nThe base library, shared by all C++ targets (not only Codal-based).\n\n\n",
      "advmath.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\nnamespace Math_ {\n\n//%\nTNumber log2(TNumber x){SINGLE(log2)}\n//%\nTNumber exp(TNumber x){SINGLE(exp)}\n//%\nTNumber tanh(TNumber x){SINGLE(tanh)}\n//%\nTNumber sinh(TNumber x){SINGLE(sinh)}\n//%\nTNumber cosh(TNumber x){SINGLE(cosh)}\n//%\nTNumber atanh(TNumber x){SINGLE(atanh)}\n//%\nTNumber asinh(TNumber x){SINGLE(asinh)}\n//%\nTNumber acosh(TNumber x){SINGLE(acosh)}\n\n}",
      "buffer.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n\nusing namespace std;\n\n//% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\nnamespace BufferMethods {\n//%\nuint8_t *getBytes(Buffer buf) {\n    return buf->data;\n}\n\n//%\nint getByte(Buffer buf, int off) {\n    if (buf && 0 <= off && off < buf->length)\n        return buf->data[off];\n    return 0;\n}\n\n//%\nvoid setByte(Buffer buf, int off, int v) {\n    if (buf && 0 <= off && off < buf->length)\n        buf->data[off] = v;\n}\n\nint writeBuffer(Buffer buf, int dstOffset, Buffer src, int srcOffset = 0, int length = -1) {\n    if (length < 0)\n        length = src->length;\n\n    if (srcOffset < 0 || dstOffset < 0 || dstOffset > buf->length)\n        return -1;\n\n    length = min(src->length - srcOffset, buf->length - dstOffset);\n\n    if (length < 0)\n        return -1;\n\n    if (buf == src) {\n        memmove(buf->data + dstOffset, src->data + srcOffset, length);\n    } else {\n        memcpy(buf->data + dstOffset, src->data + srcOffset, length);\n    }\n\n    return 0;\n}\n\n/**\n * Write a number in specified format in the buffer.\n */\n//%\nvoid setNumber(Buffer buf, NumberFormat format, int offset, TNumber value) {\n    if (offset < 0)\n        return;\n    setNumberCore(buf->data + offset, buf->length - offset, format, value);\n}\n\n/**\n * Read a number in specified format from the buffer.\n */\n//%\nTNumber getNumber(Buffer buf, NumberFormat format, int offset) {\n    if (offset < 0)\n        return fromInt(0);\n    return getNumberCore(buf->data + offset, buf->length - offset, format);\n}\n\n/** Returns the length of a Buffer object. */\n//% property\nint length(Buffer s) {\n    return s->length;\n}\n\n/**\n * Fill (a fragment) of the buffer with given value.\n */\n//%\nvoid fill(Buffer buf, int value, int offset = 0, int length = -1) {\n    if (offset < 0 || offset > buf->length)\n        return; // DEVICE_INVALID_PARAMETER;\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    memset(buf->data + offset, value, length);\n}\n\n/**\n * Return a copy of a fragment of a buffer.\n */\n//%\nBuffer slice(Buffer buf, int offset = 0, int length = -1) {\n    offset = min((int)buf->length, offset);\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    return mkBuffer(buf->data + offset, length);\n}\n\n/**\n * Shift buffer left in place, with zero padding.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid shift(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n    if (offset <= -length || offset >= length) {\n        fill(buf, 0);\n        return;\n    }\n\n    uint8_t *data = buf->data + start;\n    if (offset < 0) {\n        offset = -offset;\n        memmove(data + offset, data, length - offset);\n        memset(data, 0, offset);\n    } else {\n        length = length - offset;\n        memmove(data, data + offset, length);\n        memset(data + length, 0, offset);\n    }\n}\n\n/**\n * Convert a buffer to its hexadecimal representation.\n */\n//%\nString toHex(Buffer buf) {\n    const char *hex = \"0123456789abcdef\";\n    auto res = mkString(NULL, buf->length * 2);\n    for (int i = 0; i < buf->length; ++i) {\n        res->data[i << 1] = hex[buf->data[i] >> 4];\n        res->data[(i << 1) + 1] = hex[buf->data[i] & 0xf];\n    }\n    return res;\n}\n\n/**\n * Rotate buffer left in place.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid rotate(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n\n    if (offset < 0)\n        offset += length << 8; // try to make it positive\n    offset %= length;\n    if (offset < 0)\n        offset += length;\n\n    uint8_t *data = buf->data + start;\n\n    uint8_t *n_first = data + offset;\n    uint8_t *first = data;\n    uint8_t *next = n_first;\n    uint8_t *last = data + length;\n\n    while (first != next) {\n        uint8_t tmp = *first;\n        *first++ = *next;\n        *next++ = tmp;\n        if (next == last) {\n            next = n_first;\n        } else if (first == n_first) {\n            n_first = next;\n        }\n    }\n}\n\n/**\n * Write contents of `src` at `dstOffset` in current buffer.\n */\n//%\nvoid write(Buffer buf, int dstOffset, Buffer src) {\n    // srcOff and length not supported, we only do up to 4 args :/\n    writeBuffer(buf, dstOffset, src, 0, -1);\n}\n}\n\nnamespace control {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n}\n\nnamespace pxt {\nstatic int writeBytes(uint8_t *dst, uint8_t *src, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = dst + length;\n        for (int i = 0; i < length; ++i)\n            *--p = src[i];\n    } else {\n        if (length == 4 && ((uint32_t)dst & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uint32_t)dst & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nstatic int readBytes(uint8_t *src, uint8_t *dst, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        memset(dst, 0, length);\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = src + length;\n        for (int i = 0; i < length; ++i)\n            dst[i] = *--p;\n    } else {\n        if (length == 4 && ((uint32_t)src & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uint32_t)src & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nvoid setNumberCore(uint8_t *buf, int szLeft, NumberFormat format, TNumber value) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define WRITEBYTES(isz, swap, toInt)                                                               \\\n    isz = toInt(value);                                                                            \\\n    writeBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                   \\\n    break\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        WRITEBYTES(i8, false, toInt);\n    case NumberFormat::UInt8LE:\n        WRITEBYTES(u8, false, toInt);\n    case NumberFormat::Int16LE:\n        WRITEBYTES(i16, false, toInt);\n    case NumberFormat::UInt16LE:\n        WRITEBYTES(u16, false, toInt);\n    case NumberFormat::Int32LE:\n        WRITEBYTES(i32, false, toInt);\n    case NumberFormat::UInt32LE:\n        WRITEBYTES(u32, false, toUInt);\n\n    case NumberFormat::Int8BE:\n        WRITEBYTES(i8, true, toInt);\n    case NumberFormat::UInt8BE:\n        WRITEBYTES(u8, true, toInt);\n    case NumberFormat::Int16BE:\n        WRITEBYTES(i16, true, toInt);\n    case NumberFormat::UInt16BE:\n        WRITEBYTES(u16, true, toInt);\n    case NumberFormat::Int32BE:\n        WRITEBYTES(i32, true, toInt);\n    case NumberFormat::UInt32BE:\n        WRITEBYTES(u32, true, toUInt);\n\n    case NumberFormat::Float32LE:\n        WRITEBYTES(f32, false, toFloat);\n    case NumberFormat::Float32BE:\n        WRITEBYTES(f32, true, toFloat);\n    case NumberFormat::Float64LE:\n        WRITEBYTES(f64, false, toDouble);\n    case NumberFormat::Float64BE:\n        WRITEBYTES(f64, true, toDouble);\n    }\n}\n\nTNumber getNumberCore(uint8_t *buf, int szLeft, NumberFormat format) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define READBYTES(isz, swap, conv)                                                                 \\\n    readBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                    \\\n    return conv(isz)\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        READBYTES(i8, false, fromInt);\n    case NumberFormat::UInt8LE:\n        READBYTES(u8, false, fromInt);\n    case NumberFormat::Int16LE:\n        READBYTES(i16, false, fromInt);\n    case NumberFormat::UInt16LE:\n        READBYTES(u16, false, fromInt);\n    case NumberFormat::Int32LE:\n        READBYTES(i32, false, fromInt);\n    case NumberFormat::UInt32LE:\n        READBYTES(u32, false, fromUInt);\n\n    case NumberFormat::Int8BE:\n        READBYTES(i8, true, fromInt);\n    case NumberFormat::UInt8BE:\n        READBYTES(u8, true, fromInt);\n    case NumberFormat::Int16BE:\n        READBYTES(i16, true, fromInt);\n    case NumberFormat::UInt16BE:\n        READBYTES(u16, true, fromInt);\n    case NumberFormat::Int32BE:\n        READBYTES(i32, true, fromInt);\n    case NumberFormat::UInt32BE:\n        READBYTES(u32, true, fromUInt);\n\n    case NumberFormat::Float32LE:\n        READBYTES(f32, false, fromFloat);\n    case NumberFormat::Float32BE:\n        READBYTES(f32, true, fromFloat);\n    case NumberFormat::Float64LE:\n        READBYTES(f64, false, fromDouble);\n    case NumberFormat::Float64BE:\n        READBYTES(f64, true, fromDouble);\n    }\n\n    return 0;\n}\n}",
      "buffer.ts": "namespace pins {\n    /**\n     * Get the size in bytes of specified number format.\n     */\n    //%\n    export function sizeOf(format: NumberFormat) {\n        switch (format) {\n            case NumberFormat.Int8LE:\n            case NumberFormat.UInt8LE:\n            case NumberFormat.Int8BE:\n            case NumberFormat.UInt8BE:\n                return 1;\n            case NumberFormat.Int16LE:\n            case NumberFormat.UInt16LE:\n            case NumberFormat.Int16BE:\n            case NumberFormat.UInt16BE:\n                return 2;\n            case NumberFormat.Int32LE:\n            case NumberFormat.Int32BE:\n            case NumberFormat.UInt32BE:\n            case NumberFormat.UInt32LE:\n            case NumberFormat.Float32BE:\n            case NumberFormat.Float32LE:\n                return 4;\n            case NumberFormat.Float64BE:\n            case NumberFormat.Float64LE:\n                return 8;\n        }\n        return 0;\n    }\n\n    /**\n     * Create a new buffer initalized to bytes from given array.\n     * @param bytes data to initalize with\n     */\n    //%\n    export function createBufferFromArray(bytes: number[]) {\n        let buf = control.createBuffer(bytes.length)\n        for (let i = 0; i < bytes.length; ++i)\n            buf[i] = bytes[i]\n        return buf\n    }\n\n    function getFormat(pychar: string, isBig: boolean) {\n        switch (pychar) {\n            case 'B':\n                return NumberFormat.UInt8LE\n            case 'b':\n                return NumberFormat.Int8LE\n            case 'H':\n                return isBig ? NumberFormat.UInt16BE : NumberFormat.UInt16LE\n            case 'h':\n                return isBig ? NumberFormat.Int16BE : NumberFormat.Int16LE\n            case 'I':\n            case 'L':\n                return isBig ? NumberFormat.UInt32BE : NumberFormat.UInt32LE\n            case 'i':\n            case 'l':\n                return isBig ? NumberFormat.Int32BE : NumberFormat.Int32LE\n            case 'f':\n                return isBig ? NumberFormat.Float32BE : NumberFormat.Float32LE\n            case 'd':\n                return isBig ? NumberFormat.Float64BE : NumberFormat.Float64LE\n            default:\n                return null as NumberFormat\n        }\n    }\n\n    function packUnpackCore(format: string, nums: number[], buf: Buffer, isPack: boolean, off = 0) {\n        let isBig = false\n        let idx = 0\n        for (let i = 0; i < format.length; ++i) {\n            switch (format[i]) {\n                case ' ':\n                case '<':\n                case '=':\n                    isBig = false\n                    break\n                case '>':\n                case '!':\n                    isBig = true\n                    break\n                case 'x':\n                    off++\n                    break\n                default:\n                    let fmt = getFormat(format[i], isBig)\n                    if (fmt === null) {\n                        control.fail(\"Not supported format character: \" + format[i])\n                    } else {\n                        if (buf) {\n                            if (isPack)\n                                buf.setNumber(fmt, off, nums[idx++])\n                            else\n                                nums.push(buf.getNumber(fmt, off))\n                        }\n\n                        off += pins.sizeOf(fmt)\n                    }\n                    break\n            }\n        }\n        return off\n    }\n\n    export function packedSize(format: string) {\n        return packUnpackCore(format, null, null, true)\n    }\n\n    export function packBuffer(format: string, nums: number[]) {\n        let buf = control.createBuffer(packedSize(format))\n        packUnpackCore(format, nums, buf, true)\n        return buf\n    }\n\n    export function packIntoBuffer(format: string, buf: Buffer, offset: number, nums: number[]) {\n        packUnpackCore(format, nums, buf, true, offset)\n    }\n\n    export function unpackBuffer(format: string, buf: Buffer, offset = 0) {\n        let res: number[] = []\n        packUnpackCore(format, res, buf, false, offset)\n        return res\n    }\n}\n\n// see http://msgpack.org/ for the spec\n// it currently only implements numbers and their sequances\n// once we handle any type and typeof expressions we can do more\n\nnamespace msgpack {\n    function tagFormat(tag: number) {\n        switch (tag) {\n            case 0xCB: return NumberFormat.Float64BE\n            case 0xCC: return NumberFormat.UInt8BE\n            case 0xCD: return NumberFormat.UInt16BE\n            case 0xCE: return NumberFormat.UInt32BE\n            case 0xD0: return NumberFormat.Int8BE\n            case 0xD1: return NumberFormat.Int16BE\n            case 0xD2: return NumberFormat.Int32BE\n            default:\n                return null\n        }\n    }\n\n    function packNumberCore(buf: Buffer, offset: number, num: number) {\n        let tag = 0xCB\n        if (num == (num << 0) || num == (num >>> 0)) {\n            if (-31 <= num && num <= 127) {\n                if (buf) buf[offset] = num\n                return 1\n            } else if (0 <= num) {\n                if (num <= 0xff) {\n                    tag = 0xCC\n                } else if (num <= 0xffff) {\n                    tag = 0xCD\n                } else {\n                    tag = 0xCE\n                }\n            } else {\n                if (-0x7f <= num) {\n                    tag = 0xD0\n                } else if (-0x7fff <= num) {\n                    tag = 0xD1\n                } else {\n                    tag = 0xD2\n                }\n            }\n        }\n        let fmt = tagFormat(tag)\n        if (buf) {\n            buf[offset] = tag\n            buf.setNumber(fmt, offset + 1, num)\n        }\n        return pins.sizeOf(fmt) + 1\n    }\n\n    /**\n     * Unpacks a buffer into a number array.\n     */\n    export function unpackNumberArray(buf: Buffer, offset = 0): number[] {\n        let res: number[] = []\n\n        while (offset < buf.length) {\n            let fmt = tagFormat(buf[offset++])\n            if (fmt === null) {\n                let v = buf.getNumber(NumberFormat.Int8BE, offset - 1)\n                if (-31 <= v && v <= 127)\n                    res.push(v)\n                else\n                    return null\n            } else {\n                res.push(buf.getNumber(fmt, offset))\n                offset += pins.sizeOf(fmt)\n            }\n            // padding at the end\n            while (buf[offset] === 0xc1) offset++;\n        }\n\n        return res\n    }\n\n    /**\n     * Pack a number array into a buffer.\n     * @param nums the numbers to be packed\n     */\n    export function packNumberArray(nums: number[]): Buffer {\n        let off = 0\n        for (let n of nums) {\n            off += packNumberCore(null, off, n)\n        }\n        let buf = control.createBuffer(off)\n        off = 0\n        for (let n of nums) {\n            off += packNumberCore(buf, off, n)\n        }\n        return buf\n    }\n}\n\ninterface Buffer {\n    [index: number]: number;\n    // rest defined in buffer.cpp\n}",
      "console.ts": "/// <reference no-default-lib=\"true\"/>\n\n/**\n * Reading and writing data to the console output.\n */\n//% weight=12 color=#002050 icon=\"\\uf120\"\n//% advanced=true\nnamespace console {\n    type Listener = (text: string) => void;\n\n    //% whenUsed\n    const listeners: Listener[] = [function(text: string) { control.__log(text); }];\n\n    /**\n     * Write a line of text to the console output.\n     * @param value to send\n     */\n    //% weight=90\n    //% help=console/log blockGap=8\n    //% blockId=console_log block=\"console|log %text\"\n    //% text.shadowOptions.toString=true\n    export function log(text: string): void {\n        // pad text on the 32byte boundar\n        text += \"\\r\\n\";\n        // send to listeners\n        for (let i = 0; i < listeners.length; ++i)\n            listeners[i](text);\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the console output.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=console/log-value\n    //% blockId=console_log_value block=\"console|log value %name|= %value\"\n    export function logValue(name: string, value: number): void {\n        log(name ? `${name}: ${value}` : `${value}`)\n    }\n\n    /**\n     * Adds a listener for the log messages\n     * @param listener\n     */\n    //%\n    export function addListener(listener: (text: string) => void) {\n        if (!listener) return;\n        listeners.push(listener);\n    }\n}",
      "control.cpp": "#include \"pxtbase.h\"\n\n\nnamespace control {\n    /**\n    * Gets the number of milliseconds elapsed since power on.\n    */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\"\n    int millis() {\n        return current_time_ms();\n    }\n\n    /**\n    * Used internally\n    */\n    //%\n    void internalOnEvent(int src, int value, Action handler, int flags = 16) {\n        registerWithDal(src, value, handler, flags);\n    }\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\"\n    void reset() {\n        target_reset();\n    }\n\n    /**\n    * Block the current fiber for the given microseconds\n    * @param micros number of micro-seconds to wait. eg: 4\n    */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (µs)%micros\"\n    void waitMicros(int micros) {\n        sleep_us(micros);\n    }\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8\n    void runInParallel(Action a) {\n        pxt::runInParallel(a);\n    }\n\n    /**\n    * Blocks the calling thread until the specified event is raised.\n    */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\"\n    void waitForEvent(int src, int value) {\n        pxt::waitForEvent(src, value);\n    }\n\n    /**\n    * Derive a unique, consistent serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number\n    int deviceSerialNumber() {\n        return pxt::getSerialNumber();\n    }\n\n    /**\n    *\n    */\n    //%\n    void __log(String text) {\n        if (NULL == text) return;\n        pxt::sendSerial(text->data, text->length);\n    }\n\n    /**\n     * Dump internal information about a value.\n     */\n    //%\n    void dmesgValue(TValue v) {\n        anyPrint(v);\n    }\n\n    /**\n     * Force GC and dump information about heap.\n     */\n    //%\n    void gc() {\n        pxt::gc(1);\n    }\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //%\n    bool profilingEnabled() {\n#ifdef PXT_PROFILE\n        return true;\n#else\n        return false;\n#endif\n    }\n}\n",
      "control.ts": "/**\n* Program controls and events.\n*/\n//% weight=10 color=\"#31bca3\" icon=\"\\uf110\" advanced=true\nnamespace control {\n    /**\n     * Deprecated, use ``control.runInParallel`` instead.\n     */\n    //% deprecated=1 hidden=1 help=control/run-in-background blockAllowMultiple=1 afterOnStart=true\n    //% blockId=\"control_run_in_background\" block=\"run in background\" blockGap=8 weight=0\n    export function runInBackground(a: () => void) {\n        control.runInParallel(a);\n    }\n\n    /**\n     * Display an error code and stop the program.\n     * @param code an error number to display. eg: 5\n     */\n    //% help=control/panic weight=29\n    //% blockId=\"control_panic\" block=\"panic %code\"\n    //% shim=pxtrt::panic\n    export function panic(code: number) { }\n\n    /**\n     * Enable profiling for current function.\n     */\n    //% shim=TD_NOOP shimArgument=perfCounter\n    export function enablePerfCounter(name?: string) { }\n\n    /**\n     * Dump values of profiling performance counters.\n     */\n    //% shim=pxt::dumpPerfCounters\n    export function dmesgPerfCounters() { }\n\n    /**\n     * Display an error code and stop the program when the assertion is `false`.\n     */\n    //% help=control/assert weight=30\n    //% blockId=\"control_assert\" block=\"assert %cond|with value %code\"\n    export function assert(cond: boolean, code: number) {\n        if (!cond) {\n            fail(\"Assertion failed, code=\" + code)\n        }\n    }\n\n    export function fail(message: string) {\n        console.log(\"Fatal failure: \")\n        console.log(message)\n        panic(108)\n    }\n\n    export class AnimationQueue {\n        running: boolean;\n        eventID: number;\n        public interval: number;\n\n        constructor() {\n            this.running = false;\n            this.eventID = control.allocateNotifyEvent();\n            this.interval = 1;\n        }\n\n        /**\n         * Runs 'render' in a loop until it returns false or the 'stop' function is called\n         */\n        runUntilDone(render: () => boolean) {\n            const evid = this.eventID;\n\n            // if other animation, wait for turn\n            if (this.running)\n                control.waitForEvent(DAL.DEVICE_ID_NOTIFY, evid);\n\n            // check if the animation hasn't been cancelled since we've waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // run animation\n            this.running = true;\n            while (this.running\n                && !this.isCancelled(evid)\n                && render()) {\n                pause(this.interval);\n            }\n\n            // check if the animation hasn't been cancelled since we've been waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // we're done\n            this.running = false;\n            // unblock 1 fiber\n            control.raiseEvent(DAL.DEVICE_ID_NOTIFY_ONE, this.eventID);\n        }\n\n        isCancelled(evid: number) {\n            return this.eventID !== evid;\n        }\n\n        /**\n         * Cancels the current running animation and clears the queue\n         */\n        cancel() {\n            if (this.running) {\n                this.running = false;\n                const evid = this.eventID;\n                this.eventID = control.allocateNotifyEvent();\n                // unblock fibers\n                control.raiseEvent(DAL.DEVICE_ID_NOTIFY, evid);\n            }\n        }\n    }\n\n    class PollEvent {\n        public eid: number;\n        public vid: number;\n        public start: number;\n        public timeOut: number;\n        public condition: () => boolean;\n        public once: boolean;\n        constructor(eid: number, vid: number, start: number, timeOut: number, condition: () => boolean, once: boolean) {\n            this.eid = eid;\n            this.vid = vid;\n            this.start = start;\n            this.timeOut = timeOut;\n            this.condition = condition;\n            this.once = once;\n        }\n    }\n\n    let _pollEventQueue: PollEvent[] = undefined;\n\n    function pollEvents() {\n        while (_pollEventQueue.length > 0) {\n            const now = control.millis();\n            for (let i = 0; i < _pollEventQueue.length; ++i) {\n                const ev = _pollEventQueue[i];\n                if (ev.condition() || (ev.timeOut > 0 && now - ev.start > ev.timeOut)) {\n                    control.raiseEvent(ev.eid, ev.vid);\n                    if (ev.once) {\n                        _pollEventQueue.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            pause(50);\n        }\n        // release fiber\n        _pollEventQueue = undefined;\n    }\n\n    export function __queuePollEvent(timeOut: number, condition: () => boolean, handler: () => void) {\n        const ev = new PollEvent(\n            control.allocateNotifyEvent(),\n            1,\n            control.millis(),\n            timeOut,\n            condition,\n            !handler\n        );\n\n        // start polling fiber if needed\n        if (!_pollEventQueue) {\n            _pollEventQueue = [ev];\n            control.runInParallel(pollEvents);\n        }\n        else {\n            // add to the queue\n            _pollEventQueue.push(ev)\n        }\n\n        // register event\n        if (handler)\n            control.onEvent(ev.eid, ev.vid, handler);\n        else // or wait\n            control.waitForEvent(ev.eid, ev.vid);\n    }\n\n    //% shim=pxt::getConfig\n    export declare function getConfigValue(key: int32, defl: int32): number;\n}\n\n/**\n * Busy wait for a condition to be true\n * @param condition condition to test for\n * @param timeOut if positive, maximum duration to wait for in milliseconds\n */\n//% blockId=\"pxt_pause_until\"\nfunction pauseUntil(condition: () => boolean, timeOut?: number): void {\n    if (!condition || condition()) return; // optimistic path\n    if (!timeOut) timeOut = 0;\n    control.__queuePollEvent(timeOut, condition, undefined);\n}\n\n/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true blockNamespace=\"loops\"\n//% blockId=forever block=\"forever\" blockAllowMultiple=1\nfunction forever(a: () => void): void {\n    loops.forever(a);\n}\n\n/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause blockNamespace=\"loops\"\nfunction pause(ms: number): void {\n    loops.pause(ms);\n}\n\n/**\n * Tagged hex literal converter\n */\n//% shim=@hex\nfunction hex(lits: any, ...args: any[]): Buffer { return null }\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function pause(millis: number) {\n        loops.pause(millis);\n    }\n}",
      "core.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#define p10(v) __builtin_powi(10, v)\n\nnamespace pxt {\n\nstatic HandlerBinding *handlerBindings;\n\nHandlerBinding *findBinding(int source, int value) {\n    for (auto p = handlerBindings; p; p = p->next) {\n        if (p->source == source && p->value == value) {\n            return p;\n        }\n    }\n    return 0;\n}\n\nvoid setBinding(int source, int value, Action act) {\n    auto curr = findBinding(source, value);\n    incr(act);\n    if (curr) {\n        decr(curr->action);\n        curr->action = act;\n        return;\n    }\n    curr = new HandlerBinding();\n    curr->next = handlerBindings;\n    curr->source = source;\n    curr->value = value;\n    curr->action = act;\n    registerGC(&curr->action);\n    handlerBindings = curr;\n}\n\nPXT_DEF_STRING(emptyString, \"\")\n\nstatic const char emptyBuffer[] __attribute__((aligned(4))) = \"@PXT#:\\x00\\x00\\x00\";\n\nString mkString(const char *data, int len) {\n    if (len < 0)\n        len = strlen(data);\n    if (len == 0)\n        return (String)emptyString;\n    String r = new (gcAllocate(sizeof(BoxedString) + len + 1)) BoxedString();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    r->data[len] = 0;\n    MEMDBG(\"mkString: len=%d => %p\", len, r);\n    return r;\n}\n\nBuffer mkBuffer(const uint8_t *data, int len) {\n    if (len <= 0)\n        return (Buffer)emptyBuffer;\n    Buffer r = new (gcAllocate(sizeof(BoxedBuffer) + len)) BoxedBuffer();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    else\n        memset(r->data, 0, len);\n    MEMDBG(\"mkBuffer: len=%d => %p\", len, r);\n    return r;\n}\n\nstatic unsigned random_value = 0xC0DA1;\n\nvoid seedRandom(unsigned seed) {\n    random_value = seed;\n}\n\nunsigned getRandom(unsigned max) {\n    unsigned m, result;\n\n    do {\n        m = (unsigned)max;\n        result = 0;\n\n        do {\n            // Cycle the LFSR (Linear Feedback Shift Register).\n            // We use an optimal sequence with a period of 2^32-1, as defined by Bruce Schneier here\n            // (a true legend in the field!),\n            // For those interested, it's documented in his paper:\n            // \"Pseudo-Random Sequence Generator for 32-Bit CPUs: A fast, machine-independent\n            // generator for 32-bit Microprocessors\"\n            // https://www.schneier.com/paper-pseudorandom-sequence.html\n            unsigned r = random_value;\n\n            r = ((((r >> 31) ^ (r >> 6) ^ (r >> 4) ^ (r >> 2) ^ (r >> 1) ^ r) & 1) << 31) |\n                (r >> 1);\n\n            random_value = r;\n\n            result = ((result << 1) | (r & 0x00000001));\n        } while (m >>= 1);\n    } while (result > (unsigned)max);\n\n    return result;\n}\n\nPXT_DEF_STRING(sTrue, \"true\")\nPXT_DEF_STRING(sFalse, \"false\")\nPXT_DEF_STRING(sUndefined, \"undefined\")\nPXT_DEF_STRING(sNull, \"null\")\nPXT_DEF_STRING(sObject, \"[Object]\")\nPXT_DEF_STRING(sFunction, \"[Function]\")\nPXT_DEF_STRING(sNaN, \"NaN\")\nPXT_DEF_STRING(sInf, \"Infinity\")\nPXT_DEF_STRING(sMInf, \"-Infinity\")\n} // namespace pxt\n\n#ifndef X86_64\n\nnamespace String_ {\n\n//%\nString mkEmpty() {\n    return mkString(\"\", 0);\n}\n\n//%\nString fromCharCode(int code) {\n    char buf[] = {(char)code, 0};\n    return mkString(buf, 1);\n}\n\n//%\nString charAt(String s, int pos) {\n    if (s && 0 <= pos && pos < s->length) {\n        return fromCharCode(s->data[pos]);\n    } else {\n        return mkEmpty();\n    }\n}\n\n//%\nTNumber charCodeAt(String s, int pos) {\n    if (s && 0 <= pos && pos < s->length) {\n        return fromInt(s->data[pos]);\n    } else {\n        return TAG_NAN;\n    }\n}\n\n//%\nString concat(String s, String other) {\n    if (!s)\n        s = (String)sNull;\n    if (!other)\n        other = (String)sNull;\n    if (s->length == 0)\n        return (String)incrRC(other);\n    if (other->length == 0)\n        return (String)incrRC(s);\n    String r = mkString(NULL, s->length + other->length);\n    memcpy(r->data, s->data, s->length);\n    memcpy(r->data + s->length, other->data, other->length);\n    return r;\n}\n\nint compare(String a, String b) {\n    if (a == b)\n        return 0;\n\n    int compareResult = strcmp(a->data, b->data);\n    if (compareResult < 0)\n        return -1;\n    else if (compareResult > 0)\n        return 1;\n    return 0;\n}\n\n//%\nint length(String s) {\n    return s->length;\n}\n\n#define isspace(c) ((c) == ' ')\n\nNUMBER mystrtod(const char *p, char **endp) {\n    while (isspace(*p))\n        p++;\n    NUMBER m = 1;\n    NUMBER v = 0;\n    int dot = 0;\n    if (*p == '+')\n        p++;\n    if (*p == '-') {\n        m = -1;\n        p++;\n    }\n    if (*p == '0' && (p[1] | 0x20) == 'x') {\n        return m * strtol(p, endp, 16);\n    }\n    while (*p) {\n        int c = *p - '0';\n        if (0 <= c && c <= 9) {\n            v *= 10;\n            v += c;\n            if (dot)\n                m /= 10;\n        } else if (!dot && *p == '.') {\n            dot = 1;\n        } else if (*p == 'e' || *p == 'E') {\n            break;\n        } else {\n            while (isspace(*p))\n                p++;\n            if (*p)\n                return NAN;\n            break;\n        }\n        p++;\n    }\n\n    v *= m;\n\n    if (*p) {\n        p++;\n        int pw = strtol(p, endp, 10);\n        v *= p10(pw);\n    } else {\n        *endp = (char *)p;\n    }\n\n    return v;\n}\n\n//%\nTNumber toNumber(String s) {\n    // JSCHECK\n    char *endptr;\n    NUMBER v = mystrtod(s->data, &endptr);\n    if (endptr != s->data + s->length)\n        v = NAN;\n    else if (v == 0.0 || v == -0.0)\n        v = v;\n    else if (!isnormal(v))\n        v = NAN;\n    return fromDouble(v);\n}\n\n//%\nString substr(String s, int start, int length) {\n    if (length <= 0)\n        return mkEmpty();\n    if (start < 0)\n        start = max(s->length + start, 0);\n    length = min(length, s->length - start);\n    return mkString(s->data + start, length);\n}\n\n//%\nint indexOf(String s, String searchString, int start) {\n    if (!s || !searchString)\n        return -1;\n    if (start < 0 || start + searchString->length > s->length)\n        return -1;\n    const char *match = strstr(((const char *)s->data + start), searchString->data);\n    if (NULL == match)\n        return -1;\n    return match - s->data;\n}\n\n//%\nint includes(String s, String searchString, int start) {\n    return -1 != indexOf(s, searchString, start);\n}\n\n} // namespace String_\n\nnamespace Boolean_ {\n//%\nbool bang(int v) {\n    return v == 0;\n}\n} // namespace Boolean_\n\nnamespace pxt {\n\n// ES5 9.5, 9.6\nunsigned toUInt(TNumber v) {\n    if (isNumber(v))\n        return numValue(v);\n    if (isSpecial(v)) {\n        if ((intptr_t)v >> 6)\n            return 1;\n        else\n            return 0;\n    }\n    if (!v)\n        return 0;\n\n    NUMBER num = toDouble(v);\n    if (!isnormal(num))\n        return 0;\n#ifdef PXT_USE_FLOAT\n    float rem = fmodf(truncf(num), 4294967296.0);\n#else\n    double rem = fmod(trunc(num), 4294967296.0);\n#endif\n    if (rem < 0.0)\n        rem += 4294967296.0;\n    return (unsigned)rem;\n}\nint toInt(TNumber v) {\n    return (int)toUInt(v);\n}\n\nNUMBER toDouble(TNumber v) {\n    if (v == TAG_NAN || v == TAG_UNDEFINED)\n        return NAN;\n    if (isTagged(v))\n        return toInt(v);\n\n    ValType t = valType(v);\n    if (t == ValType::Number) {\n        BoxedNumber *p = (BoxedNumber *)v;\n        return p->num;\n    } else if (t == ValType::String) {\n        // TODO avoid allocation\n        auto tmp = String_::toNumber((String)v);\n        auto r = toDouble(tmp);\n        decr(tmp);\n        return r;\n    } else {\n        return NAN;\n    }\n}\n\nfloat toFloat(TNumber v) {\n    // TODO optimize?\n    return (float)toDouble(v);\n}\n\n#if !defined(PXT_HARD_FLOAT) && !defined(PXT_USE_FLOAT)\nunion NumberConv {\n    double v;\n    struct {\n        uint32_t word0;\n        uint32_t word1;\n    };\n};\n\nstatic inline TValue doubleToInt(double x) {\n    NumberConv cnv;\n    cnv.v = x;\n\n    if (cnv.word1 == 0 && cnv.word0 == 0)\n        return TAG_NUMBER(0);\n\n    auto ex = (int)((cnv.word1 << 1) >> 21) - 1023;\n\n    // DMESG(\"v=%d/1000 %p %p %d\", (int)(x * 1000), cnv.word0, cnv.word1, ex);\n\n    if (ex < 0 || ex > 29) {\n        // the 'MININT' case\n        if (ex == 30 && cnv.word0 == 0 && cnv.word1 == 0xC1D00000)\n            return (TValue)(0x80000001);\n        return NULL;\n    }\n\n    int32_t r;\n\n    if (ex <= 20) {\n        if (cnv.word0)\n            return TAG_UNDEFINED;\n        if (cnv.word1 << (ex + 12))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n    } else {\n        if (cnv.word0 << (ex - 20))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n        r |= cnv.word0 >> (32 - (ex - 20));\n    }\n\n    if (cnv.word1 >> 31)\n        return TAG_NUMBER(-r);\n    else\n        return TAG_NUMBER(r);\n}\n#else\nstatic inline TValue doubleToInt(NUMBER r) {\n    int ri = ((int)r) << 1;\n    if ((ri >> 1) == r)\n        return (TNumber)(ri | 1);\n    return TAG_UNDEFINED;\n}\n#endif\n\nTNumber fromDouble(NUMBER r) {\n#ifndef PXT_BOX_DEBUG\n    auto i = doubleToInt(r);\n    if (i)\n        return i;\n#endif\n    if (isnan(r))\n        return TAG_NAN;\n    BoxedNumber *p = NEW_GC(BoxedNumber);\n    p->num = r;\n    MEMDBG(\"mkNum: %d/1000 => %p\", (int)(r * 1000), p);\n    return (TNumber)p;\n}\n\nTNumber fromFloat(float r) {\n    // TODO optimize\n    return fromDouble(r);\n}\n\nTNumber fromInt(int v) {\n    if (canBeTagged(v))\n        return TAG_NUMBER(v);\n    return fromDouble(v);\n}\n\nTNumber fromUInt(unsigned v) {\n#ifndef PXT_BOX_DEBUG\n    if (v <= 0x3fffffff)\n        return TAG_NUMBER(v);\n#endif\n    return fromDouble(v);\n}\n\nTValue fromBool(bool v) {\n    if (v)\n        return TAG_TRUE;\n    else\n        return TAG_FALSE;\n}\n\nTNumber eqFixup(TNumber v) {\n    if (v == TAG_NULL)\n        return TAG_UNDEFINED;\n    if (v == TAG_TRUE)\n        return TAG_NUMBER(1);\n    if (v == TAG_FALSE)\n        return TAG_NUMBER(0);\n    return v;\n}\n\nstatic inline bool eq_core(TValue a, TValue b, ValType ta) {\n#ifndef PXT_BOX_DEBUG\n    int aa = (int)a;\n    int bb = (int)b;\n\n    // if at least one of the values is tagged, they are not equal\n    if ((aa | bb) & 3)\n        return false;\n#endif\n\n    if (ta == ValType::String)\n        return String_::compare((String)a, (String)b) == 0;\n    else if (ta == ValType::Number)\n        return toDouble(a) == toDouble(b);\n    else\n        return a == b;\n}\n\nbool eqq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (a == b)\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\nbool eq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (eqFixup(a) == eqFixup(b))\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if ((ta == ValType::String && tb == ValType::Number) ||\n        (tb == ValType::String && ta == ValType::Number))\n        return toDouble(a) == toDouble(b);\n\n    if (ta == ValType::Boolean) {\n        a = eqFixup(a);\n        ta = ValType::Number;\n    }\n    if (tb == ValType::Boolean) {\n        b = eqFixup(b);\n        tb = ValType::Number;\n    }\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\n// TODO move to assembly\n//%\nbool switch_eq(TValue a, TValue b) {\n    if (eq_bool(a, b)) {\n        decr(b);\n        return true;\n    }\n    return false;\n}\n\n} // namespace pxt\n\n#define NUMOP(op) return fromDouble(toDouble(a) op toDouble(b));\n#define BITOP(op) return fromInt(toInt(a) op toInt(b));\nnamespace numops {\n\nint toBool(TValue v) {\n    if (isTagged(v)) {\n        if (v == TAG_FALSE || v == TAG_UNDEFINED || v == TAG_NAN || v == TAG_NULL ||\n            v == TAG_NUMBER(0))\n            return 0;\n        else\n            return 1;\n    }\n\n    ValType t = valType(v);\n    if (t == ValType::String) {\n        String s = (String)v;\n        if (s->length == 0)\n            return 0;\n    } else if (t == ValType::Number) {\n        auto x = toDouble(v);\n        if (isnan(x) || x == 0.0 || x == -0.0)\n            return 0;\n        else\n            return 1;\n    }\n\n    return 1;\n}\n\nint toBoolDecr(TValue v) {\n    if (v == TAG_TRUE)\n        return 1;\n    if (v == TAG_FALSE)\n        return 0;\n    int r = toBool(v);\n    decr(v);\n    return r;\n}\n\n// TODO\n// The integer, non-overflow case for add/sub/bit opts is handled in assembly\n\n//%\nTNumber adds(TNumber a, TNumber b){NUMOP(+)}\n\n//%\nTNumber subs(TNumber a, TNumber b){NUMOP(-)}\n\n//%\nTNumber muls(TNumber a, TNumber b) {\n    if (bothNumbers(a, b)) {\n        int aa = (int)a;\n        int bb = (int)b;\n        // if both operands fit 15 bits, the result will not overflow int\n        if ((aa >> 15 == 0 || aa >> 15 == -1) && (bb >> 15 == 0 || bb >> 15 == -1)) {\n            // it may overflow 31 bit int though - use fromInt to convert properly\n            return fromInt((aa >> 1) * (bb >> 1));\n        }\n    }\n    NUMOP(*)\n}\n\n//%\nTNumber div(TNumber a, TNumber b){NUMOP(/)}\n\n//%\nTNumber mod(TNumber a, TNumber b) {\n    if (isNumber(a) && isNumber(b) && numValue(b))\n        BITOP(%)\n    return fromDouble(fmod(toDouble(a), toDouble(b)));\n}\n\n//%\nTNumber lsls(TNumber a, TNumber b){BITOP(<<)}\n\n//%\nTNumber lsrs(TNumber a, TNumber b) {\n    return fromUInt(toUInt(a) >> toUInt(b));\n}\n\n//%\nTNumber asrs(TNumber a, TNumber b){BITOP(>>)}\n\n//%\nTNumber eors(TNumber a, TNumber b){BITOP (^)}\n\n//%\nTNumber orrs(TNumber a, TNumber b){BITOP(|)}\n\n//%\nTNumber bnot(TNumber a) {\n    return fromInt(~toInt(a));\n}\n\n//%\nTNumber ands(TNumber a, TNumber b) {\n    BITOP(&)\n}\n\n#define CMPOP_RAW(op, t, f)                                                                        \\\n    if (bothNumbers(a, b))                                                                         \\\n        return (int)a op((int)b) ? t : f;                                                          \\\n    int cmp = valCompare(a, b);                                                                    \\\n    return cmp != -2 && cmp op 0 ? t : f;\n\n#define CMPOP(op) CMPOP_RAW(op, TAG_TRUE, TAG_FALSE)\n\n// 7.2.13 Abstract Relational Comparison\nstatic int valCompare(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return -2;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta == ValType::String && tb == ValType::String)\n        return String_::compare((String)a, (String)b);\n\n    if (a == b)\n        return 0;\n\n    auto da = toDouble(a);\n    auto db = toDouble(b);\n\n    if (isnan(da) || isnan(db))\n        return -2;\n\n    if (da < db)\n        return -1;\n    else if (da > db)\n        return 1;\n    else\n        return 0;\n}\n\n//%\nbool lt_bool(TNumber a, TNumber b){CMPOP_RAW(<, true, false)}\n\n//%\nTNumber le(TNumber a, TNumber b){CMPOP(<=)}\n\n//%\nTNumber lt(TNumber a, TNumber b){CMPOP(<)}\n\n//%\nTNumber ge(TNumber a, TNumber b){CMPOP(>=)}\n\n//%\nTNumber gt(TNumber a, TNumber b){CMPOP(>)}\n\n//%\nTNumber eq(TNumber a, TNumber b) {\n    return pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neq(TNumber a, TNumber b) {\n    return !pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber eqq(TNumber a, TNumber b) {\n    return pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neqq(TNumber a, TNumber b) {\n    return !pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\nvoid mycvt(NUMBER d, char *buf) {\n    if (d < 0) {\n        *buf++ = '-';\n        d = -d;\n    }\n\n    if (!d) {\n        *buf++ = '0';\n        *buf++ = 0;\n        return;\n    }\n\n    int pw = (int)log10(d);\n    int e = 1;\n    int beforeDot = 1;\n\n    if (0.000001 <= d && d < 1e21) {\n        if (pw > 0) {\n            d /= p10(pw);\n            beforeDot = 1 + pw;\n        }\n    } else {\n        d /= p10(pw);\n        e = pw;\n    }\n\n    int sig = 0;\n    while (sig < 17 || beforeDot > 0) {\n        // printf(\"%f sig=%d bd=%d\\n\", d, sig, beforeDot);\n        int c = (int)d;\n        *buf++ = '0' + c;\n        d = (d - c) * 10;\n        if (--beforeDot == 0)\n            *buf++ = '.';\n        if (sig || c)\n            sig++;\n    }\n\n    buf--;\n    while (*buf == '0')\n        buf--;\n    if (*buf == '.')\n        buf--;\n    buf++;\n\n    if (e != 1) {\n        *buf++ = 'e';\n        itoa(e, buf);\n    } else {\n        *buf = 0;\n    }\n}\n\n#if 0\n//%\nTValue floatAsInt(TValue x) {\n    return doubleToInt(toDouble(x));\n}\n\n//% shim=numops::floatAsInt\nfunction floatAsInt(v: number): number { return 0 }\n\nfunction testInt(i: number) {\n    if (floatAsInt(i) != i)\n        control.panic(101)\n    if (floatAsInt(i + 0.5) != null)\n        control.panic(102)\n    if (floatAsInt(i + 0.00001) != null)\n        control.panic(103)\n}\n\nfunction testFloat(i: number) {\n    if (floatAsInt(i) != null)\n        control.panic(104)\n}\n\nfunction testFloatAsInt() {\n    for (let i = 0; i < 0xffff; ++i) {\n        testInt(i)\n        testInt(-i)\n        testInt(i * 10000)\n        testInt(i << 12)\n        testInt(i + 0x3fff0001)\n        testInt(-i - 0x3fff0002)\n        testFloat(i + 0x3fffffff + 1)\n        testFloat((i + 10000) * 1000000)\n    }   \n}\n#endif\n\nString toString(TValue v) {\n    ValType t = valType(v);\n\n    if (t == ValType::String) {\n        return (String)(void *)incr(v);\n    } else if (t == ValType::Number) {\n        char buf[64];\n\n        if (isNumber(v)) {\n            itoa(numValue(v), buf);\n            return mkString(buf);\n        }\n\n        if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n\n        auto x = toDouble(v);\n\n#ifdef PXT_BOX_DEBUG\n        if (x == (int)x) {\n            itoa((int)x, buf);\n            return mkString(buf);\n        }\n#endif\n\n        if (isinf(x)) {\n            if (x < 0)\n                return (String)(void *)sMInf;\n            else\n                return (String)(void *)sInf;\n        } else if (isnan(x)) {\n            return (String)(void *)sNaN;\n        }\n        mycvt(x, buf);\n\n        return mkString(buf);\n    } else if (t == ValType::Function) {\n        return (String)(void *)sFunction;\n    } else {\n        if (v == TAG_UNDEFINED)\n            return (String)(void *)sUndefined;\n        else if (v == TAG_FALSE)\n            return (String)(void *)sFalse;\n        else if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n        else if (v == TAG_TRUE)\n            return (String)(void *)sTrue;\n        else if (v == TAG_NULL)\n            return (String)(void *)sNull;\n        return (String)(void *)sObject;\n    }\n}\n\n} // namespace numops\n\nnamespace Math_ {\n//%\nTNumber pow(TNumber x, TNumber y) {\n#ifdef PXT_POWI\n    // regular pow() from math.h is 4k of code\n    return fromDouble(__builtin_powi(toDouble(x), toInt(y)));\n#else\n    return fromDouble(::pow(toDouble(x), toDouble(y)));\n#endif\n}\n\n//%\nTNumber atan2(TNumber y, TNumber x) {\n    return fromDouble(::atan2(toDouble(y), toDouble(x)));\n}\n\nNUMBER randomDouble() {\n    return getRandom(UINT_MAX) / ((NUMBER)UINT_MAX + 1) +\n           getRandom(0xffffff) / ((NUMBER)UINT_MAX * 0xffffff);\n}\n\n//%\nTNumber random() {\n    return fromDouble(randomDouble());\n}\n\n//%\nTNumber randomRange(TNumber min, TNumber max) {\n    if (isNumber(min) && isNumber(max)) {\n        int mini = numValue(min);\n        int maxi = numValue(max);\n        if (mini > maxi) {\n            int temp = mini;\n            mini = maxi;\n            maxi = temp;\n        }\n        if (maxi == mini)\n            return fromInt(mini);\n        else\n            return fromInt(mini + getRandom(maxi - mini));\n    } else {\n        auto mind = toDouble(min);\n        auto maxd = toDouble(max);\n        if (mind > maxd) {\n            auto temp = mind;\n            mind = maxd;\n            maxd = temp;\n        }\n        if (maxd == mind)\n            return fromDouble(mind);\n        else {\n            return fromDouble(mind + randomDouble() * (maxd - mind));\n        }\n    }\n}\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber log(TNumber x){SINGLE(log)}\n\n//%\nTNumber log10(TNumber x){SINGLE(log10)}\n\n//%\nTNumber tan(TNumber x){SINGLE(tan)}\n\n//%\nTNumber sin(TNumber x){SINGLE(sin)}\n\n//%\nTNumber cos(TNumber x){SINGLE(cos)}\n\n//%\nTNumber atan(TNumber x){SINGLE(atan)}\n\n//%\nTNumber asin(TNumber x){SINGLE(asin)}\n\n//%\nTNumber acos(TNumber x){SINGLE(acos)}\n\n//%\nTNumber sqrt(TNumber x){SINGLE(sqrt)}\n\n//%\nTNumber floor(TNumber x){SINGLE(floor)}\n\n//%\nTNumber ceil(TNumber x){SINGLE(ceil)}\n\n//%\nTNumber trunc(TNumber x){SINGLE(trunc)}\n\n//%\nTNumber round(TNumber x) {\n    // In C++, round(-1.5) == -2, while in JS, round(-1.5) == -1. Align to the JS convention for\n    // consistency between simulator and device. The following does rounding with ties (x.5) going\n    // towards positive infinity.\n    return fromDouble(::floor(toDouble(x) + 0.5));\n}\n\n//%\nint imul(int x, int y) {\n    return x * y;\n}\n\n//%\nint idiv(int x, int y) {\n    return x / y;\n}\n} // namespace Math_\n\nnamespace Array_ {\nRefCollection *mk() {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl: => %p\", r);\n    return r;\n}\n//%\nint length(RefCollection *c) {\n    return c->length();\n}\n//%\nvoid setLength(RefCollection *c, int newLength) {\n    c->setLength(newLength);\n}\n//%\nvoid push(RefCollection *c, TValue x) {\n    c->push(x);\n}\n//%\nTValue pop(RefCollection *c) {\n    return c->pop();\n}\n//%\nTValue getAt(RefCollection *c, int x) {\n    return c->getAt(x);\n}\n//%\nvoid setAt(RefCollection *c, int x, TValue y) {\n    c->setAt(x, y);\n}\n//%\nTValue removeAt(RefCollection *c, int x) {\n    return c->removeAt(x);\n}\n//%\nvoid insertAt(RefCollection *c, int x, TValue value) {\n    c->insertAt(x, value);\n}\n//%\nint indexOf(RefCollection *c, TValue x, int start) {\n    return c->indexOf(x, start);\n}\n//%\nbool removeElement(RefCollection *c, TValue x) {\n    return c->removeElement(x);\n}\n} // namespace Array_\n\nnamespace pxt {\n//%\nvoid *ptrOfLiteral(int offset);\n\n//%\nunsigned programSize() {\n    return bytecode[17] * 8;\n}\n\n//%\nint getConfig(int key, int defl) {\n    int *cfgData;\n\n#ifdef PXT_BOOTLOADER_CFG_ADDR\n    cfgData = *(int **)(PXT_BOOTLOADER_CFG_ADDR);\n#ifdef PXT_BOOTLOADER_CFG_MAGIC\n    cfgData++;\n    if ((void *)0x200 <= cfgData && cfgData < (void *)PXT_BOOTLOADER_CFG_ADDR &&\n        cfgData[-1] == (int)PXT_BOOTLOADER_CFG_MAGIC)\n#endif\n        for (int i = 0;; i += 2) {\n            if (cfgData[i] == key)\n                return cfgData[i + 1];\n            if (cfgData[i] == 0)\n                break;\n        }\n#endif\n\n    cfgData = *(int **)&bytecode[18];\n    for (int i = 0;; i += 2) {\n        if (cfgData[i] == key)\n            return cfgData[i + 1];\n        if (cfgData[i] == 0)\n            return defl;\n    }\n}\n\n} // namespace pxt\n\nnamespace pxtrt {\n//%\nTValue ldlocRef(RefRefLocal *r) {\n    TValue tmp = r->v;\n    incr(tmp);\n    return tmp;\n}\n\n//%\nvoid stlocRef(RefRefLocal *r, TValue v) {\n    decr(r->v);\n    r->v = v;\n}\n\n//%\nRefRefLocal *mklocRef() {\n    auto r = NEW_GC(RefRefLocal);\n    MEMDBG(\"mklocRef: => %p\", r);\n    return r;\n}\n\n// Store a captured local in a closure. It returns the action, so it can be chained.\n//%\nRefAction *stclo(RefAction *a, int idx, TValue v) {\n    // DBG(\"STCLO \"); a->print(); DBG(\"@%d = %p\\n\", idx, (void*)v);\n    a->stCore(idx, v);\n    return a;\n}\n\n//%\nvoid panic(int code) {\n    target_panic(code);\n}\n\n//%\nString emptyToNull(String s) {\n    if (!s || s->length == 0)\n        return NULL;\n    return s;\n}\n\n//%\nint ptrToBool(TValue p) {\n    if (p) {\n        decr(p);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n//%\nRefMap *mkMap() {\n    auto r = NEW_GC(RefMap);\n    MEMDBG(\"mkMap: => %p\", r);\n    return r;\n}\n\n//%\nTValue mapGetByString(RefMap *map, String key) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        return 0;\n    }\n    TValue r = incr(map->values.get(i));\n    return r;\n}\n\n//%\nint lookupMapKey(String key) {\n    auto arr = *(uintptr_t **)&bytecode[22];\n    auto len = *arr++;\n    auto ikey = (uintptr_t)key;\n    auto l = 0U;\n    auto r = len - 1;\n    if (arr[0] <= ikey && ikey <= arr[len - 1]) {\n        while (l <= r) {\n            auto m = (l + r) >> 1;\n            if (arr[m] == ikey)\n                return m;\n            else if (arr[m] < ikey)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    } else {\n        while (l <= r) {\n            auto m = (l + r) >> 1;\n            auto cmp = String_::compare((String)arr[m], key);\n            if (cmp == 0)\n                return m;\n            else if (cmp < 0)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    }\n    return 0;\n}\n\n//%\nTValue mapGet(RefMap *map, unsigned key) {\n    auto arr = *(String **)&bytecode[22];\n    auto r = mapGetByString(map, arr[key + 1]);\n    map->unref();\n    return r;\n}\n\n//%\nvoid mapSetByString(RefMap *map, String key, TValue val) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        incrRC(key);\n        map->keys.push((TValue)key);\n        map->values.push(val);\n    } else {\n        map->values.setRef(i, val);\n    }\n    incr(val);\n}\n\n//%\nvoid mapSet(RefMap *map, unsigned key, TValue val) {\n    auto arr = *(String **)&bytecode[22];\n    mapSetByString(map, arr[key + 1], val);\n    decr(val);\n    map->unref();\n}\n\n//\n// Debugger\n//\n\n// This is only to be called once at the beginning of lambda function\n//%\nvoid *getGlobalsPtr() {\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    return globals;\n}\n\n//%\nvoid runtimeWarning(String s) {\n    // noop for now\n}\n} // namespace pxtrt\n#endif\n\nnamespace pxt {\n\n//%\nValType valType(TValue v) {\n    if (isTagged(v)) {\n        if (!v)\n            return ValType::Undefined;\n\n        if (isNumber(v) || v == TAG_NAN)\n            return ValType::Number;\n        if (v == TAG_TRUE || v == TAG_FALSE)\n            return ValType::Boolean;\n        else if (v == TAG_NULL)\n            return ValType::Object;\n        else {\n            oops(1);\n            return ValType::Object;\n        }\n    } else {\n        auto vt = getVTable((RefObject *)v);\n        if (vt->magic == VTABLE_MAGIC)\n            return vt->objectType;\n        else\n            return ValType::Object;\n    }\n}\n\nPXT_DEF_STRING(sObjectTp, \"object\")\nPXT_DEF_STRING(sBooleanTp, \"boolean\")\nPXT_DEF_STRING(sStringTp, \"string\")\nPXT_DEF_STRING(sNumberTp, \"number\")\nPXT_DEF_STRING(sFunctionTp, \"function\")\nPXT_DEF_STRING(sUndefinedTp, \"undefined\")\n\n//%\nString typeOf(TValue v) {\n    switch (valType(v)) {\n    case ValType::Undefined:\n        return (String)sUndefinedTp;\n    case ValType::Boolean:\n        return (String)sBooleanTp;\n    case ValType::Number:\n        return (String)sNumberTp;\n    case ValType::String:\n        return (String)sStringTp;\n    case ValType::Object:\n        return (String)sObjectTp;\n    case ValType::Function:\n        return (String)sFunctionTp;\n    default:\n        oops(2);\n        return 0;\n    }\n}\n\n// Maybe in future we will want separate print methods; for now ignore\nvoid anyPrint(TValue v) {\n    if (valType(v) == ValType::Object) {\n        if (isRefCounted(v)) {\n            auto o = (RefObject *)v;\n            auto vt = getVTable(o);\n            auto meth = ((RefObjectMethod)vt->methods[1]);\n            if ((void *)meth == (void *)&anyPrint)\n                DMESG(\"[RefObject refs=%d vt=%p cl=%d sz=%d]\", REFCNT(o), o->vtable, vt->classNo,\n                      vt->numbytes);\n            else\n                meth(o);\n        } else {\n            DMESG(\"[Native %p]\", v);\n        }\n    } else {\n#ifndef X86_64\n        String s = numops::toString(v);\n        DMESG(\"[%s %p = %s]\", pxt::typeOf(v)->data, v, s->data);\n        decr((TValue)s);\n#endif\n    }\n}\n\nstatic void dtorDoNothing() {}\n\n#ifdef PXT_GC\n#define PRIM_VTABLE(name, objectTp, tp, szexpr)                                                    \\\n    static uint32_t name##_size(tp *p) { return ((sizeof(tp) + szexpr) + 3) >> 2; }                \\\n    DEF_VTABLE(name##_vt, tp, objectTp, (void *)&dtorDoNothing, (void *)&anyPrint, 0,              \\\n               (void *)&name##_size)\n#else\n#define PRIM_VTABLE(name, objectTp, tp, szexpr)                                                    \\\n    DEF_VTABLE(name##_vt, tp, objectTp, (void *)&dtorDoNothing, (void *)&anyPrint)\n#endif\n\nPRIM_VTABLE(string, ValType::String, BoxedString, p->length + 1)\nPRIM_VTABLE(number, ValType::Number, BoxedNumber, 0)\nPRIM_VTABLE(buffer, ValType::Object, BoxedBuffer, p->length)\n// PRIM_VTABLE(action, ValType::Function, RefAction, )\n\nvoid failedCast(TValue v) {\n    DMESG(\"failed type check for %p\", v);\n    auto vt = getAnyVTable(v);\n    if (vt) {\n        DMESG(\"VT %p - objtype %d classNo %d\", vt, vt->objectType, vt->classNo);\n    }\n\n    int code;\n    if (v == TAG_NULL)\n        code = PANIC_CAST_FROM_NULL;\n    else\n        code = PANIC_CAST_FIRST + (int)valType(v);\n    target_panic(code);\n}\n\nvoid missingProperty(TValue v) {\n    DMESG(\"missing property on %p\", v);\n    target_panic(PANIC_MISSING_PROPERTY);\n}\n\n#ifdef PXT_PROFILE\nstruct PerfCounter *perfCounters;\n\nstruct PerfCounterInfo {\n    uint32_t numPerfCounters;\n    char *perfCounterNames[0];\n};\n\n#define PERF_INFO ((PerfCounterInfo *)(((uintptr_t *)bytecode)[13]))\n\nvoid initPerfCounters() {\n    auto n = PERF_INFO->numPerfCounters;\n    perfCounters = new PerfCounter[n];\n    memset(perfCounters, 0, n * sizeof(PerfCounter));\n}\n\nvoid dumpPerfCounters() {\n    auto info = PERF_INFO;\n    DMESG(\"calls,us,name\");\n    for (uint32_t i = 0; i < info->numPerfCounters; ++i) {\n        auto c = &perfCounters[i];\n        DMESG(\"%d,%d,%s\", c->numstops, c->value, info->perfCounterNames[i]);\n    }\n}\n\nvoid startPerfCounter(PerfCounters n) {\n    auto c = &perfCounters[(uint32_t)n];\n    if (c->start)\n        oops(50);\n    c->start = PERF_NOW();\n}\n\nvoid stopPerfCounter(PerfCounters n) {\n    auto c = &perfCounters[(uint32_t)n];\n    if (!c->start)\n        oops(51);\n    c->value += PERF_NOW() - c->start;\n    c->start = 0;\n    c->numstops++;\n}\n#endif\n\n} // namespace pxt\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum NumberFormat {\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    }\n\n\n    declare const enum PerfCounters {\n    GC = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "eventcontext.ts": "namespace control {\n    /**\n     * Run code when a registered event happens.\n     * @param id the event compoent id\n     * @param value the event value to match\n     */\n    //% weight=20 blockGap=8 blockId=\"control_on_event\" block=\"on event|from %src|with value %value\"\n    //% blockExternalInputs=1\n    //% help=\"control/on-event\"\n    export function onEvent(src: number, value: number, handler: () => void, flags = 16) { // EVENT_LISTENER_DEFAULT_FLAGS\n        const ctx = control.eventContext();\n        if (!ctx)\n            control.internalOnEvent(src, value, handler, flags);\n        else\n            ctx.registerHandler(src, value, handler, flags);\n    }\n\n    class FrameCallback {\n        order: number\n        handler: () => void\n    }\n\n    class EventHandler {\n        src: number;\n        value: number;\n        handler: () => void;\n        flags: number;\n\n        constructor(src: number, value: number, handler: () => void, flags: number) {\n            this.src = src;\n            this.value = value;\n            this.handler = handler;\n        }\n\n        register() {\n            control.internalOnEvent(this.src, this.value, () => {\n                if (this.handler) this.handler();\n            }, this.flags)\n        }\n\n        unregister() {\n            control.internalOnEvent(this.src, this.value, doNothing, this.flags);\n        }\n    }\n\n    function doNothing() { }\n\n    export class EventContext {\n        private handlers: EventHandler[];\n        private frameCallbacks: FrameCallback[];\n        private frameWorker: number;\n        private frameNo: number;\n        private framesInSample: number;\n        private timeInSample: number;\n        public deltaTime: number;\n        private prevTime: number;\n        static onStats: (stats: string) => void;\n\n        constructor() {\n            this.handlers = [];\n            this.frameNo = 0;\n            this.framesInSample = 0;\n            this.timeInSample = 0;\n            this.deltaTime = 0;\n            this.frameWorker = 0;\n        }\n\n        private runCallbacks() {\n            control.enablePerfCounter(\"all frame callbacks\")\n\n            this.frameNo++\n            let loopStart = control.millis()\n            this.deltaTime = (loopStart - this.prevTime) / 1000.0\n            this.prevTime = loopStart;\n            for (let f of this.frameCallbacks) {\n                f.handler()\n            }\n            let runtime = control.millis() - loopStart\n            this.timeInSample += runtime\n            this.framesInSample++\n            if (this.timeInSample > 1000 || this.framesInSample > 30) {\n                const fps = this.framesInSample / (this.timeInSample / 1000);\n                if (EventContext.onStats) {\n                    EventContext.onStats(`${Math.round(fps)}fps`)\n                }\n                if (control.profilingEnabled()) {\n                    control.dmesg(`${(fps * 100) | 0}/100 fps - ${this.framesInSample} frames`)\n                    control.gc()\n                    control.dmesgPerfCounters()\n                }\n                this.timeInSample = 0\n                this.framesInSample = 0\n            }\n            let delay = Math.max(1, 20 - runtime)\n            return delay\n        }\n\n        private registerFrameCallbacks() {\n            if (!this.frameCallbacks) return;\n\n            this.frameNo = 0;\n            this.framesInSample = 0;\n            this.timeInSample = 0;\n            this.deltaTime = 0;\n            this.prevTime = control.millis();\n            const worker = this.frameWorker;\n            control.runInParallel(() => {\n                while (worker == this.frameWorker) {\n                    let delay = this.runCallbacks()\n                    pause(delay)\n                }\n            })\n        }\n\n        register() {\n            for (const h of this.handlers)\n                h.register();\n            this.registerFrameCallbacks();\n        }\n\n        unregister() {\n            for (const h of this.handlers)\n                h.unregister();\n            this.frameWorker++;\n        }\n\n        registerFrameHandler(order: number, handler: () => void) {\n            if (!this.frameCallbacks) {\n                this.frameCallbacks = [];\n                this.registerFrameCallbacks();\n            }\n\n            const fn = new FrameCallback()\n            fn.order = order\n            fn.handler = handler\n            for (let i = 0; i < this.frameCallbacks.length; ++i) {\n                if (this.frameCallbacks[i].order > order) {\n                    this.frameCallbacks.insertAt(i, fn)\n                    return\n                }\n            }\n            this.frameCallbacks.push(fn)\n        }\n\n        registerHandler(src: number, value: number, handler: () => void, flags: number) {\n            // already there?\n            for (const h of this.handlers) {\n                if (h.src == src && h.value == value) {\n                    h.flags = flags;\n                    h.handler = handler;\n                    return;\n                }\n            }\n            // register and push\n            const hn = new EventHandler(src, value, handler, flags);\n            this.handlers.push(hn);\n            hn.register();\n        }\n    }\n\n    let eventContexts: EventContext[];\n\n    /**\n     * Gets the current event context if any\n     */\n    export function eventContext(): EventContext {\n        return eventContexts ? eventContexts[eventContexts.length - 1] : undefined;\n    }\n\n    /**\n     * Pushes a new event context and clears all handlers\n     */\n    export function pushEventContext(): EventContext {\n        if (!eventContexts)\n            eventContexts = [];\n\n        // unregister previous context\n        const ctx = eventContext();\n        if (ctx) ctx.unregister();\n        // register again\n        const n = new EventContext();\n        eventContexts.push(n);\n        return n;\n    }\n\n    /**\n     * Pops the current event context and restore handlers if any previous context\n     */\n    export function popEventContext() {\n        if (!eventContexts) return;\n\n        // clear current context\n        const ctx = eventContexts.pop();\n        if (!ctx) return;\n        ctx.unregister();\n\n        // register old context again\n        const context = eventContexts[eventContexts.length - 1];\n        if (context)\n            context.register();\n        else\n            eventContexts = undefined;\n    }\n}",
      "gc.cpp": "#include \"pxtbase.h\"\n\n#ifndef GC_BLOCK_SIZE\n#define GC_BLOCK_SIZE (1024 * 16)\n#endif\n\n#define GC_BLOCK_WORDS ((GC_BLOCK_SIZE - sizeof(GCBlock)) / sizeof(void *))\n\n#ifndef GC_ALLOC_BLOCK\n#define GC_ALLOC_BLOCK xmalloc\n#endif\n\n//#define PXT_GC_DEBUG 1\n\n#ifdef PXT_GC_DEBUG\n#define LOG DMESG\n#define VLOG DMESG\n#define VVLOG DMESG\n#else\n#define LOG NOLOG\n#define VLOG NOLOG\n#define VVLOG NOLOG\n#endif\n\n#ifdef PXT_GC_DEBUG\n#define GC_CHECK(cond, code)                                                                       \\\n    if (!(cond))                                                                                   \\\n    oops(code)\n#else\n#define GC_CHECK(cond, code) ((void)0)\n#endif\n\nnamespace pxt {\n\n//%\nvoid popThreadContext(ThreadContext *ctx);\n//%\nThreadContext *pushThreadContext(void *sp);\n\nunsigned RefRecord_gcsize(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    return tbl->numbytes >> 2;\n}\n\n#ifndef PXT_GC\n// dummies, to make the linker happy\nvoid popThreadContext(ThreadContext *ctx) {}\nThreadContext *pushThreadContext(void *sp) {\n    return NULL;\n}\nvoid RefRecord_scan(RefRecord *r) {}\n#else\n\nThreadContext *threadContexts;\n\nvoid popThreadContext(ThreadContext *ctx) {\n    VLOG(\"pop: %p %p n:%p p:%p\", ctx, threadContexts, ctx->next, ctx->prev);\n\n    if (!ctx)\n        return;\n\n    auto n = ctx->stack.next;\n    if (n) {\n        VLOG(\"seg %p\", n);\n        ctx->stack.top = n->top;\n        ctx->stack.bottom = n->bottom;\n        ctx->stack.next = n->next;\n        delete n;\n    } else {\n        if (ctx->next)\n            ctx->next->prev = ctx->prev;\n        if (ctx->prev)\n            ctx->prev->next = ctx->next;\n        else {\n            if (threadContexts != ctx)\n                oops(41);\n            threadContexts = ctx->next;\n            if (threadContexts)\n                threadContexts->prev = NULL;\n        }\n        delete ctx;\n        setThreadContext(NULL);\n    }\n}\n\nThreadContext *pushThreadContext(void *sp) {\n    auto curr = getThreadContext();\n    if (curr) {\n#ifdef PXT_GC_DEBUG\n        auto ok = false;\n        for (auto p = threadContexts; p; p = p->next)\n            if (p == curr) {\n                ok = true;\n                break;\n            }\n        if (!ok)\n            oops(49);\n#endif\n        auto seg = new StackSegment;\n        VLOG(\"stack %p / %p\", seg, curr);\n        seg->top = curr->stack.top;\n        seg->bottom = curr->stack.bottom;\n        seg->next = curr->stack.next;\n        curr->stack.next = seg;\n    } else {\n        curr = new ThreadContext;\n        LOG(\"push: %p\", curr);\n        curr->globals = globals;\n        curr->stack.next = NULL;\n        curr->next = threadContexts;\n        curr->prev = NULL;\n        if (curr->next)\n            curr->next->prev = curr;\n        threadContexts = curr;\n        curr->fiber = getCurrentFiber();\n        setThreadContext(curr);\n    }\n    curr->stack.bottom = sp;\n    curr->stack.top = NULL;\n    return curr;\n}\n\nclass RefBlock : public RefObject {\n  public:\n    RefBlock *nextFree;\n};\n\nstruct GCBlock {\n    GCBlock *next;\n    RefObject data[0];\n};\n\nstatic Segment gcRoots;\nstatic Segment workQueue;\nstatic GCBlock *firstBlock;\nstatic RefBlock *firstFree;\n\n#define IS_OUTSIDE_GC(v)                                                                           \\\n    (isReadOnly(v) || (*(uint32_t *)v & 1) || (*(VTable **)v)->magic != VTABLE_MAGIC)\n\nvoid gcScan(TValue v) {\n    if (IS_OUTSIDE_GC(v))\n        return;\n    *(uint32_t *)v |= 1;\n    workQueue.push(v);\n}\n\nvoid gcScanMany(TValue *data, unsigned len) {\n    // VLOG(\"scan: %p %d\", data, len);\n    for (unsigned i = 0; i < len; ++i) {\n        auto v = data[i];\n        // VLOG(\"psh: %p %d %d\", v, isReadOnly(v), (*(uint32_t *)v & 1));\n        if (IS_OUTSIDE_GC(v))\n            continue;\n        *(uint32_t *)v |= 1;\n        workQueue.push(v);\n    }\n}\n\nvoid gcScanSegment(Segment &seg) {\n    gcScanMany(seg.getData(), seg.getLength());\n}\n\n#define getScanMethod(vt) ((RefObjectMethod)(((VTable *)(vt))->methods[2]))\n#define getSizeMethod(vt) ((RefObjectSizeMethod)(((VTable *)(vt))->methods[3]))\n\nstatic void process(TValue v) {\n    if (IS_OUTSIDE_GC(v))\n        return;\n    auto p = (RefObject *)v;\n    auto vt = p->vtable;\n    if (vt & 1)\n        return;\n    VVLOG(\"process: %p\", p);\n    auto scan = getScanMethod(vt);\n    p->vtable |= 1;\n    if (scan)\n        scan(p);\n    while (workQueue.getLength()) {\n        auto curr = (RefObject *)workQueue.pop();\n        VVLOG(\" - %p\", curr);\n        scan = getScanMethod(curr->vtable & ~1);\n        if (scan)\n            scan(curr);\n    }\n}\n\nstatic void mark() {\n    auto data = gcRoots.getData();\n    auto len = gcRoots.getLength();\n    for (unsigned i = 0; i < len; ++i) {\n        auto d = data[i];\n        if ((uint32_t)d & 1) {\n            d = *(TValue *)((uint32_t)d & ~1);\n        }\n        process(d);\n    }\n\n    for (auto ctx = threadContexts; ctx; ctx = ctx->next) {\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(ctx, seg->top);\n            auto end = (TValue *)threadAddressFor(ctx, seg->bottom);\n            VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                process(*ptr++);\n            }\n        }\n    }\n\n    auto nonPtrs = bytecode[21];\n    len = getNumGlobals() - nonPtrs;\n    data = globals + nonPtrs;\n    VLOG(\"globals: %p %d\", data, len);\n    for (unsigned i = 0; i < len; ++i) {\n        process(*data++);\n    }\n}\n\nstatic uint32_t getObjectSize(RefObject *o) {\n    auto vt = o->vtable;\n    uint32_t r;\n    GC_CHECK(vt != 0 && !(vt & 1), 49);\n    if (vt & 2) {\n        r = vt >> 2;\n    } else {\n        auto sz = getSizeMethod(vt);\n        // GC_CHECK(0x2000 <= (intptr_t)sz && (intptr_t)sz <= 0x100000, 47);\n        r = sz(o);\n    }\n    GC_CHECK(1 <= r && r < 0x100000, 48);\n    return r;\n}\n\n__attribute__((noinline)) static void allocateBlock() {\n    auto curr = (GCBlock *)GC_ALLOC_BLOCK(GC_BLOCK_SIZE);\n    LOG(\"GC alloc: %p\", curr);\n    curr->data[0].vtable = (GC_BLOCK_WORDS << 2) | 2;\n    ((RefBlock *)curr->data)[0].nextFree = firstFree;\n    firstFree = (RefBlock *)curr->data;\n    curr->next = firstBlock;\n    firstBlock = curr;\n}\n\nstatic void sweep(int verbose) {\n    RefBlock *freePtr = NULL;\n    uint32_t freeSize = 0;\n    uint32_t totalSize = 0;\n    for (auto h = firstBlock; h; h = h->next) {\n        auto d = h->data;\n        auto end = d + GC_BLOCK_WORDS;\n        totalSize += GC_BLOCK_WORDS;\n        VLOG(\"sweep: %p - %p\", d, end);\n        while (d < end) {\n            if (d->vtable & 1) {\n                VVLOG(\"Live %p\", d);\n                d->vtable &= ~1;\n                d += getObjectSize(d);\n            } else {\n                auto start = (RefBlock *)d;\n                while (d < end && !(d->vtable & 1)) {\n                    if (d->vtable & 2) {\n                        VVLOG(\"Free %p\", d);\n                    } else {\n                        VVLOG(\"Dead %p\", d);\n                        d->destroyVT();\n                    }\n                    d += getObjectSize(d);\n                }\n                auto sz = d - (RefObject *)start;\n                freeSize += sz;\n#ifdef PXT_GC_DEBUG\n                memset(start, 0xff, sz << 2);\n#endif\n                start->vtable = (sz << 2) | 2;\n                if (sz > 1) {\n                    start->nextFree = freePtr;\n                    freePtr = start;\n                }\n            }\n        }\n    }\n    if (verbose)\n        DMESG(\"GC %d/%d free\", freeSize, totalSize);\n    else\n        LOG(\"GC %d/%d free\", freeSize, totalSize);\n    firstFree = freePtr;\n    // if the heap is 90% full, allocate a new block\n    if (freeSize * 10 <= totalSize) {\n        allocateBlock();\n    }\n}\n\nvoid gc(int verbose) {\n    startPerfCounter(PerfCounters::GC);\n    VLOG(\"GC mark\");\n    mark();\n    VLOG(\"GC sweep\");\n    sweep(verbose);\n    VLOG(\"GC done\");\n    stopPerfCounter(PerfCounters::GC);\n}\n\nvoid *gcAllocate(int numbytes) {\n    size_t numwords = (numbytes + 3) >> 2;\n\n    if (numwords > GC_BLOCK_WORDS)\n        oops(45);\n\n#ifdef PXT_GC_DEBUG\n    auto curr = getThreadContext();\n    if (!curr || !curr->stack.top)\n        oops(46);\n#endif\n\n    // gc();\n\n    for (int i = 0;; ++i) {\n        RefBlock *prev = NULL;\n        for (auto p = firstFree; p; p = p->nextFree) {\n            VVLOG(\"p=%p\", p);\n            GC_CHECK(!isReadOnly((TValue)p), 49);\n            auto vt = p->vtable;\n            if (!(vt & 2))\n                oops(43);\n            int left = (vt >> 2) - numwords;\n            if (left >= 0) {\n                auto nf = (RefBlock *)((void **)p + numwords);\n                //VLOG(\"nf=%p\", nf);\n                auto nextFree = p->nextFree; // p and nf can overlap when allocating 4 bytes\n                if (left)\n                    nf->vtable = (left << 2) | 2;\n                if (left >= 2) {\n                    nf->nextFree = nextFree;\n                } else {\n                    nf = p->nextFree;\n                }\n                if (prev)\n                    prev->nextFree = nf;\n                else\n                    firstFree = nf;\n                p->vtable = 0;\n                GC_CHECK(!nf->nextFree || ((uint32_t)nf->nextFree) >> 20, 48);\n                VVLOG(\"GC=>%p %d %p\", p, numwords, nf->nextFree);\n                return p;\n            }\n            prev = p;\n        }\n\n        // we didn't find anything, try GC\n        if (i == 0)\n            gc(0);\n        // GC didn't help, try new block\n        else if (i == 1)\n            allocateBlock();\n        else\n            oops(44);\n    }\n}\n\nstatic void removePtr(TValue v) {\n    auto len = gcRoots.getLength();\n    auto data = gcRoots.getData();\n    for (unsigned i = 0; i < len; ++i) {\n        if (data[i] == v) {\n            if (i == len - 1) {\n                gcRoots.pop();\n            } else {\n                data[i] = gcRoots.pop();\n            }\n            return;\n        }\n    }\n    oops(40);\n}\n\nvoid registerGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            registerGC(root++, 1);\n        }\n        return;\n    }\n\n    gcRoots.push((TValue)((uint32_t)root | 1));\n}\n\nvoid unregisterGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            unregisterGC(root++, 1);\n        }\n        return;\n    }\n\n    removePtr((TValue)((uint32_t)root | 1));\n}\n\nvoid registerGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    gcRoots.push(ptr);\n}\n\nvoid unregisterGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    removePtr(ptr);\n}\n\nvoid RefImage::scan(RefImage *t) {\n    gcScan((TValue)t->buffer());\n}\n\nvoid RefCollection::scan(RefCollection *t) {\n    gcScanSegment(t->head);\n}\n\nvoid RefAction::scan(RefAction *t) {\n    gcScanMany(t->fields, t->len);\n}\n\nvoid RefRefLocal::scan(RefRefLocal *t) {\n    gcScan(t->v);\n}\n\nvoid RefMap::scan(RefMap *t) {\n    gcScanSegment(t->keys);\n    gcScanSegment(t->values);\n}\n\nvoid RefRecord_scan(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    gcScanMany(r->fields, (tbl->numbytes - sizeof(RefRecord)) >> 2);\n}\n\n#define SIZE(off) (sizeof(*t) + (off) + 3) >> 2\n\nunsigned RefImage::gcsize(RefImage *t) {\n    if (t->hasBuffer())\n        return SIZE(0);\n    return SIZE(t->length());\n}\n\nunsigned RefCollection::gcsize(RefCollection *t) {\n    return SIZE(0);\n}\n\nunsigned RefAction::gcsize(RefAction *t) {\n    return SIZE(t->len << 2);\n}\n\nunsigned RefRefLocal::gcsize(RefRefLocal *t) {\n    return SIZE(0);\n}\n\nunsigned RefMap::gcsize(RefMap *t) {\n    return SIZE(0);\n}\n\n#endif\n\n} // namespace pxt\n",
      "json.ts": "namespace JSON {\n    export function parseIntRadix(s: string, base?: number) {\n        if (base == null || base == 10) {\n            return parseFloat(s) | 0\n        }\n\n        let m = false\n        let r = 0\n        for (let i = 0; i < s.length; ++i) {\n            let c = s.charCodeAt(i)\n            if (c == 0x20 || c == 10 || c == 13 || c == 9)\n                continue\n            if (r == 0 && !m && c == 0x2d) {\n                m = true\n                continue\n            }\n\n            let v = -1\n            if (0x30 <= c && c <= 0x39)\n                v = c - 0x30\n            else {\n                c |= 0x20\n                if (0x61 <= c && c <= 0x7a)\n                    v = c - 0x61 + 10\n            }\n\n            if (0 <= v && v < base) {\n                r *= base\n                r += v\n            } else {\n                return undefined\n            }\n        }\n\n        return m ? -r : r\n    }\n\n\n    class Parser {\n        ptr: number\n        s: string\n        errorMsg: string\n\n        error(msg: string) {\n            if (!this.errorMsg) {\n                this.errorMsg = msg + \" at position \" + this.ptr\n                this.ptr = this.s.length\n            }\n        }\n\n        skipWS() {\n            for (; ;) {\n                const c = this.nextChar()\n                if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {\n                    // OK\n                } else {\n                    this.ptr--\n                    return c\n                }\n            }\n        }\n\n        nextChar() {\n            if (this.ptr < this.s.length)\n                return this.s.charCodeAt(this.ptr++)\n            return 0\n        }\n\n        doString() {\n            let r = \"\"\n            this.ptr++\n            for (; ;) {\n                const c = this.s.charAt(this.ptr++)\n                if (c == \"\\\"\")\n                    return r\n                if (c == \"\\\\\") {\n                    let q = this.s.charAt(this.ptr++)\n                    if (q == \"b\") q = \"\\b\"\n                    else if (q == \"n\") q = \"\\n\"\n                    else if (q == \"r\") q = \"\\r\"\n                    else if (q == \"t\") q = \"\\t\"\n                    else if (q == \"u\") {\n                        q = String.fromCharCode(parseIntRadix(this.s.slice(this.ptr, this.ptr + 4), 16))\n                        this.ptr += 4\n                    }\n                    r += q\n                } else {\n                    r += c\n                }\n            }\n        }\n\n        doArray(): any[] {\n            const r = []\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x5d) {\n                    this.ptr++\n                    return r\n                }\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r.push(v)\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x5d)\n                    continue\n                this.error(\"expecting comma\")\n            }\n        }\n\n        doObject() {\n            const r: any = {}\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x7d) {\n                    this.ptr++\n                    return r\n                }\n                if (c != 0x22) {\n                    this.error(\"expecting key\")\n                    return r\n                }\n                const k = this.doString()\n                c = this.skipWS()\n                if (c != 0x3a) {\n                    this.error(\"expecting colon\")\n                    return r\n                }\n                this.ptr++\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r[k] = v\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x7d)\n                    continue\n                this.error(\"expecting comma, got \" + String.fromCharCode(c))\n            }\n        }\n\n        doNumber() {\n            const beg = this.ptr\n            for (; ;) {\n                const c = this.nextChar()\n                if ((0x30 <= c && c <= 0x39) || c == 0x2b || c == 0x2d || c == 0x2e || c == 0x45 || c == 0x65) {\n                    // one more\n                } else {\n                    this.ptr--\n                    break\n                }\n            }\n            const ss = this.s.slice(beg, this.ptr)\n            if (ss.length == 0) {\n                this.error(\"expecting number\")\n                return 0\n            }\n            return parseFloat(ss)\n        }\n\n        checkKw(k: string) {\n            if (this.s.slice(this.ptr, this.ptr + k.length) == k) {\n                this.ptr += k.length\n                return true\n            }\n            return false\n        }\n\n        value() {\n            if (this.errorMsg)\n                return null\n\n            const c = this.skipWS()\n            if (c == 0x7b)\n                return this.doObject()\n            else if (c == 0x5b)\n                return this.doArray()\n            else if ((0x30 <= c && c <= 0x39) || c == 0x2d)\n                return this.doNumber()\n            else if (c == 0x22)\n                return this.doString()\n            else if (c == 0x74 && this.checkKw(\"true\"))\n                return true\n            else if (c == 0x66 && this.checkKw(\"false\"))\n                return false\n            else if (c == 0x6e && this.checkKw(\"null\"))\n                return null\n\n            this.error(\"unexpected token\")\n            return null\n        }\n    }\n\n    class Stringifier {\n        currIndent: string\n        indentStep: string\n        indent: number\n\n        doString(s: string) {\n            let r = \"\\\"\"\n            for (let i = 0; i < s.length; ++i) {\n                let c = s[i]\n                if (c == \"\\n\") c = \"\\\\n\"\n                else if (c == \"\\r\") c = \"\\\\r\"\n                else if (c == \"\\t\") c = \"\\\\t\"\n                else if (c == \"\\b\") c = \"\\\\b\"\n                else if (c == \"\\\\\") c = \"\\\\\\\\\"\n                else if (c == \"\\\"\") c = \"\\\\\\\"\"\n                r += c\n            }\n            return r + \"\\\"\"\n        }\n\n        go(v: any) {\n            const t = typeof v\n            if (t == \"string\")\n                return this.doString(v)\n            else if (t == \"boolean\" || t == \"number\" || v == null)\n                return \"\" + v\n            else if (Array.isArray(v)) {\n                const arr = v as any[]\n                if (arr.length == 0)\n                    return \"[]\"\n                else {\n                    let r = \"[\"\n                    if (this.indent) {\n                        this.currIndent += this.indentStep\n                        r += \"\\n\"\n                    }\n                    for (let i = 0; i < arr.length; ++i) {\n                        r += this.currIndent + this.go(arr[i])\n                        if (i != arr.length - 1)\n                            r += \",\"\n                        if (this.indent)\n                            r += \"\\n\"\n                    }\n                    if (this.indent)\n                        this.currIndent = this.currIndent.slice(this.indent)\n                    r += this.currIndent + \"]\"\n                    return r\n                }\n            } else {\n                const keys = Object.keys(v)\n                if (keys.length == 0)\n                    return \"{}\"\n\n                let r = \"{\"\n                if (this.indent) {\n                    this.currIndent += this.indentStep\n                    r += \"\\n\"\n                }\n                for (let i = 0; i < keys.length; ++i) {\n                    const k = keys[i]\n                    r += this.currIndent + this.doString(k)\n                    if (this.indent)\n                        r += \": \"\n                    else\n                        r += \":\"\n                    r += this.go(v[k])\n                    if (i != keys.length - 1)\n                        r += \",\"\n                    if (this.indent)\n                        r += \"\\n\"\n                }\n                if (this.indent)\n                    this.currIndent = this.currIndent.slice(this.indent)\n                r += this.currIndent + \"}\"\n                return r\n            }\n        }\n    }\n\n    /**\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n     * @param value A JavaScript value, usually an object or array, to be converted.\n     * @param replacer Not supported; use null.\n     * @param indent Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    export function stringify(value: any, replacer: any = null, indent: number = 0) {\n        const ss = new Stringifier()\n        ss.currIndent = \"\"\n        indent |= 0\n        if (indent < 0) indent = 0\n        if (indent > 10) indent = 10\n        ss.indentStep = \"\"\n        ss.currIndent = \"\"\n        ss.indent = indent\n        while (indent-- > 0)\n            ss.indentStep += \" \"\n        return ss.go(value)\n    }\n\n\n    /**\n     * Converts a JavaScript Object Notation (JSON) string into an object.\n     * @param text A valid JSON string.\n     */\n    export function parse(s: string) {\n        const p = new Parser()\n        p.ptr = 0\n        p.s = s\n        const r = p.value()\n        if (p.skipWS()) {\n            p.error(\"excessive input\")\n        }\n        if (p.errorMsg) {\n            control.dmesg(\"Invalid JSON: \" + p.errorMsg)\n            return undefined\n        }\n        return r\n    }\n}\n",
      "loops.cpp": "#include \"pxtbase.h\"\n\nnamespace loops {\n\n/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true deprecated=true\n//% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1\nvoid forever(Action a) {\n    runForever(a);\n}\n\n/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99 deprecated=true\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause_deprecated\nvoid pause(int ms) {\n    if (ms < 0) return;\n    sleep_ms(ms);\n}\n\n}",
      "math.ts": "namespace Math {\n\n    export const E = 2.718281828459045;\n    export const LN2 = 0.6931471805599453;\n    export const LN10 = 2.302585092994046;\n    export const LOG2E = 1.4426950408889634;\n    export const LOG10E = 0.4342944819032518;\n    export const PI = 3.141592653589793;\n    export const SQRT1_2 = 0.7071067811865476;\n    export const SQRT2 = 1.4142135623730951;\n\n    /**\n     * Re-maps a number from one range to another. That is, a value of ``from low`` would get mapped to ``to low``, a value of ``from high`` to ``to high``, values in-between to values in-between, etc.\n     * @param value value to map in ranges\n     * @param fromLow the lower bound of the value's current range\n     * @param fromHigh the upper bound of the value's current range, eg: 1023\n     * @param toLow the lower bound of the value's target range\n     * @param toHigh the upper bound of the value's target range, eg: 4\n     */\n    //% help=math/map weight=10 blockGap=8\n    //% blockId=math_map block=\"map %value|from low %fromLow|high %fromHigh|to low %toLow|high %toHigh\"\n    //% inlineInputMode=inline\n    export function map(value: number, fromLow: number, fromHigh: number, toLow: number, toHigh: number): number {\n        return ((value - fromLow) * (toHigh - toLow)) / (fromHigh - fromLow) + toLow;\n    }    \n\n    /**\n     * Constrains a number to be within a range\n     * @param x the number to constrain, all data types\n     * @param y the lower end of the range, all data types\n     * @param z the upper end of the range, all data types\n     */\n    //% help=math/constrain weight=11 blockGap=8\n    //% blockId=\"math_constrain_value\" block=\"constrain %value|between %low|and %high\"\n    export function constrain(value: number, low: number, high: number): number {\n        return value < low ? low : value > high ? high : value;\n    }\n\n    const b_m16: number[] = [0, 49, 49, 41, 90, 27, 117, 10]\n    /**\n     * Returns the sine of an input angle. This is an 8-bit approximation.\n     * @param theta input angle from 0-255\n     */\n    //% help=math/isin weight=11 advanced=true blockGap=8\n    export function isin(theta: number) {\n        //reference: based on FASTLed's sin approximation method: [https://github.com/FastLED/FastLED](MIT)\n        let offset = theta;\n        if( theta & 0x40 ) {\n            offset = 255 - offset;\n        }\n        offset &= 0x3F; // 0..63\n\n        let secoffset  = offset & 0x0F; // 0..15\n        if( theta & 0x40) secoffset++;\n\n        let section = offset >> 4; // 0..3\n        let s2 = section * 2;\n\n        let b = b_m16[s2];\n        let m16 = b_m16[s2+1];\n        let mx = (m16 * secoffset) >> 4;\n        \n        let y = mx + b;\n        if( theta & 0x80 ) y = -y;\n\n        y += 128;\n\n        return y;\n    }\n\n    /**\n     * Returns the cosine of an input angle. This is an 8-bit approximation. \n     * @param theta input angle from 0-255\n     */\n    //% help=math/icos weight=10 advanced=true blockGap=8\n    export function icos(theta: number) {\n        return isin(theta + 16384);\n    }\n}\n\nnamespace Number {\n    export const EPSILON = 2.220446049250313e-16;\n}",
      "ns.ts": "\n/**\n * Respond to and read data from buttons and sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}\n",
      "pxt-core.d.ts": "/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n      * Get or set the length of an array. This number is one more than the index of the last element the array.\n      */\n    //% shim=Array_::length weight=84\n    //% blockId=\"lists_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"arrays\"\n    length: number;\n\n    /**\n      * Append a new element to an array.\n      * @param items New elements of the Array.\n      */\n    //% help=arrays/push\n    //% shim=Array_::push weight=50\n    //% blockId=\"array_push\" block=\"%list| add value %value| to end\" blockNamespace=\"arrays\"\n    push(item: T): void;\n\n    /**\n      * Remove the last element from an array and return it.\n      */\n    //% help=arrays/pop\n    //% shim=Array_::pop weight=45\n    //% blockId=\"array_pop\" block=\"get and remove last value from %list\" blockNamespace=\"arrays\"\n    //% blockGap=64\n    pop(): T;\n\n    /**\n      * Reverse the elements in an array. The first array element becomes the last, and the last array element becomes the first.\n      */\n    //% help=arrays/reverse\n    //% helper=arrayReverse weight=10\n    //% blockId=\"array_reverse\" block=\"reverse %list\" blockNamespace=\"arrays\"\n    reverse(): void;\n\n    /**\n      * Remove the first element from an array and return it. This method changes the length of the array.\n      */\n    //% help=arrays/shift\n    //% helper=arrayShift weight=30\n    //% blockId=\"array_shift\" block=\"get and remove first value from %list\" blockNamespace=\"arrays\"\n    shift(): T;\n\n    /**\n      * Add one element to the beginning of an array and return the new length of the array.\n      * @param element to insert at the start of the Array.\n      */\n    //% help=arrays/unshift\n    //% helper=arrayUnshift weight=25\n    //% blockId=\"array_unshift\" block=\"%list| insert %value| at beginning\" blockNamespace=\"arrays\"\n    //unshift(...values:T[]): number; //rest is not supported in our compiler yet.\n    unshift(value: T): number;\n\n    /**\n      * Return a section of an array.\n      * @param start The beginning of the specified portion of the array. eg: 0\n      * @param end The end of the specified portion of the array. eg: 0\n      */\n    //% help=arrays/slice\n    //% helper=arraySlice weight=41 blockNamespace=\"arrays\"\n    slice(start: number, end: number): T[];\n\n    /**\n      * Remove elements from an array.\n      * @param start The zero-based location in the array from which to start removing elements. eg: 0\n      * @param deleteCount The number of elements to remove. eg: 0\n      */\n    //% helper=arraySplice weight=40\n    splice(start: number, deleteCount: number): void;\n\n    /**\n      * joins all elements of an array into a string and returns this string.\n      * @param sep the string separator\n      */\n    //% helper=arrayJoin weight=40\n    join(sep: string): string;\n    \n    /**\n      * Tests whether at least one element in the array passes the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arraySome weight=40\n    some(callbackfn: (value: T, index: number) => boolean): boolean;\n\n    /**\n      * Tests whether all elements in the array pass the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayEvery weight=40\n    every(callbackfn: (value: T, index: number) => boolean): boolean;\n    \n    /**\n      * Sort the elements of an array in place and returns the array. The sort is not necessarily stable.\n      * @param specifies a function that defines the sort order. If omitted, the array is sorted according to the prmitive type\n      */\n    //% helper=arraySort weight=40\n    sort(callbackfn?: (value1: T, value2: T) => number): T[];\n\n    /**\n      * Call a defined callback function on each element of an array, and return an array containing the results.\n      * @param callbackfn A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayMap weight=40\n    map<U>(callbackfn: (value: T, index: number) => U): U[];\n\n    /**\n      * Call a defined callback function on each element of an array.\n      * @param callbackfn A function that accepts up to two arguments. The forEach method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayForEach weight=40\n    forEach(callbackfn: (value: T, index: number) => void): void;\n    \n    /**\n      * Return the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayFilter weight=40\n    filter(callbackfn: (value: T, index: number) => boolean): T[];\n\n    /**\n      * Call the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    //% helper=arrayReduce weight=40\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U;\n\n\n    /** Remove the first occurence of an object. Returns true if removed. */\n    //% shim=Array_::removeElement weight=48\n    removeElement(element: T): boolean;\n\n    /** Remove the element at a certain index. */\n    //% help=arrays/remove-at\n    //% shim=Array_::removeAt weight=15\n    //% blockId=\"array_removeat\" block=\"%list| remove value at %index\" blockNamespace=\"arrays\"\n    removeAt(index: number): T;\n\n    /**\n     * Insert the value at a particular index, increases length by 1\n     * @param index the zero-based position in the list to insert the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/insert-at\n    //% shim=Array_::insertAt weight=20\n    //% blockId=\"array_insertAt\" block=\"%list| insert at %index| value %value\" blockNamespace=\"arrays\"\n    insertAt(index: number, value: T): void;\n\n    /**\n      * Return the index of the first occurrence of a value in an array.\n      * @param item The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    //% help=arrays/index-of\n    //% shim=Array_::indexOf weight=40\n    //% blockId=\"array_indexof\" block=\"%list| find index of %value\" blockNamespace=\"arrays\"\n    indexOf(item: T, fromIndex?: number): number;\n\n    /**\n     * Get the value at a particular index\n     * @param index the zero-based position in the list of the item, eg: 0\n     */\n    //% help=arrays/get\n    //% shim=Array_::getAt weight=85\n    get(index: number): T;\n\n    /**\n     * Store a value at a particular index\n     * @param index the zero-based position in the list to store the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/set\n    //% shim=Array_::setAt weight=84\n    set(index: number, value: T): void;\n\n    [n: number]: T;\n}\n\ndeclare interface String {\n    // This block is currently disabled in favor of the built-in Blockly \"Create text with\" block, which compiles to \"\" + \"\"\n    // Add % sign back to the block annotation to re-enable\n    /**\n     * Returns a string that contains the concatenation of two or more strings.\n     * @param other The string to append to the end of the string.\n     */\n    //% shim=String_::concat weight=49\n    //% blockId=\"string_concat\" blockNamespace=\"text\"\n    // block=\"join %list=text|%other\"\n    concat(other: string): string;\n\n    /**\n     * Return the character at the specified index.\n     * @param index The zero-based index of the desired character.\n     */\n    //% shim=String_::charAt weight=48\n    //% help=text/char-at\n    //% blockId=\"string_get\" block=\"char from %this=text|at %pos\" blockNamespace=\"text\"\n    charAt(index: number): string;\n\n    /** Returns the length of a String object. */\n    //% property shim=String_::length weight=47\n    //% blockId=\"text_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"text\"\n    length: number;\n\n    /**\n     * Return the Unicode value of the character at the specified location.\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n     */\n    //% shim=String_::charCodeAt\n    charCodeAt(index: number): number;\n\n    /**\n     * See how the order of characters in two strings is different (in ASCII encoding).\n     * @param that String to compare to target string\n     */\n    //% shim=String_::compare\n    //% help=text/compare\n    //% blockId=\"string_compare\" block=\"compare %this=text| to %that\" blockNamespace=\"text\"\n    compare(that: string): number;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param length number of characters to extract\n     */\n    //% shim=String_::substr length.defl=10\n    //% help=text/substr\n    //% blockId=\"string_substr\" block=\"substring of %this=text|from %start|of length %length\" blockNamespace=\"text\"\n    substr(start: number, length?: number): string;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param end one-past-last character index\n     */\n    //% helper=stringSlice\n    slice(start: number, end?: number): string;\n\n    // This block is currently disabled, as it does not compile in some targets\n    // Add % sign back to the block annotation to re-enable\n    /** Returns a value indicating if the string is empty */\n    //% shim=String_::isEmpty\n    //% blockId=\"string_isempty\" blockNamespace=\"text\"\n    // block=\"%this=text| is empty\"\n    isEmpty(): boolean;\n\n    /**\n     * Returns the position of the first occurrence of a specified value in a string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::indexOf\n    //% help=text/index-of\n    //% blockId=\"string_indexof\" blockNamespace=\"text\"\n    indexOf(searchValue: string, start?: number): number;\n\n    /**\n     * Determines whether a string contains the characters of a specified string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::includes\n    //% help=text/includes\n    //% blockId=\"string_includes\" blockNamespace=\"text\"\n    includes(searchValue: string, start?: number): boolean;\n\n    [index: number]: string;\n}\n\n/**\n  * Convert a string to a number.\n  * @param s A string to convert into a number. eg: 123\n  */\n//% shim=String_::toNumber\n//% help=text/parse-float\n//% blockId=\"string_parsefloat\" block=\"parse to number %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\ndeclare function parseFloat(text: string): number;\n\ninterface Object { }\ninterface Function { }\ninterface IArguments { }\ninterface RegExp { }\ntype TemplateStringsArray = Array<string>;\n\ntype uint8 = number;\ntype uint16 = number;\ntype uint32 = number;\ntype int8 = number;\ntype int16 = number;\ntype int32 = number;\n\n\ndeclare interface Boolean {\n    /**\n     * Returns a string representation of an object.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Combine, split, and search text strings.\n*/\n//% blockNamespace=\"Text\"\ndeclare namespace String {\n\n    /**\n     * Make a string from the given ASCII character code.\n     */\n    //% help=math/from-char-code\n    //% shim=String_::fromCharCode\n    //% weight=0\n    //% blockNamespace=\"Text\" blockId=\"stringFromCharCode\" block=\"text from char code %code\" weight=1\n    function fromCharCode(code: number): string;\n}\n\ndeclare interface Number {\n    /**\n     * Returns a string representation of a number.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Add, remove, and replace items in lists.\n*/\n//% blockNamespace=\"Arrays\"\ndeclare namespace Array {\n    /**\n     * Check if a given object is an array.\n     */\n    //% shim=Array_::isArray\n    function isArray(obj: any): boolean;\n}\n\ndeclare namespace Object {\n    /**\n     * Return the field names in an object.\n     */\n    //% shim=pxtrt::keysOf\n    function keys(obj: any): string[];\n}\n\n/**\n * More complex operations with numbers.\n*/\ndeclare namespace Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    //% shim=Math_::pow\n    function pow(x: number, y: number): number;\n\n    /**\n     * Returns a pseudorandom number between 0 and 1.\n     */\n    //% shim=Math_::random\n    //% help=math/random\n    function random(): number;\n\n    /**\n     * Returns a pseudorandom number between min and max included.\n     * If both numbers are integral, the result is integral.\n     * @param min the lower inclusive bound, eg: 0\n     * @param max the upper inclusive bound, eg: 10\n     */\n    //% blockId=\"device_random\" block=\"pick random %min|to %limit\"\n    //% help=math/random-range\n    //% shim=Math_::randomRange\n    function randomRange(min: number, max: number): number;\n\n    /**\n     * Returns the natural logarithm (base e) of a number.\n     * @param x A number\n     */\n    //% shim=Math_::log\n    function log(x: number): number;\n\n    /**\n     * Returns returns ``e^x``.\n     * @param x A number\n     */\n    //% shim=Math_::exp\n    function exp(x: number): number;\n\n    /**\n     * Returns the sine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::sin\n    function sin(x: number): number;\n\n    /**\n     * Returns the cosine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::cos\n    function cos(x: number): number;\n\n    /**\n     * Returns the tangent of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::tan\n    function tan(x: number): number;\n\n    /**\n     * Returns the arcsine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::asin\n    function asin(x: number): number;\n\n    /**\n     * Returns the arccosine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::acos\n    function acos(x: number): number;\n\n    /**\n     * Returns the arctangent (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::atan\n    function atan(x: number): number;\n\n    /**\n     * Returns the arctangent of the quotient of its arguments.\n     * @param y A number\n     * @param x A number\n     */\n    //% shim=Math_::atan2\n    function atan2(y: number, x: number): number;\n\n    /**\n     * Returns the square root of a number.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::sqrt\n    function sqrt(x: number): number;\n\n    /**\n     * Returns the smallest number greater than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::ceil\n    function ceil(x: number): number;\n\n    /**\n      * Returns the greatest number less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::floor\n    function floor(x: number): number;\n\n    /**\n      * Returns the number with the decimal part truncated.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::trunc\n    function trunc(x: number): number;\n\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    //% shim=Math_::round\n    function round(x: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit multiplication of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::imul\n    function imul(x: number, y: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit division of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::idiv\n    function idiv(x: number, y: number): number;\n}\n",
      "pxt-helpers.ts": "type Action = () => void;\n\n\n/**\n  * Convert a string to an integer.\n  * @param s A string to convert into an integral number. eg: 123\n  */\n//% help=text/parse-int\n//% blockId=\"string_parseint\" block=\"parse to integer %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\n//% blockHidden=1\nfunction parseInt(text: string): number {\n    return parseFloat(text) >> 0;\n}\n\nnamespace helpers {\n    export function arraySplice<T>(arr: T[], start: number, len: number) {\n        if (start < 0) {\n            return;\n        }\n        for (let i = 0; i < len; ++i) {\n            arr.removeAt(start)\n        }\n    }\n\n    export function arrayReverse<T>(arr: T[]): void {\n        let len = arr.length;\n        for (let i = 0; i < len / 2; i++) {\n            swap(arr, i, len - i - 1);\n        }\n    }\n\n    export function arrayShift<T>(arr: T[]): T {\n        return arr.removeAt(0);\n    }\n\n    export function arrayJoin<T>(arr: T[], sep: string): string {\n        let r = \"\";\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            if (i > 0 && sep)\n                r += sep;\n            r += arr[i] || \"\";\n        }\n        return r;\n    }\n\n    /*TODO: Enable this multiple value unshift, after rest is enabled in our compiler.\n        export function arrayUnshift<T>(arr: T[], ...values: T[]) : number {\n            for(let i = values.length; i > 0; --i) {\n                arr.insertAt(0, values[i - 1]);\n            }\n            return arr.length;\n        }\n    */\n    export function arrayUnshift<T>(arr: T[], value: T): number {\n        arr.insertAt(0, value);\n        return arr.length;\n    }\n\n    function swap<T>(arr: T[], i: number, j: number): void {\n        let temp: T = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    function sortHelper<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (arr.length <= 0 || !callbackfn) {\n            return arr;\n        }\n        let len = arr.length;\n        // simple selection sort.\n        for (let i = 0; i < len - 1; ++i) {\n            for (let j = i + 1; j < len; ++j) {\n                if (callbackfn(arr[i], arr[j]) > 0) {\n                    swap(arr, i, j);\n                }\n            }\n        }\n        return arr;\n    }\n\n    export function arraySort<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (!callbackfn) {\n            //TODO: support native strings and number sorting\n            /* callbackfn = function (value1: string, value2: string) : number {\n                return value1.compare(value2);\n                }*/\n        }\n        return sortHelper(arr, callbackfn);\n    }\n\n    export function arrayMap<T, U>(arr: T[], callbackfn: (value: T, index: number) => U): U[] {\n        let res: U[] = []\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            res.push(callbackfn(arr[i], i))\n        }\n        return res\n    }\n\n    export function arraySome<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (callbackfn(arr[i], i))\n                return true;\n        return false;\n    }\n\n    export function arrayEvery<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (!callbackfn(arr[i], i))\n                return false;\n        return true;\n    }\n\n    export function arrayForEach<T>(arr: T[], callbackfn: (value: T, index: number) => void): void {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            callbackfn(arr[i], i);\n        }\n    }\n\n    export function arrayFilter<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T[] {\n        let res: T[] = []\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) res.push(v)\n        }\n        return res\n    }\n\n    export function arrayReduce<T, U>(arr: T[], callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            initialValue = callbackfn(initialValue, arr[i], i)\n        }\n        return initialValue\n    }\n\n    export function arraySlice<T>(arr: T[], start: number, end: number): T[] {\n        const res: T[] = [];\n        const len = arr.length;\n\n        if (start < 0) {\n            start = Math.max(len + start, 0);\n        }\n\n        if (end < 0) {\n            end = len + end;\n        }\n\n        const sliceLength = end - start;\n\n        for (let i = 0; i < sliceLength; ++i) {\n            const index = i + start;\n            if (index >= len) {\n                break;\n            }\n            res.push(arr[index]);\n        }\n        return res;\n    }\n\n    export function stringSlice(s: string, start: number, end?: number): string {\n        const len = s.length;\n\n        if (start < 0) {\n            start = Math.max(len + start, 0);\n        }\n\n        if (end == null) {\n            end = len;\n        }\n\n        if (end < 0) {\n            end = len + end;\n        }\n\n        return s.substr(start, end - start);\n    }\n}\n\nnamespace Math {\n    export function clamp(min: number, max: number, value: number): number {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    export function abs(x: number): number {\n        return x < 0 ? -x : x;\n    }\n\n    /**\n      * Returns the sign of the x, indicating whether x is positive, negative or zero.\n      * @param x The numeric expression to test\n      */\n    export function sign(x: number): number {\n        if (x == 0) return 0;\n        if (x > 0) return 1;\n        return -1;\n    }\n\n    /**\n      * Returns the larger of two supplied numeric expressions.\n      */\n    export function max(a: number, b: number): number {\n        if (a >= b) return a;\n        return b;\n    }\n\n    /**\n      * Returns the smaller of two supplied numeric expressions.\n      */\n    export function min(a: number, b: number): number {\n        if (a <= b) return a;\n        return b;\n    }\n\n    /**\n     * Rounds ``x`` to a number with the given number of ``digits``\n     * @param x the number to round\n     * @param digits the number of resulting digits\n     */\n    //%\n    export function roundWithPrecision(x: number, digits: number): number {\n        digits = digits | 0;\n        // invalid digits input\n        if (digits <= 0) return Math.round(x);\n        if (x == 0) return 0;\n        let r = 0;\n        do {\n            const d = Math.pow(10, digits);\n            r = Math.round(x * d) / d;\n            digits++;\n        } while (r == 0 && digits < 21);\n        return r;\n    }\n}\n\n\n//% blockHidden=1\nnamespace __internal {\n    /**\n     * A shim to render a boolean as a down/up toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleDownUp block=\"%down\"\n    //% down.fieldEditor=toggledownup\n    //% down.fieldOptions.decompileLiterals=true\n    export function __downUp(down: boolean): boolean {\n        return down;\n    }\n\n    /**\n     * A shim to render a boolean as a up/down toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleUpDown block=\"%up\"\n    //% up.fieldEditor=toggleupdown\n    //% up.fieldOptions.decompileLiterals=true\n    export function __upDown(up: boolean): boolean {\n        return up;\n    }\n\n    /**\n     * A shim to render a boolean as a high/low toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleHighLow block=\"%high\"\n    //% high.fieldEditor=togglehighlow\n    //% high.fieldOptions.decompileLiterals=true\n    export function __highLow(high: boolean): boolean {\n        return high;\n    }\n\n    /**\n     * A shim to render a boolean as a on/off toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleOnOff block=\"%on\"\n    //% on.fieldEditor=toggleonoff\n    //% on.fieldOptions.decompileLiterals=true\n    export function __onOff(on: boolean): boolean {\n        return on;\n    }\n\n    /**\n     * A shim to render a boolean as a yes/no toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleYesNo block=\"%yes\"\n    //% yes.fieldEditor=toggleyesno\n    //% yes.fieldOptions.decompileLiterals=true\n    export function __yesNo(yes: boolean): boolean {\n        return yes;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param color color, eg: #ff0000\n     */\n    //% blockId=colorNumberPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.defl='#ff0000'\n    //% value.fieldOptions.colours='[\"#ff0000\",\"#ff8000\",\"#ffff00\",\"#ff9da5\",\"#00ff00\",\"#b09eff\",\"#00ffff\",\"#007fff\",\"#65471f\",\"#0000ff\",\"#7f00ff\",\"#ff0080\",\"#ff00ff\",\"#ffffff\",\"#999999\",\"#000000\"]'\n    //% value.fieldOptions.columns=4 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param value value between 0 to 255 to get a color value, eg: 10\n     */\n    //% blockId=colorWheelPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    export function __colorWheelPicker(value: number) {\n        return value;\n    }\n\n    /**\n    * Get the color wheel field editor using HSV values\n    * @param value value between 0 to 255 to get a color value, eg: 10\n    */\n    //% blockId=colorWheelHsvPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    //% value.fieldOptions.channel=hsvfast\n    export function __colorWheelHsvPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * A speed picker\n     * @param speed the speed, eg: 50\n     */\n    //% blockId=speedPicker block=\"%speed\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 speed.fieldOptions.decompileLiterals=1\n    export function __speedPicker(speed: number): number {\n        return speed;\n    }\n\n    /**\n     * A turn ratio picker\n     * @param turnratio the turn ratio, eg: 0\n     */\n    //% blockId=turnRatioPicker block=\"%turnratio\" shim=TD_ID\n    //% turnratio.fieldEditor=\"turnratio\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 turnRatio.fieldOptions.decompileLiterals=1\n    export function __turnRatioPicker(turnratio: number): number {\n        return turnratio;\n    }\n\n    /**\n     * A field editor that displays a protractor\n     */\n    //% blockId=protractorPicker block=\"%angle\"\n    //% shim=TD_ID\n    //% angle.fieldEditor=protractor\n    //% angle.fieldOptions.decompileLiterals=1    \n    //% colorSecondary=\"#FFFFFF\"\n    //% blockHidden=1\n    export function __protractor(angle: number) {\n        return angle;\n    }\n\n    /**\n      * Get the time field editor\n      * @param ms time duration in milliseconds, eg: 500, 1000\n      */\n    //% blockId=timePicker block=\"%ms\"\n    //% blockHidden=true shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% ms.fieldEditor=\"numberdropdown\" ms.fieldOptions.decompileLiterals=true\n    //% ms.fieldOptions.data='[[\"100 ms\", 100], [\"200 ms\", 200], [\"500 ms\", 500], [\"1 second\", 1000], [\"2 seconds\", 2000]]'\n    export function __timePicker(ms: number): number {\n        return ms;\n    }\n}",
      "pxt.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\nnamespace pxt {\n\n#ifndef PXT_GC\nTValue incr(TValue e) {\n    if (isRefCounted(e)) {\n        getVTable((RefObject *)e);\n        ((RefObject *)e)->ref();\n    }\n    return e;\n}\n\nvoid decr(TValue e) {\n    if (isRefCounted(e)) {\n        ((RefObject *)e)->unref();\n    }\n}\n#endif\n\nAction mkAction(int totallen, RefAction *act) {\n    check(getVTable(act)->classNo == BuiltInType::RefAction,\n          PANIC_INVALID_BINARY_HEADER, 1);\n\n    if (totallen == 0) {\n        return (TValue)act; // no closure needed\n    }\n\n    void *ptr = gcAllocate(sizeof(RefAction) + totallen * sizeof(unsigned));\n    RefAction *r = new (ptr) RefAction();\n    r->len = totallen;\n    r->func = act->func;\n    memset(r->fields, 0, r->len * sizeof(unsigned));\n\n    MEMDBG(\"mkAction: start=%p => %p\", act, r);\n\n    return (Action)r;\n}\n\nRefRecord *mkClassInstance(VTable *vtable) {\n    intcheck(vtable->methods[0] == &RefRecord_destroy, PANIC_SIZE, 3);\n    //intcheck(vtable->methods[1] == &RefRecord_print, PANIC_SIZE, 4);\n\n    void *ptr = gcAllocate(vtable->numbytes);\n    RefRecord *r = new (ptr) RefRecord(vtable);\n    memset(r->fields, 0, vtable->numbytes - sizeof(RefRecord));\n    MEMDBG(\"mkClass: vt=%p => %p\", vtable, r);\n    return r;\n}\n\nTValue RefRecord::ld(int idx) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 1);\n    return fields[idx];\n}\n\nTValue RefRecord::ldref(int idx) {\n    // DMESG(\"LD %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 2);\n    TValue tmp = fields[idx];\n    incr(tmp);\n    return tmp;\n}\n\nvoid RefRecord::st(int idx, TValue v) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 3);\n    fields[idx] = v;\n}\n\nvoid RefRecord::stref(int idx, TValue v) {\n    // DMESG(\"ST %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 4);\n    decr(fields[idx]);\n    fields[idx] = v;\n}\n\nvoid RefObject::destroyVT() {\n    ((RefObjectMethod)getVTable(this)->methods[0])(this);\n#ifndef PXT_GC\n    free(this);\n#endif\n}\n\n//%\nvoid deleteRefObject(RefObject *obj) {\n    obj->destroyVT();\n}\n\nvoid RefObject::printVT() {\n    ((RefObjectMethod)getVTable(this)->methods[1])(this);\n}\n\nvoid RefRecord_destroy(RefRecord *r) {\n#ifndef PXT_GC\n    VTable *tbl = getVTable(r);\n    int len = (tbl->numbytes - sizeof(RefRecord)) >> 2;\n    for (int i = 0; i < len; ++i) {\n        decr(r->fields[i]);\n        r->fields[i] = 0;\n    }\n#endif\n}\n\nvoid RefRecord_print(RefRecord *r) {\n    DMESG(\"RefRecord %p r=%d size=%d bytes\", r, REFCNT(r), getVTable(r)->numbytes);\n}\n\nTValue Segment::get(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::get index:%d\", i);\n    this->print();\n#endif\n\n    if (i < length) {\n        return data[i];\n    }\n    return Segment::DefaultValue;\n}\n\nvoid Segment::setRef(unsigned i, TValue value) {\n    decr(get(i));\n    set(i, value);\n}\n\nvoid Segment::set(unsigned i, TValue value) {\n    if (i < size) {\n        data[i] = value;\n    } else if (i < Segment::MaxSize) {\n        growByMin(i + 1);\n        data[i] = value;\n    } else {\n        return;\n    }\n    if (length <= i) {\n        length = i + 1;\n    }\n\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::set\");\n    this->print();\n#endif\n\n    return;\n}\n\nramint_t Segment::growthFactor(ramint_t size) {\n    if (size == 0) {\n        return 4;\n    }\n    if (size < 64) {\n        return size * 2; // Double\n    }\n    if (size < 512) {\n        return size * 5 / 3; // Grow by 1.66 rate\n    }\n    // Grow by constant rate\n    if ((unsigned)size + 256 < MaxSize)\n        return size + 256;\n    else\n        return MaxSize;\n}\n\nvoid Segment::growByMin(ramint_t minSize) {\n    growBy(max(minSize, growthFactor(size)));\n}\n\nvoid Segment::growBy(ramint_t newSize) {\n#ifdef DEBUG_BUILD\n    DMESG(\"growBy: %d\", newSize);\n    this->print();\n#endif\n    if (size < newSize) {\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(xmalloc(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size) {\n            memcpy(tmp, data, size * sizeof(TValue));\n        }\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        // free older segment;\n        free(data);\n\n        data = tmp;\n        size = newSize;\n\n#ifdef DEBUG_BUILD\n        DMESG(\"growBy - after reallocation\");\n        this->print();\n#endif\n    }\n    // else { no shrinking yet; }\n    return;\n}\n\nvoid Segment::ensure(ramint_t newSize) {\n    if (newSize < size) {\n        return;\n    }\n    growByMin(newSize);\n}\n\nvoid Segment::setLength(unsigned newLength) {\n    if (newLength > size) {\n        ensure(length);\n    }\n    length = newLength;\n    return;\n}\n\nvoid Segment::push(TValue value) {\n    this->set(length, value);\n}\n\nTValue Segment::pop() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::pop\");\n    this->print();\n#endif\n\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = Segment::DefaultValue;\n        return value;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function removes an element at index i and shifts the rest of the elements to\n// left to fill the gap\nTValue Segment::remove(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::remove index:%d\", i);\n    this->print();\n#endif\n    if (i < length) {\n        // value to return\n        TValue ret = data[i];\n        if (i + 1 < length) {\n            // Move the rest of the elements to fill in the gap.\n            memmove(data + i, data + i + 1, (length - i - 1) * sizeof(unsigned));\n        }\n        length--;\n        data[length] = Segment::DefaultValue;\n#ifdef DEBUG_BUILD\n        DMESG(\"After Segment::remove index:%d\", i);\n        this->print();\n#endif\n        return ret;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function inserts element value at index i by shifting the rest of the elements right.\nvoid Segment::insert(unsigned i, TValue value) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::insert index:%d value:%d\", i, value);\n    this->print();\n#endif\n\n    if (i < length) {\n        ensure(length + 1);\n\n        // Move the rest of the elements to fill in the gap.\n        memmove(data + i + 1, data + i, (length - i) * sizeof(unsigned));\n\n        data[i] = value;\n        length++;\n    } else {\n        // This is insert beyond the length, just call set which will adjust the length\n        set(i, value);\n    }\n#ifdef DEBUG_BUILD\n    DMESG(\"After Segment::insert index:%d\", i);\n    this->print();\n#endif\n}\n\nvoid Segment::print() {\n    DMESG(\"Segment: %p, length: %d, size: %d\", data, (unsigned)length, (unsigned)size);\n    for (unsigned i = 0; i < size; i++) {\n        DMESG(\"-> %d\", (unsigned)(uintptr_t)data[i]);\n    }\n}\n\nbool Segment::isValidIndex(unsigned i) {\n    if (i > length) {\n        return false;\n    }\n    return true;\n}\n\nvoid Segment::destroy() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::destroy\");\n    this->print();\n#endif\n    length = size = 0;\n    free(data);\n    data = nullptr;\n}\n\nvoid RefCollection::push(TValue x) {\n    incr(x);\n    head.push(x);\n}\n\nTValue RefCollection::pop() {\n    TValue ret = head.pop();\n    incr(ret);\n    return ret;\n}\n\nTValue RefCollection::getAt(int i) {\n    TValue tmp = head.get(i);\n    incr(tmp);\n    return tmp;\n}\n\nTValue RefCollection::removeAt(int i) {\n    return head.remove(i);\n}\n\nvoid RefCollection::insertAt(int i, TValue value) {\n    head.insert(i, value);\n    incr(value);\n}\n\nvoid RefCollection::setAt(int i, TValue value) {\n    incr(value);\n    head.setRef(i, value);\n}\n\nint RefCollection::indexOf(TValue x, int start) {\n#ifndef X86_64\n    unsigned i = start;\n    while (head.isValidIndex(i)) {\n        if (pxt::eq_bool(head.get(i), x)) {\n            return (int)i;\n        }\n        i++;\n    }\n#endif\n    return -1;\n}\n\nbool RefCollection::removeElement(TValue x) {\n    int idx = indexOf(x, 0);\n    if (idx >= 0) {\n        decr(removeAt(idx));\n        return 1;\n    }\n    return 0;\n}\n\nPXT_VTABLE_CTOR(RefCollection) {}\n\nvoid RefCollection::destroy(RefCollection *t) {\n#ifndef PXT_GC\n    auto data = t->head.getData();\n    auto len = t->head.getLength();\n    for (unsigned i = 0; i < len; i++) {\n        decr(data[i]);\n    }\n#endif\n    t->head.destroy();\n}\n\nvoid RefCollection::print(RefCollection *t) {\n    DMESG(\"RefCollection %p r=%d size=%d\", t, REFCNT(t), t->head.getLength());\n    t->head.print();\n}\n\nPXT_VTABLE_CTOR(RefAction) {}\n\n// fields[] contain captured locals\nvoid RefAction::destroy(RefAction *t) {\n#ifndef PXT_GC\n    for (int i = 0; i < t->len; ++i) {\n        decr(t->fields[i]);\n        t->fields[i] = 0;\n    }\n#endif\n}\n\nvoid RefAction::print(RefAction *t) {\n    DMESG(\"RefAction %p r=%d pc=%X size=%d\", t, REFCNT(t),\n          (const uint8_t *)t->func - (const uint8_t *)bytecode, t->len);\n}\n\nPXT_VTABLE_CTOR(RefRefLocal) {\n    v = 0;\n}\n\nvoid RefRefLocal::print(RefRefLocal *t) {\n    DMESG(\"RefRefLocal %p r=%d v=%p\", t, REFCNT(t), (void *)t->v);\n}\n\nvoid RefRefLocal::destroy(RefRefLocal *t) {\n    decr(t->v);\n}\n\nPXT_VTABLE_CTOR(RefMap) {}\n\nvoid RefMap::destroy(RefMap *t) {\n#ifndef PXT_GC\n    auto len = t->values.getLength();\n    auto values = t->values.getData();\n    auto keys = t->keys.getData();\n    intcheck(t->keys.getLength() == len, PANIC_SIZE, 101);\n    for (unsigned i = 0; i < len; ++i) {\n        decr(values[i]);\n        values[i] = nullptr;\n        decr(keys[i]);\n        keys[i] = nullptr;\n    }\n#endif\n    t->keys.destroy();\n    t->values.destroy();\n}\n\nint RefMap::findIdx(String key) {\n    auto len = keys.getLength();\n    auto data = (String *)keys.getData();\n\n    // fast path\n    for (unsigned i = 0; i < len; ++i) {\n        if (data[i] == key)\n            return i;\n    }\n\n    // slow path\n    auto keylen = key->length;\n    for (unsigned i = 0; i < len; ++i) {\n        auto s = data[i];\n        if (s->length == keylen && memcmp(s->data, key->data, keylen) == 0)\n            return i;\n    }\n\n    return -1;\n}\n\nvoid RefMap::print(RefMap *t) {\n    DMESG(\"RefMap %p r=%d size=%d\", t, REFCNT(t), t->keys.getLength());\n}\n\nvoid debugMemLeaks() {}\n\nvoid error(PXT_PANIC code, int subcode) {\n    DMESG(\"Error: %d [%d]\", code, subcode);\n    target_panic(code);\n}\n\nuint16_t *bytecode;\nTValue *globals;\n\nunsigned *allocate(ramint_t sz) {\n    unsigned *arr = new unsigned[sz];\n    memset(arr, 0, sz * sizeof(unsigned));\n    return arr;\n}\n\nvoid checkStr(bool cond, const char *msg) {\n    if (!cond) {\n        while (true) {\n            // uBit.display.scroll(msg, 100);\n            // uBit.sleep(100);\n        }\n    }\n}\n\nint templateHash() {\n    return ((int *)bytecode)[4];\n}\n\nint programHash() {\n    return ((int *)bytecode)[6];\n}\n\nint getNumGlobals() {\n    return bytecode[16];\n}\n\n#ifndef X86_64\nvoid exec_binary(unsigned *pc) {\n    // XXX re-enable once the calibration code is fixed and [editor/embedded.ts]\n    // properly prepends a call to [internal_main].\n    // ::touch_develop::internal_main();\n\n    // unique group for radio based on source hash\n    // ::touch_develop::micro_bit::radioDefaultGroup = programHash();\n\n    unsigned ver = *pc++;\n    checkStr(ver == 0x4210, \":( Bad runtime version\");\n\n    bytecode = *((uint16_t **)pc++); // the actual bytecode is here\n    globals = (TValue *)allocate(getNumGlobals());\n\n    // can be any valid address, best in RAM for speed\n    globals[0] = (TValue)&globals;\n\n    // just compare the first word\n    // TODO\n    checkStr(((uint32_t *)bytecode)[0] == 0x923B8E70 && (unsigned)templateHash() == *pc,\n             \":( Failed partial flash\");\n\n    uintptr_t startptr = (uintptr_t)bytecode;\n\n    startptr += 64; // header\n\n    initPerfCounters();\n\n    initRuntime();\n\n    runAction0((Action)startptr);\n\n    pxt::releaseFiber();\n}\n\nvoid start() {\n    exec_binary((unsigned *)functionsAndBytecode);\n}\n#endif\n\n} // namespace pxt\n\nnamespace Array_ {\n//%\nbool isArray(TValue arr) {\n    auto vt = getAnyVTable(arr);\n    return vt && vt->classNo == BuiltInType::RefCollection;\n}\n} // namespace Array_\n\nnamespace pxtrt {\n//%\nRefCollection *keysOf(TValue v) {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl[keys]: => %p\", r);\n    if (getAnyVTable(v) != &RefMap_vtable)\n        return r;\n    auto rm = (RefMap *)v;\n    auto len = rm->keys.getLength();\n    if (!len)\n        return r;\n    r->setLength(len);\n    auto dst = r->getData();\n    memcpy(dst, rm->keys.getData(), len * sizeof(TValue));\n    for (unsigned i = 0; i < len; ++i)\n        incr(dst[i]);\n    return r;\n}\n} // namespace pxtrt\n",
      "pxt.json": "{\n    \"name\": \"base\",\n    \"description\": \"The base library\",\n    \"files\": [\n        \"README.md\",\n        \"pxt-core.d.ts\",\n        \"pxt.cpp\",\n        \"gc.cpp\",\n        \"pxtbase.h\",\n        \"core.cpp\",\n        \"advmath.cpp\",\n        \"pxt-helpers.ts\",\n        \"buffer.cpp\",\n        \"buffer.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"loops.cpp\",\n        \"math.ts\",\n        \"ns.ts\",\n        \"control.cpp\",\n        \"control.ts\",\n        \"console.ts\",\n        \"json.ts\",\n        \"eventcontext.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {},\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtbase.h": "#ifndef __PXTBASE_H\n#define __PXTBASE_H\n\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wformat\"\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n\n// needed for gcc6; not sure why\n#undef min\n#undef max\n\n#define NOLOG(...)                                                                                 \\\n    do {                                                                                           \\\n    } while (0)\n\n#define MEMDBG NOLOG\n//#define MEMDBG DMESG\n#define MEMDBG2 NOLOG\n\n#include \"pxtconfig.h\"\n\n#define intcheck(...) check(__VA_ARGS__)\n//#define intcheck(...) do {} while (0)\n\n#ifdef PXT_USE_FLOAT\n#define NUMBER float\n#else\n#define NUMBER double\n#endif\n\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n\n#ifdef POKY\nvoid *operator new(size_t size, void *ptr);\nvoid *operator new(size_t size);\n#else\n#include <new>\n#endif\n\n#include \"platform.h\"\n#include \"pxtcore.h\"\n\n#ifndef PXT_VTABLE_SHIFT\n#define PXT_VTABLE_SHIFT 2\n#endif\n\n#define PXT_REFCNT_FLASH 0xfffe\n\n#define CONCAT_1(a, b) a##b\n#define CONCAT_0(a, b) CONCAT_1(a, b)\n#define STATIC_ASSERT(e) enum { CONCAT_0(_static_assert_, __LINE__) = 1 / ((e) ? 1 : 0) };\n\n#ifndef ramint_t\n// this type limits size of arrays\n#ifdef __linux__\n#define ramint_t uint32_t\n#else\n#define ramint_t uint16_t\n#endif\n#endif\n\n#ifdef POKY\ninline void *operator new(size_t, void *p) {\n    return p;\n}\ninline void *operator new[](size_t, void *p) {\n    return p;\n}\n#endif\n\nnamespace pxt {\n\ntemplate <typename T> inline const T &max(const T &a, const T &b) {\n    if (a < b)\n        return b;\n    return a;\n}\n\ntemplate <typename T> inline const T &min(const T &a, const T &b) {\n    if (a < b)\n        return a;\n    return b;\n}\n\ntemplate <typename T> inline void swap(T &a, T &b) {\n    T tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//\n// Tagged values (assume 4 bytes for now, Cortex-M0)\n//\nstruct TValueStruct {};\ntypedef TValueStruct *TValue;\n\ntypedef TValue TNumber;\ntypedef TValue Action;\ntypedef TValue ImageLiteral;\n\n// To be implemented by the target\nextern \"C\" void target_panic(int error_code);\nextern \"C\" void target_reset();\nvoid sleep_ms(unsigned ms);\nvoid sleep_us(uint64_t us);\nvoid releaseFiber();\nuint64_t current_time_us();\nint current_time_ms();\nvoid initRuntime();\nvoid sendSerial(const char *data, int len);\nvoid setSendToUART(void (*f)(const char *, int));\nint getSerialNumber();\nvoid registerWithDal(int id, int event, Action a, int flags = 16); // EVENT_LISTENER_DEFAULT_FLAGS\nvoid runInParallel(Action a);\nvoid runForever(Action a);\nvoid waitForEvent(int id, int event);\n//%\nunsigned afterProgramPage();\n//%\nvoid dumpDmesg();\n\n// also defined DMESG macro\n// end\n\n#define TAGGED_SPECIAL(n) (TValue)(void *)((n << 2) | 2)\n#define TAG_FALSE TAGGED_SPECIAL(2) // 10\n#define TAG_TRUE TAGGED_SPECIAL(16) // 66\n#define TAG_UNDEFINED (TValue)0\n#define TAG_NULL TAGGED_SPECIAL(1) // 6\n#define TAG_NAN TAGGED_SPECIAL(3)  // 14\n#define TAG_NUMBER(n) (TNumber)(void *)((n << 1) | 1)\n\ninline bool isTagged(TValue v) {\n    return ((intptr_t)v & 3) || !v;\n}\n\ninline bool isNumber(TValue v) {\n    return (intptr_t)v & 1;\n}\n\ninline bool isSpecial(TValue v) {\n    return (intptr_t)v & 2;\n}\n\ninline bool bothNumbers(TValue a, TValue b) {\n    return (intptr_t)a & (intptr_t)b & 1;\n}\n\ninline int numValue(TValue n) {\n    return (intptr_t)n >> 1;\n}\n\n#ifdef PXT_BOX_DEBUG\ninline bool canBeTagged(int) {\n    return false;\n}\n#else\ninline bool canBeTagged(int v) {\n    return (v << 1) >> 1 == v;\n}\n#endif\n\ntypedef enum {\n    PANIC_INVALID_BINARY_HEADER = 901,\n    PANIC_OUT_OF_BOUNDS = 902,\n    PANIC_REF_DELETED = 903,\n    PANIC_SIZE = 904,\n    PANIC_INVALID_VTABLE = 905,\n    PANIC_INTERNAL_ERROR = 906,\n    PANIC_NO_SUCH_CONFIG = 907,\n    PANIC_NO_SUCH_PIN = 908,\n    PANIC_INVALID_ARGUMENT = 909,\n    PANIC_MEMORY_LIMIT_EXCEEDED = 910,\n    PANIC_SCREEN_ERROR = 911,\n    PANIC_MISSING_PROPERTY = 912,\n    PANIC_INVALID_IMAGE = 913,\n\n    PANIC_CAST_FIRST = 980,\n    PANIC_CAST_FROM_UNDEFINED = 980,\n    PANIC_CAST_FROM_BOOLEAN = 981,\n    PANIC_CAST_FROM_NUMBER = 982,\n    PANIC_CAST_FROM_STRING = 983,\n    PANIC_CAST_FROM_OBJECT = 984,\n    PANIC_CAST_FROM_FUNCTION = 985,\n    PANIC_CAST_FROM_NULL = 989,\n\n} PXT_PANIC;\n\nextern const unsigned functionsAndBytecode[];\nextern TValue *globals;\nextern uint16_t *bytecode;\nclass RefRecord;\n\n// Utility functions\n\ntypedef TValue (*RunActionType)(Action a, TValue arg0, TValue arg1, TValue arg2);\ntypedef TValue (*GetPropertyType)(TValue obj, unsigned key);\ntypedef TValue (*SetPropertyType)(TValue obj, unsigned key, TValue v);\n\n#define asmRunAction3 ((RunActionType)(((uintptr_t *)bytecode)[12]))\n\nstatic inline TValue runAction3(Action a, TValue arg0, TValue arg1, TValue arg2) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction2(Action a, TValue arg0, TValue arg1) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction1(Action a, TValue arg0) {\n    return asmRunAction3(a, arg0, 0, 0);\n}\nstatic inline TValue runAction0(Action a) {\n    return asmRunAction3(a, 0, 0, 0);\n}\n\nclass RefAction;\nstruct VTable;\n\n//%\nAction mkAction(int totallen, RefAction *act);\n// allocate [sz] words and clear them\n//%\nunsigned *allocate(ramint_t sz);\n//%\nint templateHash();\n//%\nint programHash();\n//%\nunsigned programSize();\n//%\nint getNumGlobals();\n//%\nRefRecord *mkClassInstance(VTable *vt);\n//%\nvoid debugMemLeaks();\n//%\nvoid anyPrint(TValue v);\n\nint getConfig(int key, int defl = -1);\n\n//%\nint toInt(TNumber v);\n//%\nunsigned toUInt(TNumber v);\n//%\nNUMBER toDouble(TNumber v);\n//%\nfloat toFloat(TNumber v);\n//%\nTNumber fromDouble(NUMBER r);\n//%\nTNumber fromFloat(float r);\n\n//%\nTNumber fromInt(int v);\n//%\nTNumber fromUInt(unsigned v);\n//%\nTValue fromBool(bool v);\n//%\nbool eq_bool(TValue a, TValue b);\n//%\nbool eqq_bool(TValue a, TValue b);\n\n//%\nvoid failedCast(TValue v);\n//%\nvoid missingProperty(TValue v);\n\nvoid error(PXT_PANIC code, int subcode = 0);\nvoid exec_binary(unsigned *pc);\nvoid start();\n\nstruct HandlerBinding {\n    HandlerBinding *next;\n    int source;\n    int value;\n    Action action;\n};\nHandlerBinding *findBinding(int source, int value);\nvoid setBinding(int source, int value, Action act);\n\n// The standard calling convention is:\n//   - when a pointer is loaded from a local/global/field etc, and incr()ed\n//     (in other words, its presence on stack counts as a reference)\n//   - after a function call, all pointers are popped off the stack and decr()ed\n// This does not apply to the RefRecord and st/ld(ref) methods - they unref()\n// the RefRecord* this.\n//%\nTValue incr(TValue e);\n//%\nvoid decr(TValue e);\n\n#ifdef PXT_GC\ninline TValue incr(TValue e) {\n    return e;\n}\ninline void decr(TValue e) {}\n#endif\n\nclass RefObject;\n\nstatic inline RefObject *incrRC(RefObject *r) {\n    return (RefObject *)incr((TValue)r);\n}\nstatic inline void decrRC(RefObject *r) {\n    decr((TValue)r);\n}\n\ninline void *ptrOfLiteral(int offset) {\n    return &bytecode[offset];\n}\n\n// Checks if object is ref-counted, and has a custom PXT vtable in front\n// TODO\ninline bool isRefCounted(TValue e) {\n#ifdef PXT_GC\n    return !isTagged(e);\n#else\n    return !isTagged(e) && (*((uint16_t *)e) & 1) == 1;\n#endif\n}\n\ninline void check(int cond, PXT_PANIC code, int subcode = 0) {\n    if (!cond)\n        error(code, subcode);\n}\n\ninline void oops(int subcode = 0) {\n    target_panic(800 + subcode);\n}\n\nclass RefObject;\n\ntypedef void (*RefObjectMethod)(RefObject *self);\ntypedef unsigned (*RefObjectSizeMethod)(RefObject *self);\ntypedef void *PVoid;\ntypedef void **PPVoid;\n\ntypedef void *Object_;\n\n#define VTABLE_MAGIC 0xF9\n\nenum class ValType : uint8_t {\n    Undefined,\n    Boolean,\n    Number,\n    String,\n    Object,\n    Function,\n};\n\n// keep in sync with pxt-core (search for the type name)\nenum class BuiltInType : uint16_t {\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    User0 = 16,\n};\n\nstruct VTable {\n    uint16_t numbytes;\n    ValType objectType;\n    uint8_t magic;\n    PVoid *ifaceTable;\n    BuiltInType classNo;\n    uint16_t reserved;\n    uint32_t ifaceHashMult;\n    // we only use the first few methods here; pxt will generate more\n#ifdef PXT_GC\n    PVoid methods[5];\n#else\n    PVoid methods[3];\n#endif\n};\n\n//%\nextern const VTable string_vt;\n//%\nextern const VTable buffer_vt;\n//%\nextern const VTable number_vt;\n//%\nextern const VTable RefAction_vtable;\n\n#ifdef PXT_GC\n#define PXT_VTABLE_TO_INT(vt) ((uintptr_t)(vt))\n#else\n#define PXT_VTABLE_TO_INT(vt) ((uintptr_t)(vt) >> PXT_VTABLE_SHIFT)\n#endif\n\n#ifdef PXT_GC\ninline bool isReadOnly(TValue v) {\n    return isTagged(v) || !((uint32_t)v >> 26);\n}\n#endif\n\n#ifdef PXT_GC\n#define REFCNT(x) 0\n#else\n#define REFCNT(x) ((x)->refcnt)\n#endif\n\n// A base abstract class for ref-counted objects.\nclass RefObject {\n  public:\n#ifdef PXT_GC\n    uint32_t vtable;\n\n    RefObject(const VTable *vt) { vtable = PXT_VTABLE_TO_INT(vt); }\n#else\n    uint16_t refcnt;\n    uint16_t vtable;\n\n    RefObject(const VTable *vt) {\n        refcnt = 3;\n        vtable = PXT_VTABLE_TO_INT(vt);\n    }\n#endif\n\n    void destroyVT();\n    void printVT();\n\n#ifdef PXT_GC\n    inline void ref() {}\n    inline void unref() {}\n    inline bool isReadOnly() { return pxt::isReadOnly((TValue)this); }\n#else\n    inline bool isReadOnly() { return refcnt == PXT_REFCNT_FLASH; }\n\n    // Increment/decrement the ref-count. Decrementing to zero deletes the current object.\n    inline void ref() {\n        if (isReadOnly())\n            return;\n        MEMDBG2(\"INCR: %p refs=%d\", this, this->refcnt);\n        check(refcnt > 1, PANIC_REF_DELETED);\n        refcnt += 2;\n    }\n\n    inline void unref() {\n        if (isReadOnly())\n            return;\n        MEMDBG2(\"DECR: %p refs=%d\", this, this->refcnt);\n        check(refcnt > 1, PANIC_REF_DELETED);\n        check((refcnt & 1), PANIC_REF_DELETED);\n        refcnt -= 2;\n        if (refcnt == 1) {\n            MEMDBG(\"DEL: %p\", this);\n            destroyVT();\n        }\n    }\n#endif\n};\n\nclass Segment {\n  private:\n    TValue *data;\n    ramint_t length;\n    ramint_t size;\n\n    // this just gives max value of ramint_t\n    static constexpr ramint_t MaxSize = (((1U << (8 * sizeof(ramint_t) - 1)) - 1) << 1) + 1;\n    static constexpr TValue DefaultValue = TAG_UNDEFINED;\n\n    static ramint_t growthFactor(ramint_t size);\n    void growByMin(ramint_t minSize);\n    void growBy(ramint_t newSize);\n    void ensure(ramint_t newSize);\n\n  public:\n    Segment() : data(nullptr), length(0), size(0){};\n\n    TValue get(unsigned i);\n    void set(unsigned i, TValue value);\n    void setRef(unsigned i, TValue value);\n\n    unsigned getLength() { return length; };\n    void setLength(unsigned newLength);\n    void resize(unsigned newLength) { setLength(newLength); }\n\n    void push(TValue value);\n    TValue pop();\n\n    TValue remove(unsigned i);\n    void insert(unsigned i, TValue value);\n\n    bool isValidIndex(unsigned i);\n\n    void destroy();\n\n    void print();\n\n    TValue *getData() { return data; }\n};\n\n// A ref-counted collection of either primitive or ref-counted objects (String, Image,\n// user-defined record, another collection)\nclass RefCollection : public RefObject {\n  private:\n    Segment head;\n\n  public:\n    RefCollection();\n\n    static void destroy(RefCollection *coll);\n    static void scan(RefCollection *coll);\n    static unsigned gcsize(RefCollection *coll);\n    static void print(RefCollection *coll);\n\n    unsigned length() { return head.getLength(); }\n    void setLength(unsigned newLength) { head.setLength(newLength); }\n\n    void push(TValue x);\n    TValue pop();\n    TValue getAt(int i);\n    void setAt(int i, TValue x);\n    // removes the element at index i and shifts the other elements left\n    TValue removeAt(int i);\n    // inserts the element at index i and moves the other elements right.\n    void insertAt(int i, TValue x);\n\n    int indexOf(TValue x, int start);\n    bool removeElement(TValue x);\n\n    TValue *getData() { return head.getData(); }\n};\n\nclass BoxedString;\nclass RefMap : public RefObject {\n  public:\n    Segment keys;\n    Segment values;\n\n    RefMap();\n    static void destroy(RefMap *map);\n    static void scan(RefMap *map);\n    static unsigned gcsize(RefMap *coll);\n    static void print(RefMap *map);\n    int findIdx(BoxedString *key);\n};\n\n// A ref-counted, user-defined JS object.\nclass RefRecord : public RefObject {\n  public:\n    // The object is allocated, so that there is space at the end for the fields.\n    TValue fields[];\n\n    RefRecord(VTable *v) : RefObject(v) {}\n\n    TValue ld(int idx);\n    TValue ldref(int idx);\n    void st(int idx, TValue v);\n    void stref(int idx, TValue v);\n};\n\nstatic inline VTable *getVTable(RefObject *r) {\n#ifdef PXT_GC\n    return (VTable *)(r->vtable & ~1);\n#else\n    return (VTable *)((uintptr_t)r->vtable << PXT_VTABLE_SHIFT);\n#endif\n}\n\nstatic inline VTable *getAnyVTable(TValue v) {\n    if (!isRefCounted(v))\n        return NULL;\n    auto vt = getVTable((RefObject *)v);\n    if (vt->magic == VTABLE_MAGIC)\n        return vt;\n    return NULL;\n}\n\n// these are needed when constructing vtables for user-defined classes\n//%\nvoid RefRecord_destroy(RefRecord *r);\n//%\nvoid RefRecord_print(RefRecord *r);\n//%\nvoid RefRecord_scan(RefRecord *r);\n//%\nunsigned RefRecord_gcsize(RefRecord *r);\n\ntypedef TValue (*ActionCB)(TValue *captured, TValue arg0, TValue arg1, TValue arg2);\n\n// Ref-counted function pointer.\nclass RefAction : public RefObject {\n  public:\n    uint16_t len;\n    uint16_t reserved;\n    ActionCB func; // The function pointer\n    // fields[] contain captured locals\n    TValue fields[];\n\n    static void destroy(RefAction *act);\n    static void scan(RefAction *act);\n    static unsigned gcsize(RefAction *coll);\n    static void print(RefAction *act);\n\n    RefAction();\n\n    inline void stCore(int idx, TValue v) {\n        // DMESG(\"ST [%d] = %d \", idx, v); this->print();\n        intcheck(0 <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 10);\n        intcheck(fields[idx] == 0, PANIC_OUT_OF_BOUNDS, 11); // only one assignment permitted\n        fields[idx] = v;\n    }\n};\n\n// These two are used to represent locals written from inside inline functions\nclass RefRefLocal : public RefObject {\n  public:\n    TValue v;\n    static void destroy(RefRefLocal *l);\n    static void scan(RefRefLocal *l);\n    static unsigned gcsize(RefRefLocal *l);\n    static void print(RefRefLocal *l);\n    RefRefLocal();\n};\n\ntypedef int color;\n\n// note: this is hardcoded in PXT (hexfile.ts)\n\nclass BoxedNumber : public RefObject {\n  public:\n    NUMBER num;\n    BoxedNumber() : RefObject(&number_vt) {}\n} __attribute__((packed));\n\nclass BoxedString : public RefObject {\n  public:\n    uint16_t length;\n    char data[0];\n    BoxedString() : RefObject(&string_vt) {}\n};\n\nclass BoxedBuffer : public RefObject {\n  public:\n    // data needs to be word-aligned, so we use 32 bits for length\n    int length;\n    uint8_t data[0];\n    BoxedBuffer() : RefObject(&buffer_vt) {}\n};\n\n// the first byte of data indicates the format - currently 0xE1 or 0xE4 to 1 or 4 bit bitmaps\n// second byte indicates width in pixels\n// third byte indicates the height (which should also match the size of the buffer)\n// just like ordinary buffers, these can be layed out in flash\nclass RefImage : public RefObject {\n    uintptr_t _buffer;\n    uint8_t _data[0];\n\n  public:\n    RefImage(BoxedBuffer *buf);\n    RefImage(uint32_t sz);\n\n    bool hasBuffer() { return !(_buffer & 1); }\n    BoxedBuffer *buffer() { return hasBuffer() ? (BoxedBuffer *)_buffer : NULL; }\n    void setBuffer(BoxedBuffer *b);\n    bool isDirty() { return (_buffer & 3) == 3; }\n    void clearDirty() {\n        if (isDirty())\n            _buffer &= ~2;\n    }\n\n    uint8_t *data() { return hasBuffer() ? buffer()->data : _data; }\n    int length() { return hasBuffer() ? buffer()->length : (_buffer >> 2); }\n    int pixLength() { return length() - 4; }\n\n    int height();\n    int width();\n    int byteHeight();\n    int wordHeight();\n    int bpp();\n\n    bool hasPadding() { return (height() & 0x1f) != 0; }\n\n    uint8_t *pix() { return data() + 4; }\n    uint8_t *pix(int x, int y);\n    uint8_t fillMask(color c);\n    bool inRange(int x, int y);\n    void clamp(int *x, int *y);\n    void makeWritable();\n\n    static void destroy(RefImage *t);\n    static void scan(RefImage *t);\n    static unsigned gcsize(RefImage *t);\n    static void print(RefImage *t);\n};\n\nRefImage *mkImage(int w, int h, int bpp);\n\ntypedef BoxedBuffer *Buffer;\ntypedef BoxedString *String;\ntypedef RefImage *Image_;\n\n// keep in sync with github/pxt/pxtsim/libgeneric.ts\nenum class NumberFormat {\n    Int8LE = 1,\n    UInt8LE,\n    Int16LE,\n    UInt16LE,\n    Int32LE,\n    Int8BE,\n    UInt8BE,\n    Int16BE,\n    UInt16BE,\n    Int32BE,\n\n    UInt32LE,\n    UInt32BE,\n    Float32LE,\n    Float64LE,\n    Float32BE,\n    Float64BE,\n};\n\n// data can be NULL in both cases\nString mkString(const char *data, int len = -1);\nBuffer mkBuffer(const uint8_t *data, int len);\n\nTNumber getNumberCore(uint8_t *buf, int size, NumberFormat format);\nvoid setNumberCore(uint8_t *buf, int size, NumberFormat format, TNumber value);\n\nvoid seedRandom(unsigned seed);\n// max is inclusive\nunsigned getRandom(unsigned max);\n\nValType valType(TValue v);\n\n#ifdef PXT_GC\nvoid registerGC(TValue *root, int numwords = 1);\nvoid unregisterGC(TValue *root, int numwords = 1);\nvoid registerGCPtr(TValue ptr);\nvoid unregisterGCPtr(TValue ptr);\nvoid gc(int verbose);\n#else\ninline void registerGC(TValue *root, int numwords = 1) {}\ninline void unregisterGC(TValue *root, int numwords = 1) {}\ninline void registerGCPtr(TValue ptr) {}\ninline void unregisterGCPtr(TValue ptr) {}\ninline void gc(int) {}\n#endif\n\nstruct StackSegment {\n    void *top;\n    void *bottom;\n    StackSegment *next;\n};\n\nstruct ThreadContext {\n    TValue *globals;\n    StackSegment stack;\n    void *fiber;\n    ThreadContext *next;\n    ThreadContext *prev;\n};\n\nvoid releaseThreadContext(ThreadContext *ctx);\nThreadContext *getThreadContext();\nvoid setThreadContext(ThreadContext *ctx);\nvoid *getCurrentFiber();\nvoid *threadAddressFor(ThreadContext *ctx, void *sp);\n\n#ifndef PXT_USE_XMALLOC\n#define xmalloc malloc\n#endif\n\nvoid *gcAllocate(int numbytes);\n#ifndef PXT_GC\ninline void *gcAllocate(int numbytes) {\n    return xmalloc(numbytes);\n}\n#endif\n\nextern ThreadContext *threadContexts;\n\nenum class PerfCounters {\n    GC,\n};\n\n#ifdef PXT_PROFILE\n#ifndef PERF_NOW\n#error \"missing platform timer support\"\n#endif\n\nstruct PerfCounter {\n    uint32_t value;\n    uint32_t numstops;\n    uint32_t start;\n};\n\nextern struct PerfCounter *perfCounters;\n\nvoid initPerfCounters();\n//%\nvoid dumpPerfCounters();\n//%\nvoid startPerfCounter(PerfCounters n);\n//%\nvoid stopPerfCounter(PerfCounters n);\n#else\ninline void startPerfCounter(PerfCounters n) {}\ninline void stopPerfCounter(PerfCounters n) {}\ninline void initPerfCounters() {}\ninline void dumpPerfCounters() {}\n#endif\n\n} // namespace pxt\n\n#define PXT_DEF_STRING(name, val)                                                                  \\\n    static const char name[] __attribute__((aligned(4))) = \"@PXT@:\" val;\n\nusing namespace pxt;\n\nnamespace numops {\n//%\nString toString(TValue v);\n//%\nint toBool(TValue v);\n//%\nint toBoolDecr(TValue v);\n} // namespace numops\n\nnamespace pins {\nBuffer createBuffer(int size);\n}\n\nnamespace String_ {\n//%\nint compare(String a, String b);\n} // namespace String_\n\nnamespace Array_ {\n//%\nRefCollection *mk();\n}\n\n#define NEW_GC(T) new (gcAllocate(sizeof(T))) T()\n\n// The ARM Thumb generator in the JavaScript code is parsing\n// the hex file and looks for the magic numbers as present here.\n//\n// Then it fetches function pointer addresses from there.\n//\n// The vtable pointers are there, so that the ::emptyData for various types\n// can be patched with the right vtable.\n//\n#define PXT_SHIMS_BEGIN                                                                            \\\n    namespace pxt {                                                                                \\\n    const unsigned functionsAndBytecode[]                                                          \\\n        __attribute__((aligned(0x20))) = {0x08010801, 0x42424242, 0x08010801, 0x8de9d83e,\n\n#define PXT_SHIMS_END                                                                              \\\n    }                                                                                              \\\n    ;                                                                                              \\\n    }\n\n#ifndef X86_64\n#pragma GCC diagnostic ignored \"-Wpmf-conversions\"\n#endif\n\n#define DEF_VTABLE(name, tp, valtype, ...)                                                         \\\n    const VTable name __attribute__((aligned(1 << PXT_VTABLE_SHIFT))) = {                          \\\n        0, valtype, VTABLE_MAGIC, 0, BuiltInType::tp, 0, 0, {__VA_ARGS__}};\n\n#ifdef PXT_GC\n#define PXT_VTABLE(classname)                                                                      \\\n    DEF_VTABLE(classname##_vtable, classname, ValType::Object, (void *)&classname::destroy,        \\\n               (void *)&classname::print, (void *)&classname::scan, (void *)&classname::gcsize)\n#else\n#define PXT_VTABLE(classname)                                                                      \\\n    DEF_VTABLE(classname##_vtable, classname, ValType::Object, (void *)&classname::destroy,        \\\n               (void *)&classname::print)\n#endif\n\n#define PXT_VTABLE_INIT(classname) RefObject(&classname##_vtable)\n\n#define PXT_VTABLE_CTOR(classname)                                                                 \\\n    PXT_VTABLE(classname)                                                                          \\\n    classname::classname() : PXT_VTABLE_INIT(classname)\n\n#define PXT_MAIN                                                                                   \\\n    int main() {                                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#define PXT_FNPTR(x) (unsigned)(void *)(x)\n\n#define PXT_ABI(...)\n\n#define JOIN(a, b) a##b\n/// Defines getClassName() function to fetch the singleton\n#define SINGLETON(ClassName)                                                                       \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName))                                                                \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n#endif\n",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n\n    //% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\ndeclare interface Buffer {\n    /**\n     * Write a number in specified format in the buffer.\n     */\n    //% shim=BufferMethods::setNumber\n    setNumber(format: NumberFormat, offset: int32, value: number): void;\n\n    /**\n     * Read a number in specified format from the buffer.\n     */\n    //% shim=BufferMethods::getNumber\n    getNumber(format: NumberFormat, offset: int32): number;\n\n    /** Returns the length of a Buffer object. */\n    //% property shim=BufferMethods::length\n    length: int32;\n\n    /**\n     * Fill (a fragment) of the buffer with given value.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::fill\n    fill(value: int32, offset?: int32, length?: int32): void;\n\n    /**\n     * Return a copy of a fragment of a buffer.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::slice\n    slice(offset?: int32, length?: int32): Buffer;\n\n    /**\n     * Shift buffer left in place, with zero padding.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::shift\n    shift(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Convert a buffer to its hexadecimal representation.\n     */\n    //% shim=BufferMethods::toHex\n    toHex(): string;\n\n    /**\n     * Rotate buffer left in place.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::rotate\n    rotate(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Write contents of `src` at `dstOffset` in current buffer.\n     */\n    //% shim=BufferMethods::write\n    write(dstOffset: int32, src: Buffer): void;\n}\ndeclare namespace control {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=control::createBuffer\n    function createBuffer(size: int32): Buffer;\n}\ndeclare namespace loops {\n\n    /**\n     * Repeats the code forever in the background. On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    //% help=loops/forever weight=100 afterOnStart=true deprecated=true\n    //% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1 shim=loops::forever\n    function forever(a: () => void): void;\n\n    /**\n     * Pause for the specified time in milliseconds\n     * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n     */\n    //% help=loops/pause weight=99 deprecated=true\n    //% async block=\"pause %pause=timePicker|ms\"\n    //% blockId=device_pause_deprecated shim=loops::pause\n    function pause(ms: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Gets the number of milliseconds elapsed since power on.\n     */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\" shim=control::millis\n    function millis(): int32;\n\n    /**\n     * Used internally\n     */\n    //% flags.defl=16 shim=control::internalOnEvent\n    function internalOnEvent(src: int32, value: int32, handler: () => void, flags?: int32): void;\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\" shim=control::reset\n    function reset(): void;\n\n    /**\n     * Block the current fiber for the given microseconds\n     * @param micros number of micro-seconds to wait. eg: 4\n     */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (µs)%micros\" shim=control::waitMicros\n    function waitMicros(micros: int32): void;\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8 shim=control::runInParallel\n    function runInParallel(a: () => void): void;\n\n    /**\n     * Blocks the calling thread until the specified event is raised.\n     */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\" shim=control::waitForEvent\n    function waitForEvent(src: int32, value: int32): void;\n\n    /**\n     * Derive a unique, consistent serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number shim=control::deviceSerialNumber\n    function deviceSerialNumber(): int32;\n\n    /**\n     *\n     */\n    //% shim=control::__log\n    function __log(text: string): void;\n\n    /**\n     * Dump internal information about a value.\n     */\n    //% shim=control::dmesgValue\n    function dmesgValue(v: any): void;\n\n    /**\n     * Force GC and dump information about heap.\n     */\n    //% shim=control::gc\n    function gc(): void;\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //% shim=control::profilingEnabled\n    function profilingEnabled(): boolean;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nforever(() => {\n    pause(100)\n})\n"
    },
    "core": {
      "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
      "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nCODAL_TIMER devTimer;\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile unsigned hp = (unsigned)p;\n        if (hp & 4) {\n            free(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            free(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        free(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    if (curr)\n        runAction1(curr->action, value);\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        runAction1(curr->action, value);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n#endif\n\nvoid *getCurrentFiber() {\n    return currentFiber;\n}\n\nvoid *threadAddressFor(ThreadContext *ctx, void *sp) {\n    auto fib = (codal::Fiber *)ctx->fiber;\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\n} // namespace pxt\n",
      "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->data);\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->data, ptr);\n}\n\n\n}\n",
      "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_JD_FLAGS_LOSSY = 1,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDClasses.h\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_ARCADE = 1,\n    JD_DRIVER_CLASS_JOYSTICK = 2,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 3,\n    JD_DRIVER_CLASS_RADIO = 4,\n    JD_DRIVER_CLASS_BRIDGE = 5,\n    JD_DRIVER_CLASS_BUTTON = 6,\n    JD_DRIVER_CLASS_PIN = 7,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 1,\n    JD_DRIVER_EVT_DISCONNECTED = 2,\n    JD_DRIVER_EVT_PAIRED = 3,\n    JD_DRIVER_EVT_UNPAIRED = 4,\n    JD_DRIVER_EVT_PAIR_REJECTED = 5,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 6,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_FLAGS_BROADCAST_MAP = 16,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDRadioDriver.h\n    JD_RADIO_HISTORY_SIZE = 4,\n    JD_RADIO_MAXIMUM_BUFFERS = 10,\n    JD_RADIO_HEADER_SIZE = 4,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/dockercodal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/dockercodal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/dockercodal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/dockercodal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/dockercodal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/dockercodal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/dockercodal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/dockercodal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/dockercodal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/dockercodal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/dockercodal/pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/dockercodal/pxtapp/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACDAC = 60,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/dockercodal/pxtapp/platform.h\n    PXT_BOOTLOADER_CFG_ADDR = 134234056,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    // built/dockercodal/pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/dockercodal/pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // built/dockercodal/pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    // built/dockercodal/pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
      "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
      "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nclass WDMAC {\n  public:\n    PlatformDMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "hf2.cpp": "#define UF2_DEFINE_HANDOVER 1\n#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfo = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n    return DEVICE_NOT_SUPPORTED;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo()\n{\n    return &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError)\n{\n    if (!gotSomePacket) return DEVICE_OK;\n    return send(data, size, isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT);\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len = out->read(buf, sizeof(buf));\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\n// Send HF2 message.\n// Use command message when flag == HF2_FLAG_CMDPKT_LAST\n// Use serial stdout for HF2_FLAG_SERIAL_OUT and stderr for HF2_FLAG_SERIAL_ERR.\nint HF2::send(const void *data, int size, int flag0) {\n    uint8_t buf[64];\n    const uint8_t *ptr = (const uint8_t *)data;\n\n    if (!CodalUSB::usbInstance->isInitialised())\n        return -1;\n\n    for (;;) {\n        int s = 63;\n        int flag = flag0;\n        if (size <= 63) {\n            s = size;\n        } else {\n            if (flag == HF2_FLAG_CMDPKT_LAST)\n                flag = HF2_FLAG_CMDPKT_BODY;\n        }\n        buf[0] = flag | s;\n        memcpy(buf + 1, ptr, s);\n        if (in->write(buf, sizeof(buf)) < 0)\n            return -1;\n        ptr += s;\n        size -= s;\n        if (!size)\n            break;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    return send(pkt.buf, 4 + size, HF2_FLAG_CMDPKT_LAST);\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    int res;\n\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        __disable_irq();\n        memcpy(pkt.resp.data8, data, size);\n        __enable_irq();\n        res = sendResponse(size);\n    } else {\n        __disable_irq();\n        send(pkt.buf, 4, HF2_FLAG_CMDPKT_BODY);\n        res = send(data, size, HF2_FLAG_CMDPKT_LAST);\n        __enable_irq();\n    }\n\n    return res;\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n\nint HF2::endpointRequest()\n{\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        *DBL_TAP_PTR = DBL_TAP_MAGIC_QUICK_BOOT;\n        // fall-through\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        target_reset();\n        break;\n\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : USBHID(), pkt(p), gotSomePacket(false) {}\n\n//\n//\n// WebUSB\n//\n//\n\nWebHF2::WebHF2(HF2_Buffer &p) : HF2(p) {}\n\nstatic const InterfaceInfo ifaceInfoWeb = {\n    NULL,\n    0,\n    1,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - HID\n        42, // subclass\n        0x01, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nconst InterfaceInfo *WebHF2::getInterfaceInfo()\n{\n    return &ifaceInfoWeb;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n    \n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        webhf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        webhf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        free(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            free(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
      "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct\n{\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public codal::USBHID\n{\npublic:\n    HF2_Buffer &pkt;\n    bool gotSomePacket;\n\n    int sendResponse(int size);\n    int send(const void *data, int size, int flag);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup& setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n};\n\nclass WebHF2 : public HF2\n{\npublic:\n    WebHF2(HF2_Buffer &pkt);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    virtual bool enableWebUSB() { return true; }\n};\n\n#endif\n\n#endif\n",
      "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
      "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::I2C *i2c;\n\n    static void initI2C() {\n      if (NULL == i2c) {\n        i2c = new CODAL_I2C(*LOOKUP_PIN(SDA), *LOOKUP_PIN(SCL));\n      }\n    }\n\n      /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    Buffer i2cReadBuffer(int address, int size, bool repeat = false)\n    {\n      initI2C();\n      Buffer buf = createBuffer(size);\n      int status = i2c->read(address << 1, buf->data, size, repeat);\n      if (status != ErrorCode::DEVICE_OK) {\n        decrRC(buf);\n        buf = 0;\n      }\n      return buf;\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    int i2cWriteBuffer(int address, Buffer buf, bool repeat = false)\n    {\n      initI2C();\n      return i2c->write(address << 1, buf->data, buf->length, repeat);\n    }\n}",
      "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        let buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format: NumberFormat, repeated?: boolean): void {\n        let buf = createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}",
      "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}",
      "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n    if (id < 0 || id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0)\n        return NULL;\n    return getPin(pinName);\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
      "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n#define CFG_PIN_JACDAC 60\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_I2C\n#define CODAL_I2C CODAL_MBED::I2C\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
      "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n\n}",
      "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
      "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
      "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
      "pinscompat.ts": "// this type alias is required for backward compatibility\n// it gets overriden in microbit (DigitalPin is an enum over there)\ntype DigitalPin = DigitalInOutPin;\ntype AnalogPin = AnalogInOutPin;",
      "platform.cpp": "#include \"pxt.h\"\n#include \"neopixel.h\"\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    auto pinTemp = LOOKUP_PIN(TEMPERATURE);\n    if (pinTemp)\n        seed *= pinTemp->getAnalogValue();\n    auto pinLight = LOOKUP_PIN(LIGHT);\n    if (pinLight)\n        seed *= pinLight->getAnalogValue();\n    seedRandom(seed);\n}\n\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n}\n\nstatic void clearNeoPixels() {\n    // clear on-board neopixels\n    auto neoPin = LOOKUP_PIN(NEOPIXEL);\n    if (neoPin) {\n        int numNeopixels = getConfig(CFG_NUM_NEOPIXELS, 0);\n        int size = numNeopixels * 3;\n        if (size) {\n            uint8_t neobuf[size];\n            memset(neobuf, 0, size);\n            neoPin->setDigitalValue(0);\n            fiber_sleep(1);\n            neopixel_send_buffer(*neoPin, neobuf, 30);\n        }\n    }\n}\n\nvoid platform_init() {\n    initSwdPins();\n    initRandomSeed();\n    clearNeoPixels();\n\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n}\n\n}\n",
      "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n// This is specific for SAMD21, to be replaced in other Codal targets.\n\n#include \"CapTouchButton.h\"\n#include \"Image.h\"\n#include \"MbedTimer.h\"\n#include \"MbedI2C.h\"\n#include \"MbedPin.h\"\n#include \"MbedSPI.h\"\n#include \"MbedSerial.h\"\n#include \"MultiButton.h\"\n#include \"CPlayI2C.h\"\n\n#include \"SAMD21DMAC.h\"\n\n// Analog Pins, all SAMD21: PA02-PA11 PB00-PB09 (some pins not connected)\n// 2 ports times 32 pins in each\n#define DEV_NUM_PINS 64\n// pins marked with AIN and PTC in the data sheet\n#define DEV_ANALOG_PINS 0x3ff00000ffcULL\n\n#define PAGE_SIZE 256\n\n#define PlatformDMAC SAMD21DMAC\n\n// this is codal::_mbed for both mbed and mbedos now\n#define CODAL_MBED codal::_mbed\n\n#define CODAL_I2C codal::CPlayI2C\n\n/*\n * @param nominalValue The value (in SI units) of a nominal position.\n * @param nominalReading The raw reading from the sensor at the nominal position.\n * @param beta The Steinhart-Hart Beta constant for the device\n * @param seriesResistor The value (in ohms) of the resistor in series with the sensor.\n * @param zeroOffset Optional zero offset applied to all SI units (e.g. 273.15 for temperature\n * sensing in C vs Kelvin).\n */\n\n#define TEMPERATURE_NOMINAL_VALUE 25\n#define TEMPERATURE_NOMINAL_READING 10000\n#define TEMPERATURE_BETA 3380\n#define TEMPERATURE_SERIES_RESISTOR 10000\n#define TEMPERATURE_ZERO_OFFSET 273.5\n\n#define LIGHTSENSOR_SENSITIVITY 868 // codal has 912 now\n#define LIGHTSENSOR_LOW_THRESHOLD 128\n#define LIGHTSENSOR_HIGH_THRESHOLD 896\n\n#ifndef IMAGE_BITS\n#define IMAGE_BITS 1\n#endif\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#endif\n\n#endif\n",
      "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\nextern WebHF2 webhf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n} // namespace pxt\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
      "pxt.json": "{\n    \"name\": \"core\",\n    \"description\": \"The core library for Codal-based targets\",\n    \"files\": [\n        \"README.md\",\n        \"dal.d.ts\",\n        \"codal.cpp\",\n        \"usb.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"pins.cpp\",\n        \"pinsAnalog.cpp\",\n        \"pinsDigital.cpp\",\n        \"pinsPWM.cpp\",\n        \"pins.ts\",\n        \"pinscompat.ts\",\n        \"control.cpp\",\n        \"i2c.cpp\",\n        \"i2c.ts\",\n        \"spi.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"hf2.cpp\",\n        \"hf2.h\",\n        \"hf2dbg.h\",\n        \"uf2format.h\",\n        \"uf2hid.h\",\n        \"ns.ts\",\n        \"dmac.cpp\",\n        \"dmac.h\",\n        \"timer.ts\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024,\n                \"tag\": 1\n            }\n        }\n    },\n    \"public\": true,\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\"\n        ]\n    },\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#endif\n",
      "pxtparts.json": "{\n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace pins {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\ndeclare namespace pins {\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cReadBuffer\n    function i2cReadBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cWriteBuffer\n    function i2cWriteBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\" shim=pins::spiWrite\n    function spiWrite(value: int32): int32;\n\n    /**\n     * Writes a given command to SPI bus, and afterwards reads the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\" shim=pins::spiTransfer\n    function spiTransfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\" shim=pins::spiFrequency\n    function spiFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI mode and bits\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\" shim=pins::spiMode\n    function spiMode(mode: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::SPI *spi = NULL;\n    static void initSPI() {\n        if (NULL == spi)\n            spi = new CODAL_SPI(*LOOKUP_PIN(MOSI), *LOOKUP_PIN(MISO), *LOOKUP_PIN(SCK));\n    }\n\n    /**\n    * Write to the SPI slave and return the response\n    * @param value Data to be sent to the SPI slave\n    */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    int spiWrite(int value) {\n        initSPI();\n        return spi->write(value);\n    }\n\n    /**\n    * Writes a given command to SPI bus, and afterwards reads the response.\n    */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    void spiTransfer(Buffer command, Buffer response) {\n        initSPI();\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi->transfer(cdata, clength, rdata, rlength);\n    }\n\n    /**\n    * Sets the SPI frequency\n    * @param frequency the clock frequency, eg: 1000000\n    */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    void spiFrequency(int frequency) {\n        initSPI();\n        spi->setFrequency(frequency);\n    }\n\n    /**\n    * Sets the SPI mode and bits\n    * @param mode the mode, eg: 3\n    */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    void spiMode(int mode) {\n        initSPI();\n        spi->setMode(mode);        \n    }\n}\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nforever(() => {\n    pause(100)\n})\n",
      "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
      "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n// if you increase that, you will also need to update the linker script file\n#define APP_START_ADDRESS 0x00002000\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\n#define UF2_BINFO ((UF2_BInfo *)(APP_START_ADDRESS - sizeof(UF2_BInfo)))\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return 0xb4 <= (uint32_t)addr && (uint32_t)addr < APP_START_ADDRESS;\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_BINFO->info_uf2))\n        return UF2_BINFO->info_uf2;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
      "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
      "usb.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\nWebHF2 webhf2(hf2buf);\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,            // bLength\n    0x01,            // bDescriptorType\n    0x0210,          // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40,            // bMaxPacketSize0\n    0x03EB, // Atmel\n    0x2402, // Example device\n    0x4202,          // bcdDevice - leave unchanged for the HF2 to work\n    0x01,            // iManufacturer\n    0x02,            // iProduct\n    0x03,            // SerialNumber\n    0x01             // bNumConfigs\n};\n\n// TODO extract these from uf2_info()?\nstatic const char *string_descriptors[] = {\n    \"Example Corp.\",\n    \"PXT Device\",\n    \"42424242\",\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid usb_init() {\n    usb.stringDescriptors = string_descriptors;\n    usb.deviceDescriptor = &device_desc;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n    usb.add(hf2);\n    usb.add(webhf2);\n    create_fiber(start_usb);\n}\n\n\n#else\nvoid usb_init() {}\n#endif\n\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n    webhf2.sendSerial(data, len);\n#endif    \n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n}\n"
    },
    "core---samd51": {
      "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
      "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nCODAL_TIMER devTimer;\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile unsigned hp = (unsigned)p;\n        if (hp & 4) {\n            free(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            free(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        free(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    if (curr)\n        runAction1(curr->action, value);\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        runAction1(curr->action, value);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n#endif\n\nvoid *getCurrentFiber() {\n    return currentFiber;\n}\n\nvoid *threadAddressFor(ThreadContext *ctx, void *sp) {\n    auto fib = (codal::Fiber *)ctx->fiber;\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\n} // namespace pxt\n",
      "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->data);\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->data, ptr);\n}\n\n\n}\n",
      "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_JD_FLAGS_LOSSY = 1,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDClasses.h\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_ARCADE = 1,\n    JD_DRIVER_CLASS_JOYSTICK = 2,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 3,\n    JD_DRIVER_CLASS_RADIO = 4,\n    JD_DRIVER_CLASS_BRIDGE = 5,\n    JD_DRIVER_CLASS_BUTTON = 6,\n    JD_DRIVER_CLASS_PIN = 7,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 1,\n    JD_DRIVER_EVT_DISCONNECTED = 2,\n    JD_DRIVER_EVT_PAIRED = 3,\n    JD_DRIVER_EVT_UNPAIRED = 4,\n    JD_DRIVER_EVT_PAIR_REJECTED = 5,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 6,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_FLAGS_BROADCAST_MAP = 16,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDRadioDriver.h\n    JD_RADIO_HISTORY_SIZE = 4,\n    JD_RADIO_MAXIMUM_BUFFERS = 10,\n    JD_RADIO_HEADER_SIZE = 4,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/dockercodal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/dockercodal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/dockercodal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/dockercodal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/dockercodal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/dockercodal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/dockercodal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/dockercodal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/dockercodal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/dockercodal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/dockercodal/pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/dockercodal/pxtapp/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACDAC = 60,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/dockercodal/pxtapp/platform.h\n    PAGE_SIZE = 512,\n    DEV_NUM_PINS = 64,\n    PXT_BOOTLOADER_CFG_MAGIC = 3191854542,\n    IMAGE_BITS = 4,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // built/dockercodal/pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/dockercodal/pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // built/dockercodal/pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    // built/dockercodal/pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
      "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
      "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nclass WDMAC {\n  public:\n    PlatformDMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "hf2.cpp": "#define UF2_DEFINE_HANDOVER 1\n#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfo = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n    return DEVICE_NOT_SUPPORTED;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo()\n{\n    return &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError)\n{\n    if (!gotSomePacket) return DEVICE_OK;\n    return send(data, size, isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT);\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len = out->read(buf, sizeof(buf));\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\n// Send HF2 message.\n// Use command message when flag == HF2_FLAG_CMDPKT_LAST\n// Use serial stdout for HF2_FLAG_SERIAL_OUT and stderr for HF2_FLAG_SERIAL_ERR.\nint HF2::send(const void *data, int size, int flag0) {\n    uint8_t buf[64];\n    const uint8_t *ptr = (const uint8_t *)data;\n\n    if (!CodalUSB::usbInstance->isInitialised())\n        return -1;\n\n    for (;;) {\n        int s = 63;\n        int flag = flag0;\n        if (size <= 63) {\n            s = size;\n        } else {\n            if (flag == HF2_FLAG_CMDPKT_LAST)\n                flag = HF2_FLAG_CMDPKT_BODY;\n        }\n        buf[0] = flag | s;\n        memcpy(buf + 1, ptr, s);\n        if (in->write(buf, sizeof(buf)) < 0)\n            return -1;\n        ptr += s;\n        size -= s;\n        if (!size)\n            break;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    return send(pkt.buf, 4 + size, HF2_FLAG_CMDPKT_LAST);\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    int res;\n\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        __disable_irq();\n        memcpy(pkt.resp.data8, data, size);\n        __enable_irq();\n        res = sendResponse(size);\n    } else {\n        __disable_irq();\n        send(pkt.buf, 4, HF2_FLAG_CMDPKT_BODY);\n        res = send(data, size, HF2_FLAG_CMDPKT_LAST);\n        __enable_irq();\n    }\n\n    return res;\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n\nint HF2::endpointRequest()\n{\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        *DBL_TAP_PTR = DBL_TAP_MAGIC_QUICK_BOOT;\n        // fall-through\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        target_reset();\n        break;\n\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : USBHID(), pkt(p), gotSomePacket(false) {}\n\n//\n//\n// WebUSB\n//\n//\n\nWebHF2::WebHF2(HF2_Buffer &p) : HF2(p) {}\n\nstatic const InterfaceInfo ifaceInfoWeb = {\n    NULL,\n    0,\n    1,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - HID\n        42, // subclass\n        0x01, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nconst InterfaceInfo *WebHF2::getInterfaceInfo()\n{\n    return &ifaceInfoWeb;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n    \n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        webhf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        webhf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        free(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            free(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
      "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct\n{\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public codal::USBHID\n{\npublic:\n    HF2_Buffer &pkt;\n    bool gotSomePacket;\n\n    int sendResponse(int size);\n    int send(const void *data, int size, int flag);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup& setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n};\n\nclass WebHF2 : public HF2\n{\npublic:\n    WebHF2(HF2_Buffer &pkt);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    virtual bool enableWebUSB() { return true; }\n};\n\n#endif\n\n#endif\n",
      "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
      "i2c.cpp": "",
      "i2c.ts": "// TS does not like empty files\n",
      "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}",
      "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n    if (id < 0 || id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0)\n        return NULL;\n    return getPin(pinName);\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
      "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n#define CFG_PIN_JACDAC 60\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_I2C\n#define CODAL_I2C CODAL_MBED::I2C\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
      "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n\n}",
      "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
      "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
      "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
      "pinscompat.ts": "// this type alias is required for backward compatibility\n// it gets overriden in microbit (DigitalPin is an enum over there)\ntype DigitalPin = DigitalInOutPin;\ntype AnalogPin = AnalogInOutPin;",
      "platform.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    // TODO use TRNG\n    seedRandom(seed);\n}\n\nvoid platformSendSerial(const char *data, int len) {\n}\n\nvoid platform_init() {\n    initRandomSeed();\n    setSendToUART(platformSendSerial);\n\n/*\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n*/\n}\n\n}\n\nvoid cpu_clock_init() {\n    devTimer.init();\n}\n",
      "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#include \"Image.h\"\n#include \"MultiButton.h\"\n#include \"ZPin.h\"\n#include \"ZTimer.h\"\n#include \"ZSPI.h\"\n//#include \"ZI2C.h\"\n#include \"ZSingleWireSerial.h\"\n\n#include \"pinmap.h\"\n\n#undef min\n#undef max\n\ntypedef uint8_t PinName;\n\n// #define PXT_BOOTLOADER_CFG_ADDR 0x8003fc8\n\n#define PAGE_SIZE 512\n\n// if we ever want to support 100+ pin packages, need to add PC,PD ports and increase this to 128\n#define DEV_NUM_PINS 64\n\n#define IS_ANALOG_PIN(id) 1\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER ZTimer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n#define CODAL_JACDAC_WIRE_SERIAL codal::ZSingleWireSerial\n#define CODAL_JACDAC_SUPER_UGLY_CTOR 1\n\n#define PXT_BOOTLOADER_CFG_ADDR (0x4000 - 4*4)\n#define PXT_BOOTLOADER_CFG_MAGIC 0xbe3fd5ce\n\n#define IMAGE_BITS 4\n\n// The parameters below needs tuning!\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#endif\n\n#endif",
      "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\nextern WebHF2 webhf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n} // namespace pxt\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
      "pxt.json": "{\n    \"name\": \"core---samd51\",\n    \"description\": \"The core library for Codal-based targets\",\n    \"files\": [\n        \"README.md\",\n        \"dal.d.ts\",\n        \"codal.cpp\",\n        \"usb.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"pins.cpp\",\n        \"pinsAnalog.cpp\",\n        \"pinsDigital.cpp\",\n        \"pinsPWM.cpp\",\n        \"pins.ts\",\n        \"pinscompat.ts\",\n        \"control.cpp\",\n        \"i2c.cpp\",\n        \"i2c.ts\",\n        \"spi.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"hf2.cpp\",\n        \"hf2.h\",\n        \"hf2dbg.h\",\n        \"uf2format.h\",\n        \"uf2hid.h\",\n        \"ns.ts\",\n        \"dmac.cpp\",\n        \"dmac.h\",\n        \"timer.ts\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024,\n                \"tag\": 1\n            }\n        }\n    },\n    \"public\": true,\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\"\n        ]\n    },\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#endif\n",
      "pxtparts.json": "{\n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace pins {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\ndeclare namespace pins {\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\" shim=pins::spiWrite\n    function spiWrite(value: int32): int32;\n\n    /**\n     * Writes a given command to SPI bus, and afterwards reads the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\" shim=pins::spiTransfer\n    function spiTransfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\" shim=pins::spiFrequency\n    function spiFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI mode and bits\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\" shim=pins::spiMode\n    function spiMode(mode: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::SPI *spi = NULL;\n    static void initSPI() {\n        if (NULL == spi)\n            spi = new CODAL_SPI(*LOOKUP_PIN(MOSI), *LOOKUP_PIN(MISO), *LOOKUP_PIN(SCK));\n    }\n\n    /**\n    * Write to the SPI slave and return the response\n    * @param value Data to be sent to the SPI slave\n    */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    int spiWrite(int value) {\n        initSPI();\n        return spi->write(value);\n    }\n\n    /**\n    * Writes a given command to SPI bus, and afterwards reads the response.\n    */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    void spiTransfer(Buffer command, Buffer response) {\n        initSPI();\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi->transfer(cdata, clength, rdata, rlength);\n    }\n\n    /**\n    * Sets the SPI frequency\n    * @param frequency the clock frequency, eg: 1000000\n    */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    void spiFrequency(int frequency) {\n        initSPI();\n        spi->setFrequency(frequency);\n    }\n\n    /**\n    * Sets the SPI mode and bits\n    * @param mode the mode, eg: 3\n    */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    void spiMode(int mode) {\n        initSPI();\n        spi->setMode(mode);        \n    }\n}\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nforever(() => {\n    pause(100)\n})\n",
      "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
      "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n// if you increase that, you will also need to update the linker script file\n#define APP_START_ADDRESS 0x00002000\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\n#define UF2_BINFO ((UF2_BInfo *)(APP_START_ADDRESS - sizeof(UF2_BInfo)))\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return 0xb4 <= (uint32_t)addr && (uint32_t)addr < APP_START_ADDRESS;\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_BINFO->info_uf2))\n        return UF2_BINFO->info_uf2;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
      "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
      "usb.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\nWebHF2 webhf2(hf2buf);\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,            // bLength\n    0x01,            // bDescriptorType\n    0x0210,          // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40,            // bMaxPacketSize0\n    0x03EB, // Atmel\n    0x2402, // Example device\n    0x4202,          // bcdDevice - leave unchanged for the HF2 to work\n    0x01,            // iManufacturer\n    0x02,            // iProduct\n    0x03,            // SerialNumber\n    0x01             // bNumConfigs\n};\n\n// TODO extract these from uf2_info()?\nstatic const char *string_descriptors[] = {\n    \"Example Corp.\",\n    \"PXT Device\",\n    \"42424242\",\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid usb_init() {\n    usb.stringDescriptors = string_descriptors;\n    usb.deviceDescriptor = &device_desc;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n    usb.add(hf2);\n    usb.add(webhf2);\n    create_fiber(start_usb);\n}\n\n\n#else\nvoid usb_init() {}\n#endif\n\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n    webhf2.sendSerial(data, len);\n#endif    \n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n}\n"
    },
    "core---stm32f401re": {
      "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
      "codal.cpp": "#include \"pxt.h\"\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#define PXT_COMM_BASE 0x20001000 // 4k in\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nCODAL_TIMER devTimer;\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    FreeList *head = NULL;\n    void *commBase = (void *)PXT_COMM_BASE;\n    for (;;) {\n        void *p = xmalloc(4);\n        // assume 4 byte alloc header; if we're not hitting 8 byte alignment, try allocating 8\n        // bytes, not 4 without the volatile, gcc assumes 8 byte alignment on malloc()\n        volatile unsigned hp = (unsigned)p;\n        if (hp & 4) {\n            free(p);\n            p = xmalloc(8);\n        }\n        if (p == commBase) {\n            free(p);\n            // allocate the comm section; this is never freed\n            p = xmalloc(commSize);\n            if (p != commBase)\n                oops(10);\n            break;\n        }\n        if (p > commBase)\n            oops(11);\n        auto f = (FreeList *)p;\n        f->next = head;\n        head = f;\n    }\n    // free all the filler stuff\n    while (head) {\n        auto p = head;\n        head = head->next;\n        free(p);\n    }\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    if (curr)\n        runAction1(curr->action, value);\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        runAction1(curr->action, value);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        incr(a);\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\n#ifdef PXT_GC\nThreadContext *getThreadContext() {\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n#endif\n\nvoid *getCurrentFiber() {\n    return currentFiber;\n}\n\nvoid *threadAddressFor(ThreadContext *ctx, void *sp) {\n    auto fib = (codal::Fiber *)ctx->fiber;\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\n} // namespace pxt\n",
      "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->data);\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->data, ptr);\n}\n\n\n}\n",
      "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_JD_FLAGS_LOSSY = 1,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDClasses.h\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_ARCADE = 1,\n    JD_DRIVER_CLASS_JOYSTICK = 2,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 3,\n    JD_DRIVER_CLASS_RADIO = 4,\n    JD_DRIVER_CLASS_BRIDGE = 5,\n    JD_DRIVER_CLASS_BUTTON = 6,\n    JD_DRIVER_CLASS_PIN = 7,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 8,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 1,\n    JD_DRIVER_EVT_DISCONNECTED = 2,\n    JD_DRIVER_EVT_PAIRED = 3,\n    JD_DRIVER_EVT_UNPAIRED = 4,\n    JD_DRIVER_EVT_PAIR_REJECTED = 5,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 6,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_FLAGS_BROADCAST_MAP = 16,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDRadioDriver.h\n    JD_RADIO_HISTORY_SIZE = 4,\n    JD_RADIO_MAXIMUM_BUFFERS = 10,\n    JD_RADIO_HEADER_SIZE = 4,\n    // built/dockercodal/libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/dockercodal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/dockercodal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/dockercodal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // built/dockercodal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/dockercodal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/dockercodal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/dockercodal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // built/dockercodal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/dockercodal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/dockercodal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/dockercodal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/dockercodal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/dockercodal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/dockercodal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/dockercodal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/dockercodal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/dockercodal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/dockercodal/pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/dockercodal/pxtapp/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACDAC = 60,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/dockercodal/pxtapp/platform.h\n    PXT_BOOTLOADER_CFG_ADDR = 134234056,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    // built/dockercodal/pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/dockercodal/pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // built/dockercodal/pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    // built/dockercodal/pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
      "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
      "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef PlatformDMAC\nclass WDMAC {\n  public:\n    PlatformDMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "hf2.cpp": "#define UF2_DEFINE_HANDOVER 1\n#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfo = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n    return DEVICE_NOT_SUPPORTED;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo()\n{\n    return &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError)\n{\n    if (!gotSomePacket) return DEVICE_OK;\n    return send(data, size, isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT);\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len = out->read(buf, sizeof(buf));\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\n// Send HF2 message.\n// Use command message when flag == HF2_FLAG_CMDPKT_LAST\n// Use serial stdout for HF2_FLAG_SERIAL_OUT and stderr for HF2_FLAG_SERIAL_ERR.\nint HF2::send(const void *data, int size, int flag0) {\n    uint8_t buf[64];\n    const uint8_t *ptr = (const uint8_t *)data;\n\n    if (!CodalUSB::usbInstance->isInitialised())\n        return -1;\n\n    for (;;) {\n        int s = 63;\n        int flag = flag0;\n        if (size <= 63) {\n            s = size;\n        } else {\n            if (flag == HF2_FLAG_CMDPKT_LAST)\n                flag = HF2_FLAG_CMDPKT_BODY;\n        }\n        buf[0] = flag | s;\n        memcpy(buf + 1, ptr, s);\n        if (in->write(buf, sizeof(buf)) < 0)\n            return -1;\n        ptr += s;\n        size -= s;\n        if (!size)\n            break;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    return send(pkt.buf, 4 + size, HF2_FLAG_CMDPKT_LAST);\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    int res;\n\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        __disable_irq();\n        memcpy(pkt.resp.data8, data, size);\n        __enable_irq();\n        res = sendResponse(size);\n    } else {\n        __disable_irq();\n        send(pkt.buf, 4, HF2_FLAG_CMDPKT_BODY);\n        res = send(data, size, HF2_FLAG_CMDPKT_LAST);\n        __enable_irq();\n    }\n\n    return res;\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n\nint HF2::endpointRequest()\n{\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        *DBL_TAP_PTR = DBL_TAP_MAGIC_QUICK_BOOT;\n        // fall-through\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        target_reset();\n        break;\n\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : USBHID(), pkt(p), gotSomePacket(false) {}\n\n//\n//\n// WebUSB\n//\n//\n\nWebHF2::WebHF2(HF2_Buffer &p) : HF2(p) {}\n\nstatic const InterfaceInfo ifaceInfoWeb = {\n    NULL,\n    0,\n    1,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - HID\n        42, // subclass\n        0x01, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nconst InterfaceInfo *WebHF2::getInterfaceInfo()\n{\n    return &ifaceInfoWeb;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n    \n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        webhf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        webhf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        free(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            free(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
      "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct\n{\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public codal::USBHID\n{\npublic:\n    HF2_Buffer &pkt;\n    bool gotSomePacket;\n\n    int sendResponse(int size);\n    int send(const void *data, int size, int flag);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup& setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n};\n\nclass WebHF2 : public HF2\n{\npublic:\n    WebHF2(HF2_Buffer &pkt);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    virtual bool enableWebUSB() { return true; }\n};\n\n#endif\n\n#endif\n",
      "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
      "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::I2C *i2c;\n\n    static void initI2C() {\n      if (NULL == i2c) {\n        i2c = new CODAL_I2C(*LOOKUP_PIN(SDA), *LOOKUP_PIN(SCL));\n      }\n    }\n\n      /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    Buffer i2cReadBuffer(int address, int size, bool repeat = false)\n    {\n      initI2C();\n      Buffer buf = createBuffer(size);\n      int status = i2c->read(address << 1, buf->data, size, repeat);\n      if (status != ErrorCode::DEVICE_OK) {\n        decrRC(buf);\n        buf = 0;\n      }\n      return buf;\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    int i2cWriteBuffer(int address, Buffer buf, bool repeat = false)\n    {\n      initI2C();\n      return i2c->write(address << 1, buf->data, buf->length, repeat);\n    }\n}",
      "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        let buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format: NumberFormat, repeated?: boolean): void {\n        let buf = createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}",
      "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}",
      "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n    if (id < 0 || id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    return getPin(getConfig(key));\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0)\n        return NULL;\n    return getPin(pinName);\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
      "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n#define CFG_PIN_JACDAC 60\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_I2C\n#define CODAL_I2C CODAL_MBED::I2C\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
      "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n\n}",
      "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% parts=\"photocell\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% parts=\"analogled\" trackArgs=0\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
      "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% parts=\"slideswitch\" trackArgs=0\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
      "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
      "pinscompat.ts": "// this type alias is required for backward compatibility\n// it gets overriden in microbit (DigitalPin is an enum over there)\ntype DigitalPin = DigitalInOutPin;\ntype AnalogPin = AnalogInOutPin;",
      "platform.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    /*\n    auto pinTemp = LOOKUP_PIN(TEMPERATURE);\n    if (pinTemp)\n        seed *= pinTemp->getAnalogValue();\n    auto pinLight = LOOKUP_PIN(LIGHT);\n    if (pinLight)\n        seed *= pinLight->getAnalogValue();\n    */\n    seedRandom(seed);\n}\n\nvoid platformSendSerial(const char *data, int len) {\n    /*\n    if (!serial) {\n        serial = new codal::_mbed::Serial(USBTX, NC);\n        serial->baud(9600);\n    }\n    serial->send((uint8_t*)data, len);\n    */\n}\n\nvoid platform_init() {\n    initRandomSeed();\n    setSendToUART(platformSendSerial);\n\n/*\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n*/\n}\n\n}\n\nvoid cpu_clock_init() {\n    devTimer.init();\n}\n",
      "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#include \"Image.h\"\n#include \"MultiButton.h\"\n#include \"ZPin.h\"\n#include \"ZTimer.h\"\n#include \"ZSPI.h\"\n#include \"ZI2C.h\"\n#include \"ZSingleWireSerial.h\"\n\n#include \"pinmap.h\"\n\n#define PXT_BOOTLOADER_CFG_ADDR 0x8003fc8\n\n#define PAGE_SIZE 1024 // not really\n\n#define DEV_NUM_PINS 64\n\n#define DEV_PWM_PINS 0b111100000011100111111110111000111111101111LL\n#define DEV_AIN_PINS 0b000011111100000000000000110000000011111111LL\n\n\n// Codal doesn't yet distinguish between PWM and AIN\n#define DEV_ANALOG_PINS (DEV_PWM_PINS | DEV_AIN_PINS)\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER ZTimer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n#define CODAL_JACDAC_WIRE_SERIAL codal::ZSingleWireSerial\n\n#define PERF_NOW() (TIM5->CNT)\n\n#define IMAGE_BITS 4\n\n// The parameters below needs tuning!\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA_0 0x00\n#define PA_1 0x01\n#define PA_2 0x02\n#define PA_3 0x03\n#define PA_4 0x04\n#define PA_5 0x05\n#define PA_6 0x06\n#define PA_7 0x07\n#define PA_8 0x08\n#define PA_9 0x09\n#define PA_10 0x0A\n#define PA_11 0x0B\n#define PA_12 0x0C\n#define PA_13 0x0D\n#define PA_14 0x0E\n#define PA_15 0x0F\n#define PB_0 0x10\n#define PB_1 0x11\n#define PB_2 0x12\n#define PB_3 0x13\n#define PB_4 0x14\n#define PB_5 0x15\n#define PB_6 0x16\n#define PB_7 0x17\n#define PB_8 0x18\n#define PB_9 0x19\n#define PB_10 0x1A\n#define PB_11 0x1B\n#define PB_12 0x1C\n#define PB_13 0x1D\n#define PB_14 0x1E\n#define PB_15 0x1F\n#define PC_0 0x20\n#define PC_1 0x21\n#define PC_2 0x22\n#define PC_3 0x23\n#define PC_4 0x24\n#define PC_5 0x25\n#define PC_6 0x26\n#define PC_7 0x27\n#define PC_8 0x28\n#define PC_9 0x29\n#define PC_10 0x2A\n#define PC_11 0x2B\n#define PC_12 0x2C\n#define PC_13 0x2D\n#define PC_14 0x2E\n#define PC_15 0x2F\n#endif\n\n#endif",
      "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#endif\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\nextern WebHF2 webhf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n} // namespace pxt\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#endif\n",
      "pxt.json": "{\n    \"name\": \"core---stm32f401re\",\n    \"description\": \"The core library for Codal-based targets\",\n    \"files\": [\n        \"README.md\",\n        \"dal.d.ts\",\n        \"codal.cpp\",\n        \"usb.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"pins.cpp\",\n        \"pinsAnalog.cpp\",\n        \"pinsDigital.cpp\",\n        \"pinsPWM.cpp\",\n        \"pins.ts\",\n        \"pinscompat.ts\",\n        \"control.cpp\",\n        \"i2c.cpp\",\n        \"i2c.ts\",\n        \"spi.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"hf2.cpp\",\n        \"hf2.h\",\n        \"hf2dbg.h\",\n        \"uf2format.h\",\n        \"uf2hid.h\",\n        \"ns.ts\",\n        \"dmac.cpp\",\n        \"dmac.h\",\n        \"timer.ts\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024,\n                \"tag\": 1\n            }\n        }\n    },\n    \"public\": true,\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\"\n        ]\n    },\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#endif\n",
      "pxtparts.json": "{\n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace pins {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (µs)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% parts=\"photocell\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% parts=\"analogled\" trackArgs=0\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% parts=\"slideswitch\" trackArgs=0 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (µs)|pin %name|pulsed %high||timeout %maxDuration (us)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (µs)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (µs) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\ndeclare namespace pins {\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cReadBuffer\n    function i2cReadBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cWriteBuffer\n    function i2cWriteBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\" shim=pins::spiWrite\n    function spiWrite(value: int32): int32;\n\n    /**\n     * Writes a given command to SPI bus, and afterwards reads the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\" shim=pins::spiTransfer\n    function spiTransfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\" shim=pins::spiFrequency\n    function spiFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI mode and bits\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\" shim=pins::spiMode\n    function spiMode(mode: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::SPI *spi = NULL;\n    static void initSPI() {\n        if (NULL == spi)\n            spi = new CODAL_SPI(*LOOKUP_PIN(MOSI), *LOOKUP_PIN(MISO), *LOOKUP_PIN(SCK));\n    }\n\n    /**\n    * Write to the SPI slave and return the response\n    * @param value Data to be sent to the SPI slave\n    */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    int spiWrite(int value) {\n        initSPI();\n        return spi->write(value);\n    }\n\n    /**\n    * Writes a given command to SPI bus, and afterwards reads the response.\n    */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    void spiTransfer(Buffer command, Buffer response) {\n        initSPI();\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi->transfer(cdata, clength, rdata, rlength);\n    }\n\n    /**\n    * Sets the SPI frequency\n    * @param frequency the clock frequency, eg: 1000000\n    */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    void spiFrequency(int frequency) {\n        initSPI();\n        spi->setFrequency(frequency);\n    }\n\n    /**\n    * Sets the SPI mode and bits\n    * @param mode the mode, eg: 3\n    */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    void spiMode(int mode) {\n        initSPI();\n        spi->setMode(mode);        \n    }\n}\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nforever(() => {\n    pause(100)\n})\n",
      "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
      "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n// if you increase that, you will also need to update the linker script file\n#define APP_START_ADDRESS 0x00002000\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\n#define UF2_BINFO ((UF2_BInfo *)(APP_START_ADDRESS - sizeof(UF2_BInfo)))\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return 0xb4 <= (uint32_t)addr && (uint32_t)addr < APP_START_ADDRESS;\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_BINFO->info_uf2))\n        return UF2_BINFO->info_uf2;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
      "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n",
      "usb.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\nWebHF2 webhf2(hf2buf);\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,            // bLength\n    0x01,            // bDescriptorType\n    0x0210,          // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40,            // bMaxPacketSize0\n    0x03EB, // Atmel\n    0x2402, // Example device\n    0x4202,          // bcdDevice - leave unchanged for the HF2 to work\n    0x01,            // iManufacturer\n    0x02,            // iProduct\n    0x03,            // SerialNumber\n    0x01             // bNumConfigs\n};\n\n// TODO extract these from uf2_info()?\nstatic const char *string_descriptors[] = {\n    \"Example Corp.\",\n    \"PXT Device\",\n    \"42424242\",\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(100);\n    usb.start();\n}\n\nvoid usb_init() {\n    usb.stringDescriptors = string_descriptors;\n    usb.deviceDescriptor = &device_desc;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n    usb.add(hf2);\n    usb.add(webhf2);\n    create_fiber(start_usb);\n}\n\n\n#else\nvoid usb_init() {}\n#endif\n\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n    webhf2.sendSerial(data, len);\n#endif    \n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n}\n"
    },
    "core---linux": {
      "Makefile": "include Makefile.inc\n\nCOMMON_FLAGS = -W -Wall -Wno-unused-parameter -Ipxtapp -fwrapv -fno-threadsafe-statics -O3 $(NPM_INCLUDES) -g\nLIBS = -lwiringPi -lm -lpthread -lrt\nCFLAGS = $(COMMON_FLAGS) -std=c99\nCXXFLAGS = $(COMMON_FLAGS) -std=c++11 -fno-rtti -fno-exceptions -fno-unwind-tables\nLDFLAGS = -Wl,--gc-sections -Wl,--sort-common -Wl,--sort-section=alignment -g -lwiringPi\nPREF = arm-linux-gnueabihf-\nCC = $(PREF)gcc\nLD = $(PREF)gcc\n#LIBSTDCPP = /usr/lib/gcc/arm-linux-gnueabi/4.9/libstdc++.a\nLIBSTDCPP = \nNPM_LIBS = $(wildcard node_modules/*/lib/*.a)\nNPM_INCLUDES = $(addprefix -I, $(wildcard node_modules/*/include))\n\nEXE = bld/pxt-app.elf\nHEX = $(EXE:.elf=.hex)\n\nDEPS = $(PXT_HEADERS) package.json Makefile Makefile.inc\n\nall: $(EXE)\n\n$(EXE): $(PXT_OBJS)\n\t$(LD) -o $(EXE) $(LDFLAGS) -Wl,-Map,$(EXE:.elf=.map) $(PXT_OBJS) $(LIBSTDCPP) $(LIBS) $(NPM_LIBS)\n\tcp $(EXE) $(EXE:.elf=.full)\n\t$(PREF)strip $(EXE)\n\tnode -p 'require(\"fs\").readFileSync(\"$(EXE)\").toString(\"hex\")' > $(HEX)\n\t@ls -l $(EXE)\n\nclean:\n\trm -rf bld\n\nbld/%.o: %.cpp $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CXXFLAGS) -c $< -o $@\n\nbld/%.o: %.s $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\nbld/%.o: %.c $(DEPS)\n\t@mkdir -p $(dir $@)\n\t$(CC) $(CFLAGS) -c $< -o $@\n",
      "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
      "config.cpp": "#include \"pxt.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nnamespace pxt {\n\nstruct EnvConfig {\n    const char *name;\n    const char *value;\n    EnvConfig *next;\n};\n\nstatic EnvConfig *readEnvConfig(const char *name) {\n    FILE *f = fopen(name, \"r\");\n    DMESG(\"read config: %s %s\", name, !f ? \"missing!\" : \"\");\n    if (!f)\n        return NULL;\n    EnvConfig *res = NULL;\n    EnvConfig *endres = NULL;\n    for (;;) {\n        char *line = NULL;\n        size_t len = 0;\n        int llen = getline(&line, &len, f);\n        if (llen <= 0)\n            break;\n        char *p = line;\n        while (isspace(*p))\n            p++;\n        if (!*p || *p == '#') {\n            free(line);\n            continue;\n        }\n\n        auto name = p;\n        while (isalnum(*p) || strchr(\"-_.\", *p))\n            p++;\n        auto endName = p;\n        while (isspace(*p))\n            p++;\n        if (*p == '=' || *p == ':') {\n            p++;\n        } else {\n            free(line);\n            continue;\n        }\n        *endName = 0;\n        while (isspace(*p))\n            p++;\n\n        auto e = new EnvConfig;\n        e->name = name;\n        e->value = p;\n        e->next = endres;\n\n        if (*p) {\n            auto ep = p + strlen(p) - 1;\n            while (ep > p && isspace(*ep))\n                ep--;\n            ep++;\n            *ep = 0;\n        }\n\n        DMESG(\"%s=%s\", e->name, e->value);\n\n        if (endres == NULL) {\n            res = e;\n        } else {\n            endres->next = e;\n        }\n        e->next = NULL;\n        endres = e;\n    }\n    fclose(f);\n\n    return res;\n}\n\nstatic int gotConfig;\nstatic EnvConfig *envConfig;\nstatic void readConfig() {\n    if (gotConfig)\n        return;\n    gotConfig = 1;\n    envConfig = readEnvConfig(\"/sd/arcade.cfg\");\n    DMESG(\"config done\");\n}\nconst char *getConfigString(const char *name) {\n    readConfig();\n    for (auto p = envConfig; p; p = p->next) {\n        if (strcmp(p->name, name) == 0)\n            return p->value;\n    }\n    return NULL;\n}\nint getConfigInt(const char *name, int defl) {\n    auto v = getConfigString(name);\n    if (!v)\n        return defl;\n    sscanf(v, \"%d\", &defl);\n    return defl;\n}\n\nconst int *getConfigInts(const char *name) {\n    static int buf[30];\n\n    buf[0] = ENDMARK;\n\n    auto v = getConfigString(name);\n\n    if (!v)\n        return buf;\n\n    int bp = 0;\n\n    while (bp < 25) {\n        while (isspace(*v))\n            v++;\n        if (!*v)\n            break;\n        if (sscanf(v, \"%i\", &buf[bp]) != 1)\n            break;\n        while (*v && !isspace(*v) && *v != ',')\n            v++;\n        while (isspace(*v))\n            v++;\n        if (*v == ',')\n            v++;\n        bp++;\n    }\n    buf[bp] = ENDMARK;\n\n    // if (gotConfig++ < 20)\n    //    DMESG(\"%s - %d %d %d len=%d\", name, buf[0], buf[1], buf[2], bp);\n\n    return buf;\n}\n\n} // namespace pxt",
      "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n * @param mode optional definition of how the event should be processed after construction.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n//% help=control/raise-event\nvoid raiseEvent(int src, int value) {\n    pxt::raiseEvent(src, value);\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return pxt::allocateNotifyEvent();\n}\n\n/** Write data to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->data);\n}\n\n}\n\nnamespace serial {\n    /** Send DMESG debug buffer over serial. */\n    //%\n    void writeDmesg() {\n        pxt::dumpDmesg();\n    }\n}",
      "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/codal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/codal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/codal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/codal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/codal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/codal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/codal/libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // built/codal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/codal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/codal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/codal/libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // built/codal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/codal/libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // built/codal/libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // built/codal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/codal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/codal/libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // built/codal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/codal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/codal/libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // built/codal/libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/codal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/codal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/codal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/codal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/codal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/codal/pxtapp/core---stm32f401re/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/codal/pxtapp/core---stm32f401re/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // built/codal/pxtapp/core---stm32f401re/platform.h\n    PXT_BOOTLOADER_CFG_ADDR = 134234056,\n    PAGE_SIZE = 1024,\n    DEV_NUM_PINS = 64,\n    IMAGE_BITS = 4,\n    PA_0 = 0,\n    PA_1 = 1,\n    PA_2 = 2,\n    PA_3 = 3,\n    PA_4 = 4,\n    PA_5 = 5,\n    PA_6 = 6,\n    PA_7 = 7,\n    PA_8 = 8,\n    PA_9 = 9,\n    PA_10 = 10,\n    PA_11 = 11,\n    PA_12 = 12,\n    PA_13 = 13,\n    PA_14 = 14,\n    PA_15 = 15,\n    PB_0 = 16,\n    PB_1 = 17,\n    PB_2 = 18,\n    PB_3 = 19,\n    PB_4 = 20,\n    PB_5 = 21,\n    PB_6 = 22,\n    PB_7 = 23,\n    PB_8 = 24,\n    PB_9 = 25,\n    PB_10 = 26,\n    PB_11 = 27,\n    PB_12 = 28,\n    PB_13 = 29,\n    PB_14 = 30,\n    PB_15 = 31,\n    PC_0 = 32,\n    PC_1 = 33,\n    PC_2 = 34,\n    PC_3 = 35,\n    PC_4 = 36,\n    PC_5 = 37,\n    PC_6 = 38,\n    PC_7 = 39,\n    PC_8 = 40,\n    PC_9 = 41,\n    PC_10 = 42,\n    PC_11 = 43,\n    PC_12 = 44,\n    PC_13 = 45,\n    PC_14 = 46,\n    PC_15 = 47,\n    // built/codal/pxtapp/core---stm32f401re/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // built/codal/pxtapp/core---stm32f401re/uf2hid.h\n    UF2_HID_H = 1,\n    // built/codal/pxtapp/pxtbase.h\n    MEMDBG_ENABLED = 0,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    // built/codal/pxtapp/pxtconfig.h\n    PXT_VM = 0,\n}\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "linux.cpp": "#include \"pxt.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <time.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <errno.h>\n#include <malloc.h>\n\n#define THREAD_DBG(...)\n\n#define MALLOC_LIMIT (8 * 1024 * 1024)\n#define MALLOC_CHECK_PERIOD (1024 * 1024)\n\nvoid *xmalloc(size_t sz) {\n#ifndef POKY\n    static size_t allocBytes = 0;\n    allocBytes += sz;\n    if (allocBytes >= MALLOC_CHECK_PERIOD) {\n        allocBytes = 0;\n        auto info = mallinfo();\n        // DMESG(\"malloc used: %d kb\", info.uordblks / 1024);\n        if (info.uordblks > MALLOC_LIMIT) {\n            target_panic(PANIC_MEMORY_LIMIT_EXCEEDED);\n        }\n    }\n#endif\n    auto r = malloc(sz);\n    if (r == NULL)\n        oops(50); // shouldn't happen\n    return r;\n}\n\nvoid *operator new(size_t size) {\n    return xmalloc(size);\n}\nvoid *operator new[](size_t size) {\n    return xmalloc(size);\n}\n\nvoid operator delete(void *p) {\n    free(p);\n}\nvoid operator delete[](void *p) {\n    free(p);\n}\n\nnamespace pxt {\n\nstatic uint64_t startTime;\nstatic pthread_mutex_t execMutex;\nstatic pthread_mutex_t eventMutex;\nstatic pthread_cond_t newEventBroadcast;\n\nstruct Thread {\n    struct Thread *next;\n    Action act;\n    TValue arg0;\n    TValue data0;\n    TValue data1;\n    pthread_t pid;\n    pthread_cond_t waitCond;\n    int waitSource;\n    int waitValue;\n};\n\nstatic struct Thread *allThreads;\nstatic struct Event *eventHead, *eventTail;\n\nstruct Event {\n    struct Event *next;\n    int source;\n    int value;\n};\n\nEvent lastEvent;\n\nEvent *mkEvent(int source, int value) {\n    auto res = new Event();\n    memset(res, 0, sizeof(Event));\n    res->source = source;\n    res->value = value;\n    return res;\n}\n\nvolatile bool paniced;\nextern \"C\" void drawPanic(int code);\n\nextern \"C\" void target_panic(int error_code) {\n    char buf[50];\n    int prevErr = errno;\n\n    paniced = true;\n    pthread_mutex_trylock(&execMutex);\n\n    snprintf(buf, sizeof(buf), \"\\nPANIC %d\\n\", error_code);\n\n    drawPanic(error_code);\n    DMESG(\"PANIC %d\", error_code);\n    DMESG(\"errno=%d %s\", prevErr, strerror(prevErr));\n\n    for (int i = 0; i < 10; ++i) {\n        sendSerial(buf, strlen(buf));\n        sleep_core_us(500 * 1000);\n    }\n\n    target_exit();\n}\n\nvoid startUser() {\n    pthread_mutex_lock(&execMutex);\n}\n\nvoid stopUser() {\n    pthread_mutex_unlock(&execMutex);\n}\n\nvoid sleep_core_us(uint64_t us) {\n    struct timespec ts;\n    ts.tv_sec = us / 1000000;\n    ts.tv_nsec = (us % 1000000) * 1000;\n    while (nanosleep(&ts, &ts))\n        ;\n}\n\nvoid sleep_ms(uint32_t ms) {\n    stopUser();\n    sleep_core_us(ms * 1000);\n    startUser();\n}\n\nvoid sleep_us(uint64_t us) {\n    if (us > 50000) {\n        sleep_ms(us / 1000);\n    }\n    sleep_core_us(us);\n}\n\nuint64_t currTime() {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000000LL + tv.tv_usec;\n}\n\nuint64_t current_time_us() {\n    return currTime() - startTime;\n}\n\nint current_time_ms() {\n    return current_time_us() / 1000;\n}\n\nvoid disposeThread(Thread *t) {\n    if (allThreads == t) {\n        allThreads = t->next;\n    } else {\n        for (auto tt = allThreads; tt; tt = tt->next) {\n            if (tt->next == t) {\n                tt->next = t->next;\n                break;\n            }\n        }\n    }\n    unregisterGC(&t->act, 4);\n    decr(t->act);\n    decr(t->arg0);\n    decr(t->data0);\n    decr(t->data1);\n    pthread_cond_destroy(&t->waitCond);\n    delete t;\n}\n\nstatic void runAct(Thread *thr) {\n    startUser();\n    pxt::runAction1(thr->act, thr->arg0);\n    stopUser();\n    disposeThread(thr);\n}\n\nstatic void mainThread(Thread *) {}\n\nvoid setupThread(Action a, TValue arg = 0, void (*runner)(Thread *) = NULL, TValue d0 = 0,\n                 TValue d1 = 0) {\n    if (runner == NULL)\n        runner = runAct;\n    auto thr = new Thread();\n    memset(thr, 0, sizeof(Thread));\n    thr->next = allThreads;\n    allThreads = thr;\n    registerGC(&thr->act, 4);\n    thr->act = incr(a);\n    thr->arg0 = incr(arg);\n    thr->data0 = incr(d0);\n    thr->data1 = incr(d1);\n    pthread_cond_init(&thr->waitCond, NULL);\n    if (runner == mainThread) {\n        thr->pid = pthread_self();\n    } else {\n        pthread_create(&thr->pid, NULL, (void *(*)(void *))runner, thr);\n        THREAD_DBG(\"setup thread: %p (pid %p)\", thr, thr->pid);\n        pthread_detach(thr->pid);\n    }\n}\n\nvoid releaseFiber() {\n    stopUser();\n    pthread_exit(NULL);\n}\n\nvoid runInParallel(Action a) {\n    setupThread(a);\n}\n\nstatic void runFor(Thread *t) {\n    startUser();\n    while (true) {\n        pxt::runAction0(t->act);\n        sleep_ms(20);\n    }\n}\n\nvoid runForever(Action a) {\n    setupThread(a, 0, runFor);\n}\n\nvoid waitForEvent(int source, int value) {\n    THREAD_DBG(\"waitForEv: %d %d\", source, value);\n    auto self = pthread_self();\n    for (auto t = allThreads; t; t = t->next) {\n        THREAD_DBG(\"t: %p\", t);\n        if (t->pid == self) {\n            pthread_mutex_lock(&eventMutex);\n            t->waitSource = source;\n            t->waitValue = value;\n            stopUser();\n            // spourious wake ups may occur they say\n            while (t->waitSource) {\n                pthread_cond_wait(&t->waitCond, &eventMutex);\n            }\n            pthread_mutex_unlock(&eventMutex);\n            startUser();\n            return;\n        }\n    }\n    DMESG(\"current thread not registered!\");\n    oops(52);\n}\n\nstatic void dispatchEvent(Event &e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    if (curr)\n        setupThread(curr->action, fromInt(e.value));\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        setupThread(curr->action, fromInt(e.value));\n}\n\nstatic void *evtDispatcher(void *dummy) {\n    pthread_mutex_lock(&eventMutex);\n    while (true) {\n        pthread_cond_wait(&newEventBroadcast, &eventMutex);\n        while (eventHead != NULL) {\n            if (paniced)\n                return 0;\n            Event *ev = eventHead;\n            eventHead = ev->next;\n            if (eventHead == NULL)\n                eventTail = NULL;\n\n            for (auto thr = allThreads; thr; thr = thr->next) {\n                if (paniced)\n                    return 0;\n                if (thr->waitSource == 0)\n                    continue;\n                if (thr->waitValue != ev->value && thr->waitValue != DEVICE_EVT_ANY)\n                    continue;\n                if (thr->waitSource == ev->source) {\n                    thr->waitSource = 0; // once!\n                    pthread_cond_broadcast(&thr->waitCond);\n                } else if (thr->waitSource == DEVICE_ID_NOTIFY &&\n                           ev->source == DEVICE_ID_NOTIFY_ONE) {\n                    thr->waitSource = 0; // once!\n                    pthread_cond_broadcast(&thr->waitCond);\n                    break; // do not wake up any other threads\n                }\n            }\n\n            dispatchEvent(*ev);\n            delete ev;\n        }\n    }\n}\n\nint allocateNotifyEvent() {\n    static volatile int notifyId;\n    pthread_mutex_lock(&eventMutex);\n    int res = ++notifyId;\n    pthread_mutex_unlock(&eventMutex);\n    return res;\n}\n\nvoid raiseEvent(int id, int event) {\n    auto e = mkEvent(id, event);\n    pthread_mutex_lock(&eventMutex);\n    if (eventTail == NULL) {\n        if (eventHead != NULL)\n            oops(51);\n        eventHead = eventTail = e;\n    } else {\n        eventTail->next = e;\n        eventTail = e;\n    }\n    pthread_cond_broadcast(&newEventBroadcast);\n    pthread_mutex_unlock(&eventMutex);\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // TODO support flags\n    setBinding(id, event, a);\n}\n\nstatic void runPoller(Thread *thr) {\n    Action query = thr->data0;\n    auto us = (uint64_t)toInt(thr->data1) * 1000;\n\n    // note that this is run without the user mutex held - it should not modify any state!\n    TValue prev = pxt::runAction0(query);\n    if (!isTagged(prev))\n        oops(30);\n\n    startUser();\n    pxt::runAction2(thr->act, prev, prev);\n    stopUser();\n\n    while (true) {\n        sleep_core_us(us);\n        if (paniced)\n            break;\n        TValue curr = pxt::runAction0(query);\n        if (!isTagged(curr))\n            oops(30);\n        if (curr != prev) {\n            startUser();\n            pxt::runAction2(thr->act, prev, curr);\n            stopUser();\n            if (paniced)\n                break;\n            decr(prev);\n            prev = curr;\n        }\n    }\n    //    disposeThread(thr);\n}\n\n//%\nvoid unsafePollForChanges(int ms, Action query, Action handler) {\n    setupThread(handler, 0, runPoller, query, fromInt(ms));\n}\n\nuint32_t afterProgramPage() {\n    return 0;\n}\n\nchar **initialArgv;\n\nvoid screen_init();\nvoid initKeys();\nvoid target_startup();\n\nvoid initRuntime() {\n    // daemon(1, 1);\n    startTime = currTime();\n\n    target_startup();\n\n    pthread_t disp;\n    pthread_create(&disp, NULL, evtDispatcher, NULL);\n    pthread_detach(disp);\n    setupThread(0, 0, mainThread);\n    target_init();\n    screen_init();\n    initKeys();\n    startUser();\n}\n\n#ifdef PXT_GC\n#define GC_BASE 0x20000000\n#define GC_PAGE_SIZE 4096\nvoid *gcAllocBlock(size_t sz) {\n    static uint8_t *currPtr = (uint8_t *)GC_BASE;\n    sz = (sz + GC_PAGE_SIZE - 1) & ~(GC_PAGE_SIZE - 1);\n    void *r = mmap(currPtr, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (r == MAP_FAILED) {\n        DMESG(\"mmap %p failed; err=%d\", currPtr, errno);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n    currPtr = (uint8_t *)r + sz;\n    if (isReadOnly((TValue)r)) {\n        DMESG(\"mmap returned read-only address: %p\", r);\n        target_panic(PANIC_INTERNAL_ERROR);\n    }\n    return r;\n}\n#endif\n\nstatic __thread ThreadContext *threadCtx;\n\nThreadContext *getThreadContext() {\n    return threadCtx;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    threadCtx = ctx;\n}\n\nvoid *getCurrentFiber() {\n    return (void *)pthread_self();\n}\n\nvoid *threadAddressFor(ThreadContext *, void *sp) {\n    return sp;\n}\n\n} // namespace pxt\n",
      "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}",
      "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n#define CFG_PIN_JACDAC 60\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_I2C\n#define CODAL_I2C CODAL_MBED::I2C\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
      "platform.cpp": "#include \"pxt.h\"\n\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n\nnamespace pxt {\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    read(fd, &seed, sizeof(seed));\n    close(fd);\n    seedRandom(seed);\n}\n\nvoid sendSerial(const char *data, int len) {\n    /*\n    if (!serial) {\n        serial = new codal::_mbed::Serial(USBTX, NC);\n        serial->baud(9600);\n    }\n    serial->send((uint8_t*)data, len);\n    */\n}\n\nextern \"C\" void drawPanic(int code)\n{\n    // TODO\n}\n\n\nextern \"C\" void target_init()\n{\n    initRandomSeed();\n}\n\nvoid screen_init() {\n\n}\n\n}\n\n",
      "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#define PAGE_SIZE 1024 // not really\n\n#define DEV_NUM_PINS 28\n\n#define DEV_PWM_PINS 0xffffffffULL\n#define DEV_AIN_PINS 0ULL\n\n\n// Codal doesn't yet distinguish between PWM and AIN\n#define DEV_ANALOG_PINS (DEV_PWM_PINS | DEV_AIN_PINS)\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER ZTimer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n\n\nnamespace pxt\n{\n\n    class ZPin;\n    class AbstractButton;\n    class MultiButton;\n    class CodalComponent;\n    \n    \n} // pxt\n\n#define IMAGE_BITS 4\n\n#endif\n",
      "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n//#include \"pins.h\"\n\nnamespace pxt {\nvoid raiseEvent(int id, int event);\nint allocateNotifyEvent();\nvoid sleep_core_us(uint64_t us);\nvoid startUser();\nvoid stopUser();\n\nconst char *getConfigString(const char *name);\nint getConfigInt(const char *name, int defl);\n#define ENDMARK -0x7fff0123\nconst int *getConfigInts(const char *name);\n\nclass Button;\ntypedef Button *Button_;\n\nextern \"C\" void target_init();\n\nclass MMap : public RefObject {\n  public:\n    int length;\n    int fd;\n    uint8_t *data;\n\n    MMap();\n    void destroy();\n    void print();\n};\n\nextern volatile bool paniced;\nextern char **initialArgv;\nvoid target_exit();\n\n// Buffer, Sound, and Image share representation.\ntypedef Buffer Sound;\n\n// extern Event lastEvent;\n} // namespace pxt\n\n#define DEVICE_ID_FIRST_BUTTON 4000\n\n#define DEVICE_EVT_ANY 0\n#define DEVICE_ID_NOTIFY 10000\n#define DEVICE_ID_NOTIFY_ONE 10001\n\n#undef PXT_MAIN\n#define PXT_MAIN                                                                                   \\\n    int main(int argc, char **argv) {                                                        \\\n        pxt::initialArgv = argv;                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#endif\n",
      "pxt.json": "{\n    \"name\": \"core---linux\",\n    \"files\": [\n        \"README.md\",\n        \"Makefile\",\n        \"dal.d.ts\",\n        \"linux.cpp\",\n        \"config.cpp\",\n        \"target.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"control.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"ns.ts\",\n        \"timer.ts\",\n        \"pxtparts.json\"\n    ],\n    \"description\": \"The core library for Codal-based targets\",\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024,\n                \"tag\": 1\n            }\n        }\n    },\n    \"public\": true,\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\"\n        ]\n    },\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include <stdio.h>\n#include <stdlib.h>\n\nnamespace pxt {\nvoid dmesg(const char *fmt, ...);\n#define DMESG pxt::dmesg\nvoid *gcAllocBlock(size_t sz);\n}\n\nstatic inline void itoa(int v, char *dst) {\n    snprintf(dst, 30, \"%d\", v);\n}\n\n#define PXT_USE_XMALLOC\nextern \"C\" void *xmalloc(size_t sz);\n\n#define GC_ALLOC_BLOCK gcAllocBlock\n\n#ifndef POKY\n// This seems to degrade performance - probably due to cache size\n//#define GC_BLOCK_SIZE (1024 * 64)\n#endif\n\n#define PXT_HARD_FLOAT 1\n\n#endif\n",
      "pxtparts.json": "{\n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     * @param mode optional definition of how the event should be processed after construction.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\n    //% help=control/raise-event shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write data to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n}\ndeclare namespace serial {\n\n    /** Send DMESG debug buffer over serial. */\n    //% shim=serial::writeDmesg\n    function writeDmesg(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "target.cpp": "#include \"pxt.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <fcntl.h>\n\nnamespace pxt {\n\nvoid target_exit() {\n    kill(getpid(), SIGTERM);\n}\n\nextern \"C\" void target_reset() {\n    for (int i = 3; i < 1000; ++i)\n        close(i);\n    if (!fork()) {\n        execv(initialArgv[0], initialArgv);\n        exit(127);\n    } else {\n        target_exit();\n    }\n}\n\nvoid target_startup() {\n    int pid = getpid();\n    DMESG(\"runtime starting, pid=%d...\", pid);\n\n    FILE *pf = fopen(\"/tmp/pxt-pid\", \"r\");\n    if (pf) {\n        int p2 = 0;\n        fscanf(pf, \"%d\", &p2);\n        if (p2)\n            kill(p2, SIGTERM);\n        fclose(pf);\n    }\n    pf = fopen(\"/tmp/pxt-pid\", \"w\");\n    fprintf(pf, \"%d\", pid);\n    fclose(pf);\n}\n\nstatic FILE *dmesgFile;\n\nstatic int dmesgPtr;\nstatic int dmesgSerialPtr;\nstatic char dmesgBuf[4096];\n\nvoid dumpDmesg() {\n    auto len = dmesgPtr - dmesgSerialPtr;\n    if (len == 0)\n        return;\n    sendSerial(dmesgBuf + dmesgSerialPtr, len);\n    dmesgSerialPtr = dmesgPtr;\n}\n\n\nstatic void dmesgRaw(const char *buf, uint32_t len) {\n    if (!dmesgFile) {\n        dmesgFile = fopen(\"/tmp/dmesg.txt\", \"w\");\n        if (!dmesgFile)\n            dmesgFile = stderr;\n    }\n\n    if (len > sizeof(dmesgBuf) / 2)\n        return;\n    if (dmesgPtr + len > sizeof(dmesgBuf)) {\n        dmesgPtr = 0;\n        dmesgSerialPtr = 0;\n    }\n    memcpy(dmesgBuf + dmesgPtr, buf, len);\n    dmesgPtr += len;\n    fwrite(buf, 1, len, dmesgFile);\n\n    fwrite(buf, 1, len, stderr);\n}\n\nstatic void dmesgFlushRaw() {\n    fflush(dmesgFile);\n    fdatasync(fileno(dmesgFile));\n}\n\nvoid dmesg(const char *format, ...) {\n    char buf[500];\n\n    snprintf(buf, sizeof(buf), \"[%8d] \", current_time_ms());\n    dmesgRaw(buf, strlen(buf));\n\n    va_list arg;\n    va_start(arg, format);\n    vsnprintf(buf, sizeof(buf), format, arg);\n    va_end(arg);\n    dmesgRaw(buf, strlen(buf));\n    dmesgRaw(\"\\n\", 1);\n\n    dmesgFlushRaw();\n}\n\nint getSerialNumber() {\n    static int serial;\n\n    if (serial)\n        return serial;\n\n    char buf[1024];\n    int fd = open(\"/proc/cpuinfo\", O_RDONLY);\n    int len = read(fd, buf, sizeof(buf) - 1);\n    close(fd);\n\n    if (len < 0)\n        len = 0;\n    buf[len] = 0;\n    auto p = strstr(buf, \"Serial\\t\");\n    if (p) {\n        p += 6;\n        while (*p && strchr(\" \\t:\", *p))\n            p++;\n        uint64_t s = 0;\n        sscanf(p, \"%llu\", &s);\n        serial = (s >> 32) ^ (s);\n    }\n\n    if (!serial)\n        serial = 0xf00d0042;\n\n    return serial;\n}\n\n} // namespace pxt\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nforever(() => {\n    pause(100)\n})\n",
      "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}"
    },
    "corgio": {
      "README.md": "# Corgio\n\nA small wrapper to help in creating a Corgi based platformer.",
      "corgio.ts": "/**\n* Sprite Wrapper for a Corgi Platformer\n*/\n//% weight=100 color=#d2b48c icon=\"\\uf1b0\"\n//% groups='[\"Create\", \"Movement\", \"Speak\", \"Properties\"]'\nnamespace corgio {\n    export enum CorgiFlags {\n        None = 0,\n        HorizontalMovement = 1 << 0,\n        VerticalMovement = 1 << 1,\n        UpdateSprite = 1 << 2,\n        CameraFollow = 1 << 3,\n        All = ~(~0 << 4)\n    }\n\n    export let _corgi_still: Image[] = [\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . d e 4 4 4 4 4 e d . . . .\n            . . . d d 4 e d e 4 d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f e f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 e 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e a e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 a 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . 4 . . . 4 . . . . . .\n            . . . . 4 f 4 d 4 f 4 . . . . .\n            . . . . 4 f 4 4 4 f 4 . . . . .\n            . . . . e 4 d 4 d 4 4 . . . . .\n            . . . . 4 4 f 4 f 4 f . . . . .\n            . . . . e 4 4 4 4 4 e . . . . .\n            . . . d e d 4 4 4 d e d . . . .\n            . . . d d d e d e d d d . . . .\n        `,\n    ];\n\n    export let _corgi_left: Image[] = [\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . . . . .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d . . . e 4 f .\n            f d 4 4 4 4 4 d d e e e 4 4 4 .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 4 4 4 4 4 .\n            . . . . . d d d 4 4 f 4 f 4 4 .\n            . . . . . . d 4 d 4 f f f 4 d d\n            . . . . . . f . . . . . . . d f\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 4 .\n            . . 4 d d f f d d 4 f 4 f 4 4 .\n            . . . . . d d d 4 d f f f 4 d d\n            . . . . . . d 4 d . . . . . d f\n            . . . . . . f . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 4 .\n            . . 4 d d f f d d 4 f 4 f 4 4 .\n            . . . . d d d 4 4 d f f f 4 d d\n            . . . f d 4 . . . . . . . . d f\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 f 4 f 4 . .\n            . . . . d d d 4 4 d f f f 4 d .\n            . . . f d 4 . . . . . . 4 d d .\n            . . . . . . . . . . . . . f . .\n            . . . . . . . . . . . . . . . .\n        `,\n        img`\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . . . . . . . . . . . . . . .\n            . . 4 . . . 4 . . . . . . . . .\n            . 4 f 4 d 4 f 4 . . . . . . . .\n            . 4 f 4 4 4 f 4 . . . . . . . .\n            . 4 4 d 4 d 4 4 . . . . e 4 f .\n            . e 4 f 4 f 4 e . . . . e 4 f .\n            . e 4 4 4 4 4 4 d e e e 4 4 4 .\n            f d 4 4 4 4 4 d d 4 4 4 4 4 . .\n            . 4 d d d 4 f d 4 4 4 4 4 4 . .\n            . . 4 d d f f d d 4 f 4 f 4 . .\n            . . . . d 4 d 4 4 d f f f 4 d .\n            . . . . d 4 . . . . . . 4 d d .\n            . . . . . f . . . . . . . f . .\n            . . . . . . . . . . . . . . . .\n        `\n    ];\n\n    export let _corgi_right: Image[] = reflect(_corgi_left);\n\n    /**\n     * Creates a new dart from an image and kind\n     * @param kind the kind to make the corgi \n     * @param x optional initial x position, eg: 10\n     * @param y optional initial y position, eg: 70\n     */\n    //% blockId=corgiCreate block=\"corgi of kind %kind=spritetype || at x %x y %y\"\n    //% expandableArgumentMode=toggle\n    //% inlineInputMode=inline\n    //% blockSetVariable=myCorg\n    //% weight=100\n    //% group=\"Create\"\n    export function create(kind: number,\n                            x: number = 10,\n                            y: number = 70): Corgio {\n        return new Corgio(kind, x, y);\n    }\n\n    // Round input towards 0; 1.4 becomes 1.0, -0.4 becomes 0.0\n    export function roundTowardsZero(input: number): number {\n        return Math.floor(input) + input < 0 ? 1 : 0;\n    }\n\n    // Normalize input number to 0, 1, or -1\n    export function normalize(input: number): number {\n        return input ? input / Math.abs(input) : 0;\n    }\n\n    // Set the animation for looking right to be the opposite of looking left\n    export function reflect(input: Image[]): Image[] {\n        let output: Image[] = [];\n        for (let i: number = 0; i < input.length; i++) {\n            let nextImage = input[i].clone();\n            nextImage.flipX();\n            output.push(nextImage);\n        }\n        return output;\n    }\n}\n\n/**\n * A Corgi Platformer\n **/\n//% blockNamespace=corgio color=\"#d2b48c\" blockGap=8\nclass Corgio {\n    private player: Sprite;\n    private stillAnimation: Image[];\n    private _leftAnimation: Image[];\n    private _rightAnimation: Image[];\n\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"horizontal speed\"\n    maxMoveVelocity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"gravity\"\n    gravity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"jump speed\"\n    jumpVelocity: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"max jumps in a row\"\n    maxJump: number;\n    //% group=\"Properties\" blockSetVariable=\"myCorg\"\n    //% blockCombine block=\"rate horizontal movement is slowed\"\n    decelerationRate: number;\n\n    private controlFlags: number;\n    private initJump: boolean;\n    private releasedJump: boolean;\n    private count: number;\n    private touching: number;\n    private remainingJump: number;\n    private script: string[];\n\n    public constructor(kind: number, x: number, y: number) {\n        this.maxMoveVelocity = 70;\n        this.gravity = 300;\n        this.jumpVelocity = 125;\n\n        this.initJump = true;\n        this.releasedJump = true;\n        this.maxJump = 2;\n        this.count = 0;\n        this.touching = 2;\n        this.remainingJump = this.maxJump;\n        this.script = [\n            \"bark\"\n        ];\n\n        this.controlFlags = corgio.CorgiFlags.None;\n\n        this.stillAnimation = corgio._corgi_still;\n        this._leftAnimation = corgio._corgi_left;\n        this._rightAnimation = corgio._corgi_right;\n\n        this.player = sprites.create(this.stillAnimation[0], kind);\n        this.player.setFlag(SpriteFlag.StayInScreen, true);\n        this.player.ay = this.gravity;\n        this.player.x = x;\n        this.player.y = y;\n    }\n\n    /**\n     * Get the Corgio's sprite\n     */\n    //% group=\"Properties\"\n    //% blockId=corgSprite block=\"%corgio(myCorg) sprite\"\n    //% weight=8\n    get sprite(): Sprite {\n        return this.player;\n    }\n\n    /**\n     * Make the character move in the direction indicated by the left and right arrow keys.\n     */\n    //% group=\"Movement\"\n    //% blockId=horizontalMovement block=\"make %corgio(myCorg) move left and right with arrow keys || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    horizontalMovement(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.HorizontalMovement);\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.HorizontalMovement)) return;\n\n            let dir: number = controller.dx();\n\n            _this.player.vx = dir ? corgio.normalize(dir) * _this.maxMoveVelocity :\n                                    corgio.roundTowardsZero(_this.player.vx * _this.decelerationRate);\n        })\n    }\n\n    /**\n     * Make the character jump when the up arrow key is pressed, and grab onto the wall when falling.\n     */\n    //% group=\"Movement\"\n    //% blockId=verticalMovement block=\"make %corgio(myCorg) jump if up arrow key is pressed || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    verticalMovement(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.VerticalMovement);\n\n        controller.up.onEvent(ControllerButtonEvent.Released, function () {\n            _this.releasedJump = true;\n        })\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.VerticalMovement)) return;\n\n            if (controller.up.isPressed()) {\n                if (_this.contactLeft() && controller.right.isPressed()\n                        || _this.contactRight() && controller.left.isPressed()) {\n                    _this.remainingJump = Math.max(_this.remainingJump + 1, _this.maxJump);\n                }\n                _this.jumpImpulse();\n            }\n\n            if ((_this.contactLeft() && controller.left.isPressed()\n                    || _this.contactRight() && controller.right.isPressed())\n                    && _this.player.vy > - 10) {\n                _this.player.ay = _this.gravity >> 2;\n            } else {\n                _this.player.ay = _this.gravity;\n            }\n\n            if (_this.contactBelow()) {\n                if (_this.initJump) {\n                    _this.remainingJump = _this.maxJump;\n                }\n                _this.initJump = true;\n            }\n        })\n    }\n\n    /**\n     * Set camera to follow corgio horizontally, while keeping the screen centered vertically.\n     */\n    //% group=\"Movement\"\n    //% blockId=followCorgi block=\"make camera follow %corgio(myCorg) left and right || %on=toggleOnOff\"\n    //% weight=90 blockGap=5\n    follow(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.CameraFollow);\n\n        game.onUpdate(function () {\n            if (_this.controlFlags & corgio.CorgiFlags.CameraFollow) {\n                scene.centerCameraAt(_this.player.x, screen.height >> 1);\n            }\n        })\n    }\n\n    /**\n     * Make the character change sprites when moving.\n     */\n    //% group=\"Movement\"\n    //% blockId=updateSprite block=\"change image when %corgio(myCorg) is moving || %on=toggleOnOff\"\n    //% weight=100 blockGap=5\n    updateSprite(on: boolean = true): void {\n        let _this = this;\n\n        this.updateFlags(on, corgio.CorgiFlags.UpdateSprite);\n\n        game.onUpdate(function () {\n            if (!(_this.controlFlags & corgio.CorgiFlags.UpdateSprite)) return;\n\n            _this.count++;\n\n            if (_this.player.vx == 0) {\n                _this.player.setImage(_this.pickNext(_this.stillAnimation, 6));\n            } else if (_this.player.vx < 0) {\n                _this.player.setImage(_this.pickNext(_this._leftAnimation));\n            } else {\n                _this.player.setImage(_this.pickNext(_this._rightAnimation));\n            }\n        })\n    }\n\n    /**\n     * Add new phrase for the character to bark\n     * @param input phrase to add to script, eg: \"bark\"\n     */\n    //% group=\"Speak\"\n    //% blockId=addScript block=\"teach %corgio(myCorg) the word %input\"\n    //% weight=95 blockGap=5\n    addToScript(input: string): void {\n        this.script.push(input);\n    }\n\n    /**\n     * Have the character say one of the phrases in the script at random\n     */\n    //% group=\"Speak\"\n    //% blockId=bark block=\"make %corgio(myCorg) bark!\"\n    //% weight=95 blockGap=5\n    bark(): void {\n        this.player.say(Math.pickRandom(this.script), 250);\n    }\n\n    private jumpImpulse() {\n        if (this.remainingJump > 0 && this.releasedJump) {\n            this.releasedJump = false;\n            if (this.initJump) {\n                this.player.vy = -1 * this.jumpVelocity;\n                this.initJump = false;\n            } else {\n                this.player.vy = Math.clamp((-4 * this.jumpVelocity) / 3, -30,\n                                            this.player.vy - this.jumpVelocity);\n            }\n            this.remainingJump--;\n        }\n    }\n\n    private updateFlags(on: boolean, flag: corgio.CorgiFlags): void {\n        if (on) this.controlFlags |= flag;\n        else this.controlFlags &= corgio.CorgiFlags.All ^ flag;\n    }\n\n    private pickNext(input: Image[], state: number = 3): Image {\n        return input[(this.count / state) % input.length];\n    }\n\n    private contactLeft(): boolean {\n        let screenEdge = game.currentScene().camera.offsetX;\n        return this.player.left - screenEdge <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Left);\n    }\n\n    private contactRight(): boolean {\n        let screenEdge = screen.width + game.currentScene().camera.offsetX;\n        return screenEdge - this.player.right <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Right);\n    }\n\n    private contactBelow(): boolean {\n        let screenEdge = screen.height + game.currentScene().camera.offsetY;\n        return screenEdge - this.player.bottom <= this.touching\n                || this.player.isHittingTile(CollisionDirection.Bottom);\n    }\n}\n",
      "pxt.json": "{\n    \"name\": \"corgio\",\n    \"description\": \"A Corgi platformer\",\n    \"files\": [\n        \"README.md\",\n        \"corgio.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"game\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    },\n    \"icon\": \"/arcade/docs/static/libs/corgio.png\"\n}"
    },
    "darts": {
      "README.md": "# Darts\n\nA small wrapper for projecting a path.",
      "darts.ts": "/**\n* A dart with path prediction\n*/\n//% weight=100 color=#6699CC icon=\"\\uf140\"\n//% groups='[\"Create\", \"Actions\", \"Properties\"]'\nnamespace darts {\n    /**\n     * Creates a new dart from an image and kind\n     * @param img the image for the sprite\n     * @param kind the kind to make the dart\n     * @param x optional initial x position, eg: 10\n     * @param y optional initial y position, eg: 110\n     */\n    //% blockId=dartsCreate block=\"dart %img=screen_image_picker of kind %kind=spritetype || at x %x y %y\"\n    //% expandableArgumentMode=toggle\n    //% inlineInputMode=inline\n    //% blockSetVariable=myDart\n    //% weight=100\n    //% group=\"Create\"\n    export function create(img: Image,\n                            kind: number,\n                            x: number = 10,\n                            y: number = 110): Dart {\n        return new Dart(img, kind, x, y);\n    }\n\n    /**\n     * Convert degrees to radians\n     * @param degree to convert\n     * @return converted value in radians\n     */\n    export function degreeToRadian(degree: number): number {\n        return degree * Math.PI / 180;\n    }\n\n    /**\n     * Evaluate the x component of a given vector\n     * @param degree angle of vector\n     * @param magnitude magnitude of vector\n     * @return x component of vector\n     */\n    export function xComponent(degree: number, magnitude: number): number {\n        return magnitude * Math.cos(degreeToRadian(degree));\n    }\n\n    /**\n     * Evaluate the y component of a given vector\n     * @param degree angle of vector\n     * @param magnitude magnitude of vector\n     * @return y component of vector\n     */\n    export function yComponent(degree: number, magnitude: number): number {\n        return -magnitude * Math.sin(degreeToRadian(degree));\n    }\n}\n\n/**\n * A dart\n **/\n//% blockNamespace=darts color=\"#6699CC\" blockGap=8\nclass Dart {\n    private dart: Sprite;\n    private bkgd: Image;\n\n    private controlKeys: boolean;\n    private trace: boolean;\n\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"angle\"\n    //% weight=8\n    public angle: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"power\"\n    //% weight=8\n    public pow: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"tracing time (seconds)\"\n    //% weight=8\n    public iter: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"trace color\"\n    //% weight=8\n    public traceColor: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"gravity\"\n    //% weight=8\n    public gravity: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"wind\"\n    //% weight=8\n    public wind: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"angle adjust rate\"\n    //% weight=8\n    public angleRate: number;\n    //% group=\"Properties\" blockSetVariable=\"myDart\"\n    //% blockCombine block=\"wind\"\n    //% weight=8\n    public powerRate: number;\n\n    public constructor(img: Image,\n                        kind: number,\n                        x: number,\n                        y: number) {\n        this.dart = sprites.create(img, kind);\n        this.dart.x = x;\n        this.dart.y = y;\n\n        this.gravity = 20;\n        this.pow = 50;\n        this.angle = 10;\n        this.angleRate = 1;\n        this.powerRate = 1;\n        this.iter = 3;\n        this.wind = 0;\n        this.bkgd = scene.backgroundImage();\n\n        this.controlKeys = false;\n        this.trace = false;\n        this.traceColor = 1;\n    }\n\n    /**\n     * Gets the dart's sprite\n     */\n    //% group=\"Properties\"\n    //% blockId=dartSprite block=\"%dart(myDart) sprite\"\n    //% weight=8\n    get sprite(): Sprite {\n        return this.dart;\n    }\n\n    /**\n     * Set whether to show the trace for the estimated path\n     * @param on whether to turn on or off this feature, eg: true\n     */\n    //% blockId=setTrace block=\"trace %dart(myDart) path estimate || %on=toggleOnOff\"\n    //% weight=50\n    //% group=\"Actions\"\n    public setTrace(on: boolean = true): void {\n        let __this: Dart = this;\n        this.trace = on;\n\n        game.onUpdateInterval(50, function () {\n            let newBkgd: Image = __this.bkgd.clone();\n            scene.setBackgroundImage(newBkgd);\n            if (!__this.dart.ay && __this.trace) {\n                let xComp = darts.xComponent(__this.angle, __this.pow);\n                let yComp = darts.yComponent(__this.angle, __this.pow);\n                let camera = game.currentScene().camera\n                let xOffset = camera.offsetX;\n                let yOffset = camera.offsetY;\n\n                for (let i: number = 0.1; i < __this.iter; i += i / 5) {\n                    let x = __this.dart.x + i * xComp + (i ** 2) * __this.wind / 2;\n                    let y = __this.dart.y + i * yComp + (i ** 2) * __this.gravity / 2;\n                    newBkgd.setPixel(x - xOffset,\n                                    y - yOffset,\n                                    __this.traceColor);\n                }\n            }\n        })\n    }\n\n    /**\n     * Throw the dart with the current settings\n     */\n    //% blockId=throwDart block=\"throw %dart(myDart)\"\n    //% weight=50\n    //% group=\"Actions\"\n    public throwDart(): void {\n        this.dart.vx = darts.xComponent(this.angle, this.pow);\n        this.dart.vy = darts.yComponent(this.angle, this.pow);\n        this.dart.ay = this.gravity;\n        this.dart.ax = this.wind;\n    }\n\n    /**\n     * Stop the dart at the current location\n     */\n    //% blockId=stopDart block=\"stop %dart(myDart)\"\n    //% weight=50\n    //% group=\"Actions\"\n    public stopDart(): void {\n        this.dart.ay = 0;\n        this.dart.ax = 0;\n        this.dart.vx = 0;\n        this.dart.vy = 0;\n    }\n\n    /**\n     * Set whether to control the dart with the arrow keys; left and right\n     * to adjust the angle, and up and down to increase / decrease power\n     * @param on whether to turn on or off this feature, eg: true\n     */\n    //% blockId=controlKeys block=\"control %dart(myDart) with arrow keys || %on=toggleOnOff\"\n    //% weight=50\n    //% group=\"Actions\"\n    public controlWithArrowKeys(on: boolean = true): void {\n        let __this: Dart = this;\n        this.controlKeys = on;\n\n        game.onUpdate(function () {\n            if (__this.controlKeys) {\n                __this.angle -= controller.dx() * __this.angleRate / 5;\n                __this.pow -= controller.dy() * __this.powerRate / 5;\n            }\n        })\n    }\n\n    /**\n     * Update background image to new image so dart can continue to trace\n     */\n    //% blockId=updateBackground block=\"change %dart(myDart) background to image %img=background_image_picker\"\n    //% weight=15\n    //% group=\"Properties\"\n    public updateBackground(img: Image): void {\n        this.bkgd = img;\n    }\n}",
      "pxt.json": "{\n    \"name\": \"darts\",\n    \"description\": \"A sprite with path projection\",\n    \"files\": [\n        \"README.md\",\n        \"darts.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"game\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    },\n    \"icon\": \"/arcade/docs/static/libs/darts.png\"\n}"
    },
    "hw": {
      "config.ts": "namespace config {\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 120;\n}\n",
      "pxt.json": "{\n    \"name\": \"hw\",\n    \"description\": \"Hardware definition - web-browser only\",\n    \"files\": [\n        \"config.ts\"\n    ],\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"screen\": \"*\",\n        \"controller\": \"*\",\n        \"music\": \"*\",\n        \"game\": \"*\",\n        \"jacdac\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}"
    },
    "hw---rpi": {
      "config.ts": "\nnamespace config {\n    export const PIN_LED = DAL.PC_8;\n\n    export const PIN_SCK = DAL.PA_5;\n    export const PIN_MISO = DAL.PA_6;\n    export const PIN_MOSI = DAL.PA_7;\n\n    export const PIN_RX = DAL.PA_10;\n    export const PIN_TX = DAL.PA_9;\n\n    export const PIN_SDA = DAL.PB_7;\n    export const PIN_SCL = DAL.PB_6;\n\n    export const PIN_D14 = DAL.PB_9;\n    export const PIN_D15 = DAL.PB_8;\n\n    export const PIN_BTN_LEFT = DAL.PB_10;\n    export const PIN_BTN_UP = DAL.PA_15;\n    export const PIN_BTN_RIGHT = DAL.PA_5;\n    export const PIN_BTN_DOWN = DAL.PC_13;\n\n    export const PIN_BTN_A = PIN_SDA;\n    export const PIN_BTN_B = PIN_SCL;\n    export const PIN_BTN_MENU = PIN_RX;\n\n    export const PIN_DISPLAY_CS = DAL.PB_12;\n    export const PIN_DISPLAY_SCK = DAL.PB_13;\n    export const PIN_DISPLAY_MOSI = DAL.PB_15;\n    export const PIN_DISPLAY_DC = DAL.PC_5;\n    export const PIN_DISPLAY_RST = DAL.PC_4;\n    export const PIN_DISPLAY_MISO = DAL.PB_14;\n    export const PIN_DISPLAY_BL = DAL.PA_4;\n\n    // it's really piezo speaker, not an amp\n    export const PIN_SPEAKER_AMP = DAL.PB_8;\n\n    export const DISPLAY_CFG0 = 0x00000080;\n    export const DISPLAY_CFG1 = 0x000603;\n\n    export const DISPLAY_CFG2 = 22; // MHz\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 120;\n}\n",
      "device.d.ts": "declare namespace input {\n}\n\ndeclare namespace control {\n    //% shim=control::programList\n    function programList() : string[];\n}",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Key {\n    LEFT = 1,\n    UP = 2,\n    RIGHT = 3,\n    DOWN = 4,\n    A = 5,\n    B = 6,\n    MENU = 7,\n    RESET = 8,\n    EXIT = 9,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "gamesel.cpp": "#include \"pxt.h\"\r\n\r\n#include <sys/types.h>\r\n#include <dirent.h>\r\n#include <sys/stat.h>\r\n#include <stdio.h>\r\n\r\nnamespace control {\r\n\r\n#define PROGDIR \"/sd/prj\"\r\n\r\n//%\r\nRefCollection *programList() {\r\n    DIR *d = opendir(PROGDIR);\r\n    auto res = Array_::mk();\r\n    for (;;) {\r\n        struct dirent *ent = readdir(d);\r\n        if (!ent)\r\n            break;\r\n        int len = strlen(ent->d_name);\r\n        if (len <= 4)\r\n            continue;\r\n        if (strcmp(ent->d_name + len - 4, \".elf\") != 0)\r\n            continue;\r\n        ent->d_name[len - 4] = 0; // chop extension\r\n        //DMESG(\"add: '%s'\", ent->d_name);\r\n        res->push((TValue)mkString(ent->d_name, -1));\r\n    }\r\n    closedir(d);\r\n    return res;\r\n}\r\n\r\n/** Run specified user program. */\r\n//%\r\nvoid runProgram(String prog) {\r\n    char *p;\r\n    asprintf(&p, \"%s/%s.elf\", PROGDIR, prog->data);\r\n    initialArgv = new char*[3];\r\n    initialArgv[0] = p;\r\n    initialArgv[1] = (char*)\"--run\";\r\n    initialArgv[2] = 0;\r\n    target_reset();\r\n}\r\n\r\n} // namespace control\r\n",
      "keys.cpp": "#include \"pxt.h\"\r\n\r\n#include <wiringPi.h>\r\n#include <wiringPiI2C.h>\r\n#include <pthread.h>\r\n\r\nnamespace music {\r\nvoid playTone(int frequency, int ms);\r\n}\r\n\r\nnamespace pxt {\r\n\r\nstatic uint64_t configuredPins;\r\n\r\nenum class Key {\r\n    LEFT = 1,\r\n    UP,\r\n    RIGHT,\r\n    DOWN,\r\n    A,\r\n    B,\r\n    MENU,\r\n    RESET,\r\n    EXIT,\r\n};\r\n\r\n/*\r\nBTN_A = 12, 16\r\nBTN_B = 6, 13\r\nBTN_MENU = 20\r\nBTN_EXIT = 22, 23\r\nBTN_RESTART = 26\r\nJOYSTICK_ADDR = 0x48\r\n# Free pins: 4, 5, 17, 24, 25, 27\r\n*/\r\n\r\nconst int INTERNAL_KEY_UP = 2050;\r\nconst int INTERNAL_KEY_DOWN = 2051;\r\n\r\nstatic int adcFD;\r\n\r\n#define SWAP(v) (uint16_t)((v >> 8) | (v << 8))\r\n#define MID 0x3300\r\n#define DEAD 0x1000\r\n\r\n\r\nstatic int readADC(int channel) {\r\n    if (!adcFD) {\r\n        int addr = getConfigInt(\"JOYSTICK_ADDR\", -1);\r\n        if (addr < 0)\r\n            adcFD = -1;\r\n        else\r\n            adcFD = wiringPiI2CSetup(0x48);\r\n    }\r\n\r\n    if (adcFD < 0)\r\n        return MID;\r\n\r\n    uint16_t config = 0x8383;\r\n    config += 0x4000 + 0x1000 * channel;\r\n\r\n    wiringPiI2CWriteReg16(adcFD, 0x01, SWAP(config));\r\n    sleep_core_us(1000);\r\n\r\n    config = wiringPiI2CReadReg16(adcFD, 0x00);\r\n    return SWAP(config);\r\n}\r\n\r\n#define SET(s) r |= 1 << (int)(Key::s)\r\n#define KEY(s)                                                                                 \\\r\n    if (isPressed(\"BTN_\" #s))                                                                                   \\\r\n    SET(s)\r\n\r\nstatic int isPressed(const char *name) {\r\n    auto pins = getConfigInts(name);\r\n    for (int i = 0; pins[i] != ENDMARK; ++i) {\r\n        auto p = pins[i];\r\n        auto mask = 1ULL << p;\r\n        if (!(configuredPins & mask)) {\r\n            pinMode(p, INPUT);\r\n            pullUpDnControl(p, PUD_UP);\r\n            configuredPins |= mask;\r\n        }\r\n        if (!digitalRead(p))\r\n            return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic uint32_t readBtns() {\r\n    uint32_t r = 0;\r\n\r\n    KEY(A);\r\n    KEY(B);\r\n    KEY(LEFT);\r\n    KEY(RIGHT);\r\n    KEY(UP);\r\n    KEY(DOWN);\r\n    KEY(MENU);\r\n    KEY(EXIT);\r\n    KEY(RESET);\r\n    \r\n    uint16_t ch0 = readADC(0), ch1 = readADC(1);\r\n\r\n    if (ch0 < MID - DEAD)\r\n        SET(UP);\r\n    if (ch0 > MID + DEAD)\r\n        SET(DOWN);\r\n\r\n    if (ch1 < MID - DEAD)\r\n        SET(LEFT);\r\n    if (ch1 > MID + DEAD)\r\n        SET(RIGHT);\r\n\r\n    return r;\r\n}\r\n\r\nstatic void *btnPoll(void *dummy) {\r\n    (void)dummy;\r\n\r\n    uint32_t state = readBtns();\r\n    int k = 0;\r\n    while (1) {\r\n        sleep_core_us(5000);\r\n        uint32_t nstate = readBtns();\r\n\r\n        if (k++ % 30 == 0) {\r\n            // DMESG(\"CH0 %p CH1 %p\", readADC(0), readADC(1));\r\n        }\r\n\r\n        if (state != nstate) {\r\n            for (int i = 1; i < 32; ++i) {\r\n                uint32_t mask = 1 << i;\r\n                int ev = 0;\r\n                if ((state & mask) && !(nstate & mask))\r\n                    ev = INTERNAL_KEY_UP;\r\n                else if (!(state & mask) && (nstate & mask)) {\r\n                    ev = INTERNAL_KEY_DOWN;\r\n                    if (i == (int)Key::EXIT)\r\n                        target_exit();\r\n                    else if (i == (int)Key::RESET)\r\n                        target_reset();\r\n                }\r\n                if (ev) {\r\n                    // DMESG(\"evt: %d at %d\", ev, i);\r\n                    raiseEvent(ev, i);\r\n                    raiseEvent(ev, 0); // any key\r\n                }\r\n            }\r\n            state = nstate;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\nvoid initKeys() {\r\n    DMESG(\"init keys\");\r\n    music::playTone(0, 0); // start music process early\r\n\r\n    wiringPiSetupGpio();\r\n\r\n    pthread_t disp;\r\n    pthread_create(&disp, NULL, btnPoll, NULL);\r\n    pthread_detach(disp);\r\n}\r\n\r\n} // namespace pxt\r\n",
      "pxt.json": "{\n    \"name\": \"hw---rpi\",\n    \"description\": \"Raspberry Pi\",\n    \"files\": [\n        \"keys.cpp\",\n        \"config.ts\",\n        \"gamesel.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"device.d.ts\"\n    ],\n    \"card\": {\n        \"name\": \"Raspberry Pi Zero\",\n        \"description\": \"Custom piCore Linux image running on a Pi. Play your games on a BIG screen!\",\n        \"learnMoreUrl\": \"https://arcade.makecode.com/rpi\",\n        \"buyUrl\": \"https://www.adafruit.com/product/3464\",\n        \"cardType\": \"hw\",\n        \"imageUrl\": \"/static/boards/rpi.jpg\"\n    },\n    \"compileServiceVariant\": \"rpi\",\n    \"dependencies\": {\n        \"core---linux\": \"*\",\n        \"music---linux\": \"*\",\n        \"screen---linux\": \"*\",\n        \"game\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace control {\n\n    /** Run specified user program. */\n    //% shim=control::runProgram\n    function runProgram(prog: string): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
    },
    "hw---stm32f401": {
      "config.ts": "\nnamespace config {\n    export const PIN_LED = DAL.PC_8;\n\n    export const PIN_SCK = DAL.PA_5;\n    export const PIN_MISO = DAL.PA_6;\n    export const PIN_MOSI = DAL.PA_7;\n\n    export const PIN_RX = DAL.PA_10;\n    export const PIN_TX = DAL.PA_9;\n\n    export const PIN_SDA = DAL.PB_7;\n    export const PIN_SCL = DAL.PB_6;\n\n    export const PIN_JACDAC = DAL.PA_9;\n\n    export const PIN_D14 = DAL.PB_9;\n    export const PIN_D15 = DAL.PB_8;\n\n    export const PIN_BTN_LEFT = DAL.PB_10;\n    export const PIN_BTN_UP = DAL.PA_15;\n    export const PIN_BTN_RIGHT = DAL.PA_5;\n    export const PIN_BTN_DOWN = DAL.PC_13;\n\n    export const PIN_BTN_A = PIN_SDA;\n    export const PIN_BTN_B = PIN_SCL;\n    export const PIN_BTN_MENU = PIN_RX;\n\n    export const PIN_DISPLAY_CS = DAL.PB_12;\n    export const PIN_DISPLAY_SCK = DAL.PB_13;\n    export const PIN_DISPLAY_MOSI = DAL.PB_15;\n    export const PIN_DISPLAY_DC = DAL.PC_5;\n    export const PIN_DISPLAY_RST = DAL.PC_4;\n    export const PIN_DISPLAY_MISO = DAL.PB_14;\n    export const PIN_DISPLAY_BL = DAL.PA_4;\n    \n    // it's really piezo speaker, not an amp\n    export const PIN_SPEAKER_AMP = DAL.PB_8;\n\n    export const DISPLAY_CFG0 = 0x00000080;\n    export const DISPLAY_CFG1 = 0x000603;\n\n    export const DISPLAY_CFG2 = 22; // MHz\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 128;\n}\n",
      "device.d.ts": "// TODO remove pins?\ndeclare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_LED)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SDA)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCL)\n    const SCL: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCK)\n    const SCK: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MISO)\n    const MISO: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MOSI)\n    const MOSI: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_RX)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_TX)\n    const TX: DigitalInOutPin;\n}\n\ndeclare namespace input {\n    //% block=\"button A\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_A,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonA: Button;\n    //% block=\"button B\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_B,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonB: Button;\n    //% block=\"button Left\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_LEFT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonLeft: Button;\n    //% block=\"button Right\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_RIGHT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonRight: Button;\n\n    //% block=\"button Up\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_UP,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonUp: Button;\n    //% block=\"button Down\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_DOWN,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonDown: Button;\n\n    //% block=\"button Menu\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_MENU,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonMenu: Button;\n}\n",
      "pxt.json": "{\n    \"name\": \"hw---stm32f401\",\n    \"description\": \"STM32F401 board\",\n    \"files\": [\n        \"config.ts\",\n        \"device.d.ts\"\n    ],\n    \"card\": {\n        \"name\": \"STM32F401 board\",\n        \"description\": \"Just a generic board, no branding yet.\",\n        \"learnMoreUrl\": \"https://arcade.makecode.com/stm32f401\",\n        \"cardType\": \"hw\",\n        \"imageUrl\": \"/static/boards/stm.jpg\"\n    },\n    \"compileServiceVariant\": \"stm32f401\",\n    \"dependencies\": {\n        \"core---stm32f401re\": \"*\",\n        \"screen---st7735\": \"*\",\n        \"music---pwm\": \"*\",\n        \"controller---hw\": \"*\",\n        \"buttons\": \"*\",\n        \"game\": \"*\",\n        \"jacdac\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}"
    },
    "hw---samd51": {
      "config.ts": "\nnamespace config {\n    export const PIN_LED = DAL.PA22;\n\n    export const PIN_SCK = DAL.PA01;\n    export const PIN_MISO = DAL.PB23;\n    export const PIN_MOSI = DAL.PA00;\n\n    export const PIN_SDA = DAL.PA12;\n    export const PIN_SCL = DAL.PA13;\n\n    export const PIN_A0 = DAL.PA02;\n    export const PIN_A1 = DAL.PA05;\n\n    export const PIN_A2 = DAL.PB08;\n    export const PIN_A3 = DAL.PB09;\n    export const PIN_A4 = DAL.PA04;\n    export const PIN_A5 = DAL.PA06;\n    export const PIN_RX = DAL.PA16;\n    export const PIN_TX = DAL.PA17;\n    export const PIN_D2 = DAL.PA07;\n    export const PIN_D3 = DAL.PB22;\n    export const PIN_D4 = DAL.PA14;\n    export const PIN_D5 = DAL.PA15; // ???\n    export const PIN_D7 = DAL.PA18;\n    export const PIN_D9 = DAL.PA19;\n    export const PIN_D10 = DAL.PA20;\n    export const PIN_D11 = DAL.PA21;\n    export const PIN_D12 = DAL.PA23;\n\n    export const PIN_BTN_LEFT = PIN_D11;\n    export const PIN_BTN_UP = PIN_D10;\n    export const PIN_BTN_RIGHT = PIN_D9;\n    export const PIN_BTN_DOWN = PIN_D12;\n\n    export const PIN_BTN_A = PIN_SCL;\n    export const PIN_BTN_B = PIN_D7;\n    export const PIN_BTN_MENU = PIN_SDA;\n\n    export const PIN_DISPLAY_CS = PIN_A2;\n    export const PIN_DISPLAY_SCK = PIN_SCK;\n    export const PIN_DISPLAY_MOSI = PIN_MOSI;\n    export const PIN_DISPLAY_DC = PIN_A3;\n    export const PIN_DISPLAY_RST = PIN_A4;\n    export const PIN_DISPLAY_MISO = PIN_MISO;\n    export const PIN_DISPLAY_BL = PIN_A5;\n\n    // it's really piezo speaker, not an amp\n    export const PIN_SPEAKER_AMP = PIN_D2;\n    export const SPEAKER_VOLUME = 512;\n    \n    export const DISPLAY_CFG0 = 0x00000090;\n    export const DISPLAY_CFG1 = 0x000e14ff;\n\n    //export const DISPLAY_CFG0 = 0x01000080;\n    //export const DISPLAY_CFG1 = 0x00000603;\n\n    export const DISPLAY_CFG2 = 24; // MHz\n    export const DISPLAY_WIDTH = 160;\n    export const DISPLAY_HEIGHT = 128;\n\n    // TODO: JACDAC pin\n}\n",
      "device.d.ts": "// TODO remove pins?\ndeclare namespace pins {\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_LED)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SDA)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCL)\n    const SCL: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_SCK)\n    const SCK: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MISO)\n    const MISO: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_MOSI)\n    const MOSI: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D2)\n    const D2: PwmOnlyPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D3)\n    const D3: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_D4)\n    const D4: PwmOnlyPin;\n\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_RX)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPinCfg(CFG_PIN_TX)\n    const TX: DigitalInOutPin;\n}\n\ndeclare namespace input {\n    //% block=\"button A\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_A,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonA: Button;\n    //% block=\"button B\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_B,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonB: Button;\n    //% block=\"button Left\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_LEFT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonLeft: Button;\n    //% block=\"button Right\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_RIGHT,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonRight: Button;\n\n    //% block=\"button Up\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_UP,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonUp: Button;\n    //% block=\"button Down\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_DOWN,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonDown: Button;\n\n    //% block=\"button Menu\" fixedInstance\n    //% shim=pxt::getButtonByPinCfg(CFG_PIN_BTN_MENU,BUTTON_ACTIVE_LOW_PULL_UP)\n    const buttonMenu: Button;\n}\n",
      "pxt.json": "{\n    \"name\": \"hw---samd51\",\n    \"description\": \"SAMD51 board\",\n    \"files\": [\n        \"config.ts\",\n        \"device.d.ts\"\n    ],\n    \"card\": {\n        \"name\": \"SAMD51 board\",\n        \"description\": \"Just a generic board, no branding yet.\",\n        \"learnMoreUrl\": \"https://arcade.makecode.com/samd51\",\n        \"cardType\": \"hw\",\n        \"imageUrl\": \"/static/boards/samd.jpg\"\n    },\n    \"compileServiceVariant\": \"samd51\",\n    \"dependencies\": {\n        \"core---samd51\": \"*\",\n        \"screen---st7735\": \"*\",\n        \"music---pwm\": \"*\",\n        \"controller---hw\": \"*\",\n        \"buttons\": \"*\",\n        \"game\": \"*\",\n        \"jacdac\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}"
    },
    "screen": {
      "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% weight=100 group=\"Create\"\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n}",
      "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
      "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage)\n\nvoid RefImage::destroy(RefImage *t) {\n    decrRC(t->buffer());\n}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p r=%d size=%d x %d\", t, REFCNT(t), t->width(), t->height());\n}\n\nint RefImage::width() {\n    return data()[1];\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((data()[2] * bpp() + 31) >> 5);\n}\n\nint RefImage::byteHeight() {\n    if (bpp() == 1)\n        return (data()[2] + 7) >> 3;\n    else if (bpp() == 4)\n        return ((data()[2] * 4 + 31) >> 5) << 2;\n    else {\n        oops(21);\n        return -1;\n    }\n}\n\nint RefImage::bpp() {\n    return data()[0] & 0xf;\n}\n\nint RefImage::height() {\n    return data()[2];\n}\n\nvoid RefImage::makeWritable() {\n    if (hasBuffer()) {\n        if (buffer()->isReadOnly()) {\n            auto b = mkBuffer(data(), length());\n            decrRC(buffer());\n            _buffer = (uintptr_t)b;\n        }\n    } else {\n        _buffer |= 2;\n    }\n}\n\nuint8_t *RefImage::pix(int x, int y) {\n    uint8_t *d = &data()[4 + byteHeight() * x];\n    if (y) {\n        if (bpp() == 1)\n            d += y >> 3;\n        else if (bpp() == 4)\n            d += y >> 1;\n    }\n    return d;\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), _buffer((uintptr_t)buf) {\n    incrRC(buf);\n}\nRefImage::RefImage(uint32_t sz) : PXT_VTABLE_INIT(RefImage), _buffer((sz << 2) | 3) {}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return 4 + ((h + 7) >> 3) * w;\n    else\n        return 4 + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 255 || height > 255)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    auto d = r->data();\n    d[0] = 0xe0 | bpp;\n    d[1] = width;\n    d[2] = height;\n    d[3] = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True iff the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic inline void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    }\n}\n\nstatic inline int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    uint32_t sz = img->length();\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    memcpy(r->data(), img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    img->makeWritable();\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    Image_ r = doubledY(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    //DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\", \n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n    #define LOOPHD for (int xx = 0; xx < w; ++xx, ++x) if (0 <= x && x < sw)\n\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n                y = y0;\n\n                auto fdata = (uint32_t*)fromBase + wordH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                //DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n                //    (uint8_t*)fdata - from->pix());\n\n                auto cnt = wordH;\n                auto bot = min(sh, y + h);\n\n                #define COLS(s) ((v >> (s)) & 0xf)\n                #define COL(s) COLS(s)\n                \n                #define STEPA(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETLOW(s); \\\n                    y++; \n                #define STEPB(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETHIGH(s); \\\n                    y++; tdata++;\n                 #define STEPAQ(s)  \\\n                    if (COL(s)) SETLOW(s); \n                #define STEPBQ(s)  \\\n                    if (COL(s)) SETHIGH(s); \\\n                    tdata++;\n\n                // perf: expanded version 5% faster\n                #define ORDER(A,B) A(0); B(4); A(8); B(12); A(16); B(20); A(24); B(28)\n                //#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n                #define LOOP(A,B,xbot) while (cnt--) { \\\n                            auto v = *fdata++; \\\n                            if (0 <= y && y <= xbot - 8) { \\\n                                ORDER(A ## Q,  B ## Q); \\\n                                y += 8; \\\n                            } else { \\\n                                ORDER(A, B); \\\n                            } \\\n                        }\n                #define LOOPS(xbot) if (y & 1) \\\n                        LOOP(STEPB, STEPA, xbot) \\\n                    else \\\n                        LOOP(STEPA, STEPB, xbot)\n\n                if (color >= 0) {\n                #define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n                #define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                    LOOPS(sh)\n                } else if (color == -2) {\n                    #undef COL\n                    #define COL(s) 1\n                    LOOPS(bot)\n                } else {\n                    #undef COL\n                    #define COL(s) COLS(s)\n                    #undef SETHIGH\n                    #define SETHIGH(s) if(*tdata & 0xf0) return true\n                    #undef SETLOW\n                    #define SETLOW(s) if(*tdata & 0x0f) return true\n                    LOOPS(sh)\n                }\n    } }\n    else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n                y = y0;\n\n\n                auto data = fromBase + fromH * xx;\n                auto off = imgBase + imgH * x;\n                auto off0 = off + left;\n                auto off1 = off + right;\n\n                int shift = (y & 7);\n\n                int y1 = y + h + (y & 7);\n                int prev = 0;\n\n                while (y < y1 - 8) {\n                    int curr = *data++ << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = (curr >> 0) | (prev >> 8);\n\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                    off++;\n                    prev = curr;\n                    y += 8;\n                }\n\n                int left = y1 - y; \n                if (left > 0) {\n                    int curr = *data << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                }\n        }\n        }\n        else if (tbp == 4 && fbp == 1)  {\n            if (y < 0) {\n                fromBase = from->pix(0, -y);\n                imgBase = img->pix();\n            }\n                // icon mode\n            LOOPHD {\n                auto fdata = fromBase + fromH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                unsigned mask = 0x01;\n                auto v = *fdata++;\n                int off = (y & 1) ? 1 : 0;\n                if (y < 0) {\n                    mask <<= -y & 7;\n                    off = 0;\n                }\n                for (int i = off; i < len+off; ++i) {\n                    if (mask == 0x100) {\n                        mask = 0x01;\n                        v = *fdata++;\n                    }\n                    if (v & mask) {\n                        if (i & 1)\n                            *tdata = (*tdata & 0x0f) | (color << 4);\n                        else\n                            *tdata = (*tdata & 0xf0) | color;\n                    }\n                    mask <<= 1;\n                    if (i & 1)\n                        tdata++;\n                }\n            }\n        }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format:\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    if (!isValidImage(icon) || icon->data[0] != 0xe1)\n        return;\n\n    img->makeWritable();\n    auto ii = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    drawImageCore(img, ii, XX(xy), YY(xy), c);\n    decrRC(ii);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    if (!isValidImage(buf))\n        return NULL;\n    return new (gcAllocate(sizeof(RefImage))) RefImage(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    auto t = ImageMethods::doubled(r);\n    auto res = mkBuffer(t->data(), t->length());\n    decrRC(r);\n    decrRC(t);\n\n    return res;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif",
      "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
      "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n}\n",
      "ns.ts": "\n//% color=\"#a5b1c2\"\nnamespace images {\n\n}",
      "pxt.json": "{\n    \"name\": \"screen\",\n    \"description\": \"The screen library\",\n    \"files\": [\n        \"screen.cpp\",\n        \"image.cpp\",\n        \"image.ts\",\n        \"text.ts\",\n        \"frame.ts\",\n        \"shims.d.ts\",\n        \"fieldeditors.ts\",\n        \"targetoverrides.ts\",\n        \"ns.ts\",\n        \"image.d.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "screen.cpp": "// overriden in targets",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True iff the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(160, 120)\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
      "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        doubledCache?: Font;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 8,\n        charHeight: 8,\n        // source https://github.com/dhepper/font8x8\n        data: hex`\n20000000000000000000 21000000065f5f060000 22000003030003030000 2300147f7f147f7f1400 2400242e6b6b3a120000\n2500466630180c666200 2600307a4f5d377a4800 27000407030000000000 2800001c3e6341000000 29000041633e1c000000\n2a00082a3e1c1c3e2a08 2b0008083e3e08080000 2c000080e06000000000 2d000808080808080000 2e000000606000000000\n2f006030180c06030100 30003e7f71594d7f3e00 310040427f7f40400000 3200627359496f660000 3300226349497f360000\n3400181c16537f7f5000 3500276745457d390000 36003c7e4b4979300000 3700030371790f070000 3800367f49497f360000\n3900064f49693f1e0000 3a000000666600000000 3b000080e66600000000 3c00081c366341000000 3d002424242424240000\n3e00004163361c080000 3f00020351590f060000 40003e7f415d5d1f1e00 41007c7e13137e7c0000 4200417f7f49497f3600\n43001c3e634141632200 4400417f7f41633e1c00 4500417f7f495d416300 4600417f7f491d010300 47001c3e634151737200\n48007f7f08087f7f0000 490000417f7f41000000 4a00307040417f3f0100 4b00417f7f081c776300 4c00417f7f4140607000\n4d007f7f0e1c0e7f7f00 4e007f7f060c187f7f00 4f001c3e6341633e1c00 5000417f7f49090f0600 51001e3f21717f5e0000\n5200417f7f09197f6600 5300266f4d5973320000 540003417f7f41030000 55007f7f40407f7f0000 56001f3f60603f1f0000\n57007f7f3018307f7f00 580043673c183c674300 5900074f78784f070000 5a00476371594d677300 5b00007f7f4141000000\n5c000103060c18306000 5d000041417f7f000000 5e00080c0603060c0800 5f008080808080808080 60000000030704000000\n6100207454543c784000 6200417f3f4848783000 6300387c44446c280000 6400307848493f7f4000 6500387c54545c180000\n6600487e7f4903020000 670098bca4a4f87c0400 6800417f7f08047c7800 690000447d7d40000000 6a0060e08080fd7d0000\n6b00417f7f10386c4400 6c0000417f7f40000000 6d007c7c18381c7c7800 6e007c7c04047c780000 6f00387c44447c380000\n700084fcf8a4243c1800 7100183c24a4f8fc8400 7200447c784c041c1800 7300485c545474240000 740000043e7f44240000\n75003c7c40403c7c4000 76001c3c60603c1c0000 77003c7c7038707c3c00 7800446c3810386c4400 79009cbca0a0fc7c0000\n7a004c64745c4c640000 7b0008083e7741410000 7c000000007777000000 7d004141773e08080000 7e000203010302030100\n7f000000000000000000\n`\n    }\n\n    export function doubledFont(f: Font): Font {\n        if (f.doubledCache) return f.doubledCache\n        let byteHeight = (f.charHeight + 7) >> 3\n        let sz = f.charWidth * byteHeight\n        let numChars = f.data.length / (sz + 2)\n        let newByteHeight = ((f.charHeight * 2) + 7) >> 3\n        let nsz = f.charWidth * 2 * newByteHeight\n        let data = control.createBuffer((nsz + 2) * numChars)\n        let tmp = control.createBuffer(4 + sz)\n        tmp[0] = 0xe1\n        tmp[1] = f.charWidth\n        tmp[2] = f.charHeight\n        let dst = 0\n        for (let i = 0; i < f.data.length; i += 2 + sz) {\n            tmp.write(4, f.data.slice(i + 2, sz))\n            let dbl = image.doubledIcon(tmp).slice(4)\n            data[dst] = f.data[i]\n            data[dst + 1] = f.data[i + 1]\n            data.write(dst + 2, dbl)\n            dst += 2 + dbl.length\n        }\n        f.doubledCache = {\n            charWidth: f.charWidth * 2,\n            charHeight: f.charHeight * 2,\n            data: data\n        }\n        return f.doubledCache\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.font8\n        let w = text.length * font.charWidth\n        let x = (screen.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font) {\n        x |= 0\n        y |= 0\n        if (!font) font = image.font8\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let byteHeight = (font.charHeight + 7) >> 3\n        let charSize = byteHeight * font.charWidth\n        let imgBuf = control.createBuffer(4 + charSize)\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        imgBuf[0] = 0xe1\n        imgBuf[1] = font.charWidth\n        imgBuf[2] = font.charHeight\n        while (cp < text.length) {\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            // decompose Korean characters\n            let arr = [ch]\n            if (44032 <= ch && ch <= 55203) {\n                ch -= 44032\n                arr = [\n                    Math.idiv(ch, 588) + 0x1100,\n                    (Math.idiv(ch, 28) % 21) + 0x1161,\n                ]\n                ch %= 28\n                if (ch)\n                    arr.push(ch % 28 + 0x11a7)\n            }\n\n            for (let cc of arr) {\n                let l = 0\n                let r = lastchar\n                let off = 0 // this should be a space (0x0020)\n                let guess = (ch - 32) * dataSize\n                if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == cc)\n                    off = guess\n                else {\n                    while (l <= r) {\n                        let m = l + ((r - l) >> 1);\n                        let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                        if (v == cc) {\n                            off = m * dataSize\n                            break\n                        }\n                        if (v < cc)\n                            l = m + 1\n                        else\n                            r = m - 1\n                    }\n                }\n\n                imgBuf.write(4, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x, y, color)\n                x += font.charWidth\n            }\n        }\n    }\n}\n"
    },
    "screen---st7735": {
      "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% weight=100 group=\"Create\"\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n}",
      "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
      "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage)\n\nvoid RefImage::destroy(RefImage *t) {\n    decrRC(t->buffer());\n}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p r=%d size=%d x %d\", t, REFCNT(t), t->width(), t->height());\n}\n\nint RefImage::width() {\n    return data()[1];\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((data()[2] * bpp() + 31) >> 5);\n}\n\nint RefImage::byteHeight() {\n    if (bpp() == 1)\n        return (data()[2] + 7) >> 3;\n    else if (bpp() == 4)\n        return ((data()[2] * 4 + 31) >> 5) << 2;\n    else {\n        oops(21);\n        return -1;\n    }\n}\n\nint RefImage::bpp() {\n    return data()[0] & 0xf;\n}\n\nint RefImage::height() {\n    return data()[2];\n}\n\nvoid RefImage::makeWritable() {\n    if (hasBuffer()) {\n        if (buffer()->isReadOnly()) {\n            auto b = mkBuffer(data(), length());\n            decrRC(buffer());\n            _buffer = (uintptr_t)b;\n        }\n    } else {\n        _buffer |= 2;\n    }\n}\n\nuint8_t *RefImage::pix(int x, int y) {\n    uint8_t *d = &data()[4 + byteHeight() * x];\n    if (y) {\n        if (bpp() == 1)\n            d += y >> 3;\n        else if (bpp() == 4)\n            d += y >> 1;\n    }\n    return d;\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), _buffer((uintptr_t)buf) {\n    incrRC(buf);\n}\nRefImage::RefImage(uint32_t sz) : PXT_VTABLE_INIT(RefImage), _buffer((sz << 2) | 3) {}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return 4 + ((h + 7) >> 3) * w;\n    else\n        return 4 + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 255 || height > 255)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    auto d = r->data();\n    d[0] = 0xe0 | bpp;\n    d[1] = width;\n    d[2] = height;\n    d[3] = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True iff the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic inline void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    }\n}\n\nstatic inline int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    uint32_t sz = img->length();\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    memcpy(r->data(), img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    img->makeWritable();\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    Image_ r = doubledY(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    //DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\", \n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n    #define LOOPHD for (int xx = 0; xx < w; ++xx, ++x) if (0 <= x && x < sw)\n\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n                y = y0;\n\n                auto fdata = (uint32_t*)fromBase + wordH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                //DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n                //    (uint8_t*)fdata - from->pix());\n\n                auto cnt = wordH;\n                auto bot = min(sh, y + h);\n\n                #define COLS(s) ((v >> (s)) & 0xf)\n                #define COL(s) COLS(s)\n                \n                #define STEPA(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETLOW(s); \\\n                    y++; \n                #define STEPB(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETHIGH(s); \\\n                    y++; tdata++;\n                 #define STEPAQ(s)  \\\n                    if (COL(s)) SETLOW(s); \n                #define STEPBQ(s)  \\\n                    if (COL(s)) SETHIGH(s); \\\n                    tdata++;\n\n                // perf: expanded version 5% faster\n                #define ORDER(A,B) A(0); B(4); A(8); B(12); A(16); B(20); A(24); B(28)\n                //#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n                #define LOOP(A,B,xbot) while (cnt--) { \\\n                            auto v = *fdata++; \\\n                            if (0 <= y && y <= xbot - 8) { \\\n                                ORDER(A ## Q,  B ## Q); \\\n                                y += 8; \\\n                            } else { \\\n                                ORDER(A, B); \\\n                            } \\\n                        }\n                #define LOOPS(xbot) if (y & 1) \\\n                        LOOP(STEPB, STEPA, xbot) \\\n                    else \\\n                        LOOP(STEPA, STEPB, xbot)\n\n                if (color >= 0) {\n                #define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n                #define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                    LOOPS(sh)\n                } else if (color == -2) {\n                    #undef COL\n                    #define COL(s) 1\n                    LOOPS(bot)\n                } else {\n                    #undef COL\n                    #define COL(s) COLS(s)\n                    #undef SETHIGH\n                    #define SETHIGH(s) if(*tdata & 0xf0) return true\n                    #undef SETLOW\n                    #define SETLOW(s) if(*tdata & 0x0f) return true\n                    LOOPS(sh)\n                }\n    } }\n    else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n                y = y0;\n\n\n                auto data = fromBase + fromH * xx;\n                auto off = imgBase + imgH * x;\n                auto off0 = off + left;\n                auto off1 = off + right;\n\n                int shift = (y & 7);\n\n                int y1 = y + h + (y & 7);\n                int prev = 0;\n\n                while (y < y1 - 8) {\n                    int curr = *data++ << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = (curr >> 0) | (prev >> 8);\n\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                    off++;\n                    prev = curr;\n                    y += 8;\n                }\n\n                int left = y1 - y; \n                if (left > 0) {\n                    int curr = *data << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                }\n        }\n        }\n        else if (tbp == 4 && fbp == 1)  {\n            if (y < 0) {\n                fromBase = from->pix(0, -y);\n                imgBase = img->pix();\n            }\n                // icon mode\n            LOOPHD {\n                auto fdata = fromBase + fromH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                unsigned mask = 0x01;\n                auto v = *fdata++;\n                int off = (y & 1) ? 1 : 0;\n                if (y < 0) {\n                    mask <<= -y & 7;\n                    off = 0;\n                }\n                for (int i = off; i < len+off; ++i) {\n                    if (mask == 0x100) {\n                        mask = 0x01;\n                        v = *fdata++;\n                    }\n                    if (v & mask) {\n                        if (i & 1)\n                            *tdata = (*tdata & 0x0f) | (color << 4);\n                        else\n                            *tdata = (*tdata & 0xf0) | color;\n                    }\n                    mask <<= 1;\n                    if (i & 1)\n                        tdata++;\n                }\n            }\n        }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format:\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    if (!isValidImage(icon) || icon->data[0] != 0xe1)\n        return;\n\n    img->makeWritable();\n    auto ii = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    drawImageCore(img, ii, XX(xy), YY(xy), c);\n    decrRC(ii);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    if (!isValidImage(buf))\n        return NULL;\n    return new (gcAllocate(sizeof(RefImage))) RefImage(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    auto t = ImageMethods::doubled(r);\n    auto res = mkBuffer(t->data(), t->length());\n    decrRC(r);\n    decrRC(t);\n\n    return res;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif",
      "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
      "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n}\n",
      "ns.ts": " ",
      "pxt.json": "{\n    \"name\": \"screen---st7735\",\n    \"description\": \"The screen library\",\n    \"files\": [\n        \"screen.cpp\",\n        \"image.cpp\",\n        \"image.ts\",\n        \"text.ts\",\n        \"frame.ts\",\n        \"shims.d.ts\",\n        \"fieldeditors.ts\",\n        \"targetoverrides.ts\",\n        \"ns.ts\",\n        \"image.d.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "screen.cpp": "#include \"pxt.h\"\n#include \"ST7735.h\"\n\nnamespace pxt {\nclass WDisplay {\n  public:\n    CODAL_SPI spi;\n    ST7735 lcd;\n\n    uint32_t currPalette[16];\n    bool newPalette;\n\n    uint8_t *screenBuf;\n    Image_ lastImg;\n\n    int width, height;\n    uint32_t palXOR;\n\n    WDisplay()\n        : spi(*LOOKUP_PIN(DISPLAY_MOSI), *LOOKUP_PIN(DISPLAY_MISO), *LOOKUP_PIN(DISPLAY_SCK)),\n          lcd(spi, *LOOKUP_PIN(DISPLAY_CS), *LOOKUP_PIN(DISPLAY_DC)) {\n\n        auto rst = LOOKUP_PIN(DISPLAY_RST);\n        if (rst) {\n            rst->setDigitalValue(0);\n            fiber_sleep(20);\n            rst->setDigitalValue(1);\n            fiber_sleep(20);\n        }\n\n        auto bl = LOOKUP_PIN(DISPLAY_BL);\n        if (bl) {\n            bl->setDigitalValue(1);\n        }\n\n        uint32_t cfg0 = getConfig(CFG_DISPLAY_CFG0, 0x40);\n        uint32_t cfg2 = getConfig(CFG_DISPLAY_CFG2, 0x0);\n        uint32_t frmctr1 = getConfig(CFG_DISPLAY_CFG1, 0x000603);\n        palXOR = (cfg0 & 0x1000000) ? 0xffffff : 0x000000;\n        auto madctl = cfg0 & 0xff;\n        auto offX = (cfg0 >> 8) & 0xff;\n        auto offY = (cfg0 >> 16) & 0xff;\n        auto freq = (cfg2 & 0xff);\n        if (!freq)\n            freq = 15;\n\n        DMESG(\"configure screen: FRMCTR1=%p MADCTL=%p SPI at %dMHz\", frmctr1, madctl, freq);\n\n        spi.setFrequency(freq * 1000000);\n        spi.setMode(0);\n        lcd.init();\n        lcd.configure(madctl, frmctr1);\n        width = getConfig(CFG_DISPLAY_WIDTH, 160);\n        height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n        lcd.setAddrWindow(offX, offY, width, height);\n        DMESG(\"screen: %d x %d, off=%d,%d\", width, height, offX, offY);\n        screenBuf = new uint8_t[width * height / 2 + 20];\n        lastImg = NULL;\n    }\n};\n\nSINGLETON(WDisplay);\n\n//%\nvoid setPalette(Buffer buf) {\n    auto display = getWDisplay();\n    if (48 != buf->length)\n        target_panic(PANIC_SCREEN_ERROR);\n    for (int i = 0; i < 16; ++i) {\n        display->currPalette[i] =\n            (buf->data[i * 3] << 16) | (buf->data[i * 3 + 1] << 8) | (buf->data[i * 3 + 2] << 0);\n        display->currPalette[i] ^= display->palXOR;\n    }\n    display->newPalette = true;\n}\n\nstatic const uint8_t numbers[] = {\n    0x06, 0x09, 0x09, 0x09, 0x06, // 0\n    0x04, 0x06, 0x04, 0x04, 0x0e, // 1\n    0x07, 0x08, 0x06, 0x01, 0x0f, // 2\n    0x0f, 0x08, 0x04, 0x09, 0x06, // 3\n    0x0c, 0x0a, 0x09, 0x1f, 0x08, // 4\n    0x1f, 0x01, 0x0f, 0x10, 0x0f, // 5\n    0x08, 0x04, 0x0e, 0x11, 0x0e, // 6\n    0x1f, 0x08, 0x04, 0x02, 0x01, // 7\n    0x0e, 0x11, 0x0e, 0x11, 0x0e, // 8\n    0x0e, 0x11, 0x0e, 0x04, 0x02, // 9\n    0x11, 0x00, 0x0e, 0x1b, 0x11, // :(\n    // 0x11, 0x04, 0x04, 0x0a, 0x11, // :(\n};\n\nstatic void drawNumber(int idx, uint8_t *bmp, int x, int y, int hb) {\n    const uint8_t *src = &numbers[idx * 5];\n    y >>= 1;\n    auto mask = idx == 10 ? 0x22 : 0x11;\n    for (int i = 0; i < 5; i++) {\n        uint8_t ch = *src++;\n        for (int j = 0; j < 5; j++) {\n            if (ch & (1 << j)) {\n                for (int k = 0; k < 4; ++k) {\n                    auto p = bmp + (x + (j * 4) + k) * hb + (y + i * 2);\n                    *p++ = mask;\n                    *p++ = mask;\n                }\n            }\n        }\n    }\n}\n\nstatic void drawPanic(int code) {\n    auto display = getWDisplay();\n    auto hb = display->height >> 1;\n    auto ptr = display->screenBuf;\n    auto dw = display->width;\n\n    memset(ptr, 0, hb * dw);\n\n    drawNumber(10, ptr, 70, 20, hb);\n    int x = 50;\n    int y = 60;\n    drawNumber((code / 100) % 10, ptr, x, y, hb);\n    x += 24;\n    drawNumber((code / 10) % 10, ptr, x, y, hb);\n    x += 24;\n    drawNumber((code / 1) % 10, ptr, x, y, hb);\n    x += 24;\n\n    display->lcd.waitForSendDone();\n    display->lcd.sendIndexedImage(display->screenBuf, display->width, display->height, NULL);\n    display->lcd.waitForSendDone();\n}\n\nextern \"C\" void target_panic(int statusCode) {\n    DMESG(\"*** CODAL PANIC : [%d]\", statusCode);\n\n    drawPanic(statusCode);\n\n    target_disable_irq();\n\n    while (1) {\n    }\n}\n\n//%\nvoid updateScreen(Image_ img) {\n    auto display = getWDisplay();\n\n    if (img && img != display->lastImg) {\n        decrRC(display->lastImg);\n        incrRC(img);\n        display->lastImg = img;\n    }\n    img = display->lastImg;\n\n    if (img && img->isDirty()) {\n        if (img->bpp() != 4 || img->width() != display->width || img->height() != display->height)\n            target_panic(PANIC_SCREEN_ERROR);\n\n        img->clearDirty();\n        // DMESG(\"wait for done\");\n        display->lcd.waitForSendDone();\n\n        auto palette = display->currPalette;\n\n        if (display->newPalette) {\n            display->newPalette = false;\n        } else {\n            palette = NULL;\n        }\n\n        memcpy(display->screenBuf, img->pix(), img->pixLength());\n\n        // DMESG(\"send\");\n        display->lcd.sendIndexedImage(display->screenBuf, display->width, display->height, palette);\n    }\n}\n\n//%\nvoid updateStats(String msg) {\n    // ignore...\n}\n} // namespace pxt",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True iff the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"sprites._createImageShim\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(\n    control.getConfigValue(DAL.CFG_DISPLAY_WIDTH, 160), \n    control.getConfigValue(DAL.CFG_DISPLAY_HEIGHT, 128))\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
      "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        doubledCache?: Font;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 8,\n        charHeight: 8,\n        // source https://github.com/dhepper/font8x8\n        data: hex`\n20000000000000000000 21000000065f5f060000 22000003030003030000 2300147f7f147f7f1400 2400242e6b6b3a120000\n2500466630180c666200 2600307a4f5d377a4800 27000407030000000000 2800001c3e6341000000 29000041633e1c000000\n2a00082a3e1c1c3e2a08 2b0008083e3e08080000 2c000080e06000000000 2d000808080808080000 2e000000606000000000\n2f006030180c06030100 30003e7f71594d7f3e00 310040427f7f40400000 3200627359496f660000 3300226349497f360000\n3400181c16537f7f5000 3500276745457d390000 36003c7e4b4979300000 3700030371790f070000 3800367f49497f360000\n3900064f49693f1e0000 3a000000666600000000 3b000080e66600000000 3c00081c366341000000 3d002424242424240000\n3e00004163361c080000 3f00020351590f060000 40003e7f415d5d1f1e00 41007c7e13137e7c0000 4200417f7f49497f3600\n43001c3e634141632200 4400417f7f41633e1c00 4500417f7f495d416300 4600417f7f491d010300 47001c3e634151737200\n48007f7f08087f7f0000 490000417f7f41000000 4a00307040417f3f0100 4b00417f7f081c776300 4c00417f7f4140607000\n4d007f7f0e1c0e7f7f00 4e007f7f060c187f7f00 4f001c3e6341633e1c00 5000417f7f49090f0600 51001e3f21717f5e0000\n5200417f7f09197f6600 5300266f4d5973320000 540003417f7f41030000 55007f7f40407f7f0000 56001f3f60603f1f0000\n57007f7f3018307f7f00 580043673c183c674300 5900074f78784f070000 5a00476371594d677300 5b00007f7f4141000000\n5c000103060c18306000 5d000041417f7f000000 5e00080c0603060c0800 5f008080808080808080 60000000030704000000\n6100207454543c784000 6200417f3f4848783000 6300387c44446c280000 6400307848493f7f4000 6500387c54545c180000\n6600487e7f4903020000 670098bca4a4f87c0400 6800417f7f08047c7800 690000447d7d40000000 6a0060e08080fd7d0000\n6b00417f7f10386c4400 6c0000417f7f40000000 6d007c7c18381c7c7800 6e007c7c04047c780000 6f00387c44447c380000\n700084fcf8a4243c1800 7100183c24a4f8fc8400 7200447c784c041c1800 7300485c545474240000 740000043e7f44240000\n75003c7c40403c7c4000 76001c3c60603c1c0000 77003c7c7038707c3c00 7800446c3810386c4400 79009cbca0a0fc7c0000\n7a004c64745c4c640000 7b0008083e7741410000 7c000000007777000000 7d004141773e08080000 7e000203010302030100\n7f000000000000000000\n`\n    }\n\n    export function doubledFont(f: Font): Font {\n        if (f.doubledCache) return f.doubledCache\n        let byteHeight = (f.charHeight + 7) >> 3\n        let sz = f.charWidth * byteHeight\n        let numChars = f.data.length / (sz + 2)\n        let newByteHeight = ((f.charHeight * 2) + 7) >> 3\n        let nsz = f.charWidth * 2 * newByteHeight\n        let data = control.createBuffer((nsz + 2) * numChars)\n        let tmp = control.createBuffer(4 + sz)\n        tmp[0] = 0xe1\n        tmp[1] = f.charWidth\n        tmp[2] = f.charHeight\n        let dst = 0\n        for (let i = 0; i < f.data.length; i += 2 + sz) {\n            tmp.write(4, f.data.slice(i + 2, sz))\n            let dbl = image.doubledIcon(tmp).slice(4)\n            data[dst] = f.data[i]\n            data[dst + 1] = f.data[i + 1]\n            data.write(dst + 2, dbl)\n            dst += 2 + dbl.length\n        }\n        f.doubledCache = {\n            charWidth: f.charWidth * 2,\n            charHeight: f.charHeight * 2,\n            data: data\n        }\n        return f.doubledCache\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.font8\n        let w = text.length * font.charWidth\n        let x = (screen.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font) {\n        x |= 0\n        y |= 0\n        if (!font) font = image.font8\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let byteHeight = (font.charHeight + 7) >> 3\n        let charSize = byteHeight * font.charWidth\n        let imgBuf = control.createBuffer(4 + charSize)\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        imgBuf[0] = 0xe1\n        imgBuf[1] = font.charWidth\n        imgBuf[2] = font.charHeight\n        while (cp < text.length) {\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            // decompose Korean characters\n            let arr = [ch]\n            if (44032 <= ch && ch <= 55203) {\n                ch -= 44032\n                arr = [\n                    Math.idiv(ch, 588) + 0x1100,\n                    (Math.idiv(ch, 28) % 21) + 0x1161,\n                ]\n                ch %= 28\n                if (ch)\n                    arr.push(ch % 28 + 0x11a7)\n            }\n\n            for (let cc of arr) {\n                let l = 0\n                let r = lastchar\n                let off = 0 // this should be a space (0x0020)\n                let guess = (ch - 32) * dataSize\n                if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == cc)\n                    off = guess\n                else {\n                    while (l <= r) {\n                        let m = l + ((r - l) >> 1);\n                        let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                        if (v == cc) {\n                            off = m * dataSize\n                            break\n                        }\n                        if (v < cc)\n                            l = m + 1\n                        else\n                            r = m - 1\n                    }\n                }\n\n                imgBuf.write(4, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x, y, color)\n                x += font.charWidth\n            }\n        }\n    }\n}\n"
    },
    "screen---linux": {
      "fieldeditors.ts": "/**\n * Image manipulation blocks\n */\n//% weight=70 icon=\"\\uf03e\" color=\"#0E563B\"\n//% advanced=true\nnamespace images {\n    //% blockId=screen_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% weight=100 group=\"Create\"\n    export function _spriteImage(img: Image) {\n        return img\n    }\n\n    //% blockId=background_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"-1,-1\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _screenImage(img: Image) {\n        return img\n    }\n\n    //% blockId=tilemap_image_picker block=\"%img\"\n    //% shim=TD_ID\n    //% img.fieldEditor=\"sprite\"\n    //% img.fieldOptions.taggedTemplate=\"img\"\n    //% img.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% img.fieldOptions.sizes=\"10,8;16,16;32,32;48,48;64,64;16,32;32,48;32,8;64,8\"\n    //% weight=100 group=\"Create\"\n    //% blockHidden=1\n    export function _tileMapImage(img: Image) {\n        return img\n    }\n\n    /**\n     * An image\n     * @param image the image\n     */\n    //% blockId=image_picker block=\"%image\" shim=TD_ID\n    //% image.fieldEditor=\"images\"\n    //% image.fieldOptions.columns=6\n    //% image.fieldOptions.width=600\n    //% weight=0 group=\"Create\"\n    export function _image(image: Image): Image {\n        return image;\n    }\n\n    //% blockId=colorindexpicker block=\"%index\" blockHidden=true shim=TD_ID\n    //% index.fieldEditor=\"colornumber\"\n    //% index.fieldOptions.valueMode=\"index\"\n    //% index.fieldOptions.decompileLiterals=\"true\"\n    export function __colorIndexPicker(index: number) {\n        return index;\n    }\n}",
      "frame.ts": "namespace control.__screen {\n    let __update: () => void\n    let __updated = false;\n\n    export function update() {\n        if (__update)\n            __update()\n        __updated = true\n    }\n\n    export function setupUpdate(update: () => void) {\n        __updated = true;\n        __update = update;\n        update()\n    }\n\n    // low frequency fallback screen refresh\n    control.runInParallel(() => {\n        while (true) {\n            __updated = false\n            pause(200)\n            if (!__updated) {\n                __screen.update();\n                __updated = true\n            }\n        }\n    })\n}\n",
      "image.cpp": "#include \"pxt.h\"\n\n#if IMAGE_BITS == 1\n// OK\n#elif IMAGE_BITS == 4\n// OK\n#else\n#error \"Invalid IMAGE_BITS\"\n#endif\n\n#define XX(v) (int)(((int16_t)(v)))\n#define YY(v) (int)(((int16_t)(((int32_t)(v)) >> 16)))\n\nnamespace pxt {\n\nPXT_VTABLE(RefImage)\n\nvoid RefImage::destroy(RefImage *t) {\n    decrRC(t->buffer());\n}\n\nvoid RefImage::print(RefImage *t) {\n    DMESG(\"RefImage %p r=%d size=%d x %d\", t, REFCNT(t), t->width(), t->height());\n}\n\nint RefImage::width() {\n    return data()[1];\n}\n\nint RefImage::wordHeight() {\n    if (bpp() == 1)\n        oops(20);\n    return ((data()[2] * bpp() + 31) >> 5);\n}\n\nint RefImage::byteHeight() {\n    if (bpp() == 1)\n        return (data()[2] + 7) >> 3;\n    else if (bpp() == 4)\n        return ((data()[2] * 4 + 31) >> 5) << 2;\n    else {\n        oops(21);\n        return -1;\n    }\n}\n\nint RefImage::bpp() {\n    return data()[0] & 0xf;\n}\n\nint RefImage::height() {\n    return data()[2];\n}\n\nvoid RefImage::makeWritable() {\n    if (hasBuffer()) {\n        if (buffer()->isReadOnly()) {\n            auto b = mkBuffer(data(), length());\n            decrRC(buffer());\n            _buffer = (uintptr_t)b;\n        }\n    } else {\n        _buffer |= 2;\n    }\n}\n\nuint8_t *RefImage::pix(int x, int y) {\n    uint8_t *d = &data()[4 + byteHeight() * x];\n    if (y) {\n        if (bpp() == 1)\n            d += y >> 3;\n        else if (bpp() == 4)\n            d += y >> 1;\n    }\n    return d;\n}\n\nuint8_t RefImage::fillMask(color c) {\n    return this->bpp() == 1 ? (c & 1) * 0xff : 0x11 * (c & 0xf);\n}\n\nbool RefImage::inRange(int x, int y) {\n    return 0 <= x && x < width() && 0 <= y && y < height();\n}\n\nvoid RefImage::clamp(int *x, int *y) {\n    *x = min(max(*x, 0), width() - 1);\n    *y = min(max(*y, 0), height() - 1);\n}\n\nRefImage::RefImage(BoxedBuffer *buf) : PXT_VTABLE_INIT(RefImage), _buffer((uintptr_t)buf) {\n    incrRC(buf);\n}\nRefImage::RefImage(uint32_t sz) : PXT_VTABLE_INIT(RefImage), _buffer((sz << 2) | 3) {}\n\nstatic inline int byteSize(int w, int h, int bpp) {\n    if (bpp == 1)\n        return 4 + ((h + 7) >> 3) * w;\n    else\n        return 4 + (((h * 4 + 31) / 32) * 4) * w;\n}\n\nImage_ mkImage(int width, int height, int bpp) {\n    if (width < 0 || height < 0 || width > 255 || height > 255)\n        return NULL;\n    if (bpp != 1 && bpp != 4)\n        return NULL;\n    uint32_t sz = byteSize(width, height, bpp);\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    auto d = r->data();\n    d[0] = 0xe0 | bpp;\n    d[1] = width;\n    d[2] = height;\n    d[3] = 0;\n    MEMDBG(\"mkImage: %d X %d => %p\", width, height, r);\n    return r;\n}\n\nbool isValidImage(Buffer buf) {\n    if (!buf || buf->length < 5)\n        return false;\n\n    if (buf->data[0] != 0xe1 && buf->data[0] != 0xe4)\n        return false;\n\n    int sz = byteSize(buf->data[1], buf->data[2], buf->data[0] & 0xf);\n    if (sz != (int)buf->length)\n        return false;\n\n    return true;\n}\n\n} // namespace pxt\n\nnamespace ImageMethods {\n\n/**\n * Get the width of the image\n */\n//% property\nint width(Image_ img) {\n    return img->width();\n}\n\n/**\n * Get the height of the image\n */\n//% property\nint height(Image_ img) {\n    return img->height();\n}\n\n/**\n * True iff the image is monochromatic (black and white)\n */\n//% property\nbool isMono(Image_ img) {\n    return img->bpp() == 1;\n}\n\n/**\n * Sets all pixels in the current image from the other image, which has to be of the same size and\n * bpp.\n */\n//%\nvoid copyFrom(Image_ img, Image_ from) {\n    if (img->width() != from->width() || img->height() != from->height() ||\n        img->bpp() != from->bpp())\n        return;\n    img->makeWritable();\n    memcpy(img->pix(), from->pix(), from->pixLength());\n}\n\nstatic inline void setCore(Image_ img, int x, int y, int c) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        if (c)\n            *ptr |= mask;\n        else\n            *ptr &= ~mask;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            *ptr = (*ptr & 0x0f) | (c << 4);\n        else\n            *ptr = (*ptr & 0xf0) | (c & 0xf);\n    }\n}\n\nstatic inline int getCore(Image_ img, int x, int y) {\n    auto ptr = img->pix(x, y);\n    if (img->bpp() == 1) {\n        uint8_t mask = 0x01 << (y & 7);\n        return (*ptr & mask) ? 1 : 0;\n    } else if (img->bpp() == 4) {\n        if (y & 1)\n            return *ptr >> 4;\n        else\n            return *ptr & 0x0f;\n    }\n    return 0;\n}\n\n/**\n * Set pixel color\n */\n//%\nvoid setPixel(Image_ img, int x, int y, int c) {\n    if (!img->inRange(x, y))\n        return;\n    img->makeWritable();\n    setCore(img, x, y, c);\n}\n\n/**\n * Get a pixel color\n */\n//%\nint getPixel(Image_ img, int x, int y) {\n    if (!img->inRange(x, y))\n        return 0;\n    return getCore(img, x, y);\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c);\n\n/**\n * Fill entire image with a given color\n */\n//%\nvoid fill(Image_ img, int c) {\n    if (c && img->hasPadding()) {\n        fillRect(img, 0, 0, img->width(), img->height(), c);\n        return;\n    }\n    img->makeWritable();\n    memset(img->pix(), img->fillMask(c), img->pixLength());\n}\n\nvoid fillRect(Image_ img, int x, int y, int w, int h, int c) {\n    if (w == 0 || h == 0 || x >= img->width() || y >= img->height())\n        return;\n\n    int x2 = x + w - 1;\n    int y2 = y + h - 1;\n\n    if (x2 < 0 || y2 < 0)\n        return;\n\n    img->clamp(&x2, &y2);\n    img->clamp(&x, &y);\n    w = x2 - x + 1;\n    h = y2 - y + 1;\n\n    if (!img->hasPadding() && x == 0 && y == 0 && w == img->width() && h == img->height()) {\n        fill(img, c);\n        return;\n    }\n\n    img->makeWritable();\n\n    auto bh = img->byteHeight();\n    uint8_t f = img->fillMask(c);\n\n    uint8_t *p = img->pix(x, y);\n    while (w-- > 0) {\n        if (img->bpp() == 1) {\n            auto ptr = p;\n            unsigned mask = 0x01 << (y & 7);\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0x100) {\n                    if (h - i >= 8) {\n                        *++ptr = f;\n                        i += 7;\n                        continue;\n                    } else {\n                        mask = 0x01;\n                        ++ptr;\n                    }\n                }\n                if (c)\n                    *ptr |= mask;\n                else\n                    *ptr &= ~mask;\n                mask <<= 1;\n            }\n\n        } else if (img->bpp() == 4) {\n            auto ptr = p;\n            unsigned mask = 0x0f;\n            if (y & 1)\n                mask <<= 4;\n\n            for (int i = 0; i < h; ++i) {\n                if (mask == 0xf00) {\n                    if (h - i >= 2) {\n                        *++ptr = f;\n                        i++;\n                        continue;\n                    } else {\n                        mask = 0x0f;\n                        ptr++;\n                    }\n                }\n                *ptr = (*ptr & ~mask) | (f & mask);\n                mask <<= 4;\n            }\n        }\n        p += bh;\n    }\n}\n\n//%\nvoid _fillRect(Image_ img, int xy, int wh, int c) {\n    fillRect(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n/**\n * Return a copy of the current image\n */\n//%\nImage_ clone(Image_ img) {\n    uint32_t sz = img->length();\n    Image_ r = new (gcAllocate(sizeof(RefImage) + sz)) RefImage(sz);\n    memcpy(r->data(), img->data(), img->length());\n    MEMDBG(\"mkImageClone: %d X %d => %p\", img->width(), img->height(), r);\n    return r;\n}\n\n/**\n * Flips (mirrors) pixels horizontally in the current image\n */\n//%\nvoid flipX(Image_ img) {\n    img->makeWritable();\n\n    int bh = img->byteHeight();\n    auto a = img->pix();\n    auto b = img->pix(img->width() - 1, 0);\n\n    uint8_t tmp[bh];\n\n    while (a < b) {\n        memcpy(tmp, a, bh);\n        memcpy(a, b, bh);\n        memcpy(b, tmp, bh);\n        a += bh;\n        b -= bh;\n    }\n}\n\n/**\n * Flips (mirrors) pixels vertically in the current image\n */\n//%\nvoid flipY(Image_ img) {\n    img->makeWritable();\n\n    // this is quite slow - for small 16x16 sprite it will take in the order of 1ms\n    // something faster requires quite a bit of bit tweaking, especially for mono images\n    for (int i = 0; i < img->width(); ++i) {\n        int a = 0;\n        int b = img->height() - 1;\n        while (a < b) {\n            int tmp = getCore(img, i, a);\n            setCore(img, i, a, getCore(img, i, b));\n            setCore(img, i, b, tmp);\n            a++;\n            b--;\n        }\n    }\n}\n\n/**\n * Returns a transposed image (with X/Y swapped)\n */\n//%\nImage_ transposed(Image_ img) {\n    img->makeWritable();\n    Image_ r = mkImage(img->height(), img->width(), img->bpp());\n\n    // this is quite slow\n    for (int i = 0; i < img->width(); ++i) {\n        for (int j = 0; j < img->height(); ++i) {\n            setCore(r, j, i, getCore(img, i, j));\n        }\n    }\n\n    return r;\n}\n\n/**\n * Every pixel in image is moved by (dx,dy)\n */\n//%\nvoid scroll(Image_ img, int dx, int dy) {\n    img->makeWritable();\n    auto bh = img->byteHeight();\n    auto w = img->width();\n    if (dx < 0) {\n        dx = -dx;\n        if (dx < w)\n            memmove(img->pix(), img->pix(dx, 0), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(w - dx, 0), 0, dx * bh);\n    } else if (dx > 0) {\n        if (dx < w)\n            memmove(img->pix(dx, 0), img->pix(), (w - dx) * bh);\n        else\n            dx = w;\n        memset(img->pix(), 0, dx * bh);\n    }\n    // TODO implement dy\n}\n\nconst uint8_t bitdouble[] = {0x00, 0x03, 0x0c, 0x0f, 0x30, 0x33, 0x3c, 0x3f,\n                             0xc0, 0xc3, 0xcc, 0xcf, 0xf0, 0xf3, 0xfc, 0xff};\nconst uint8_t nibdouble[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};\n\n/**\n * Stretches the image horizontally by 100%\n */\n//%\nImage_ doubledX(Image_ img) {\n    if (img->width() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width() * 2, img->height(), img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n    auto w = img->width();\n    auto bh = img->byteHeight();\n\n    for (int i = 0; i < w; ++i) {\n        memcpy(dst, src, bh);\n        dst += bh;\n        memcpy(dst, src, bh);\n        dst += bh;\n\n        src += bh;\n    }\n\n    return r;\n}\n\n/**\n * Stretches the image vertically by 100%\n */\n//%\nImage_ doubledY(Image_ img) {\n    if (img->height() > 126)\n        return NULL;\n\n    Image_ r = mkImage(img->width(), img->height() * 2, img->bpp());\n    auto src = img->pix();\n    auto dst = r->pix();\n\n    auto w = img->width();\n    auto bh = r->byteHeight();\n    auto dbl = img->bpp() == 1 ? bitdouble : nibdouble;\n\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < bh; j += 2) {\n            *dst++ = dbl[*src & 0xf];\n            if (j != bh - 1)\n                *dst++ = dbl[*src >> 4];\n            src++;\n        }\n    }\n\n    return r;\n}\n\n/**\n * Replaces one color in an image with another\n */\n//%\nvoid replace(Image_ img, int from, int to) {\n    if (img->bpp() != 4)\n        return;\n    to &= 0xf;\n    if (from == to)\n        return;\n\n    img->makeWritable();\n\n    // avoid bleeding 'to' color into the overflow areas of the picture\n    if (from == 0 && img->hasPadding()) {\n        for (int i = 0; i < img->height(); ++i)\n            for (int j = 0; j < img->width(); ++j)\n                if (getCore(img, j, i) == from)\n                    setCore(img, j, i, to);\n        return;\n    }\n\n    auto ptr = img->pix();\n    auto len = img->pixLength();\n    while (len--) {\n        auto b = *ptr;\n        if ((b & 0xf) == from)\n            b = (b & 0xf0) | to;\n        if ((b >> 4) == from)\n            b = (to << 4) | (b & 0xf);\n        *ptr++ = b;\n    }\n}\n\n/**\n * Stretches the image in both directions by 100%\n */\n//%\nImage_ doubled(Image_ img) {\n    Image_ tmp = doubledX(img);\n    Image_ r = doubledY(tmp);\n    decrRC(tmp);\n    return r;\n}\n\nbool drawImageCore(Image_ img, Image_ from, int x, int y, int color) {\n    auto w = from->width();\n    auto h = from->height();\n    auto sh = img->height();\n    auto sw = img->width();\n\n    if (x + w <= 0)\n        return false;\n    if (x >= sw)\n        return false;\n    if (y + h <= 0)\n        return false;\n    if (y >= sh)\n        return false;\n\n    auto len = y < 0 ? min(sh, h + y) : min(sh - y, h);\n    auto tbp = img->bpp();\n    auto fbp = from->bpp();\n    auto y0 = y;\n\n    if (color == -2 && x == 0 && y == 0 && tbp == fbp && w == sw && h == sh) {\n        copyFrom(img, from);\n        return false;\n    }\n\n    //DMESG(\"drawIMG(%d,%d) at (%d,%d) w=%d bh=%d len=%d\", \n    //    w,h,x, y, img->width(), img->byteHeight(), len );\n\n    auto fromH = from->byteHeight();\n    auto imgH = img->byteHeight();\n    auto fromBase = from->pix();\n    auto imgBase = img->pix(0, y);\n\n    #define LOOPHD for (int xx = 0; xx < w; ++xx, ++x) if (0 <= x && x < sw)\n\n\n    if (tbp == 4 && fbp == 4) {\n        auto wordH = fromH >> 2;\n        LOOPHD {\n                y = y0;\n\n                auto fdata = (uint32_t*)fromBase + wordH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                //DMESG(\"%d,%d xx=%d/%d - %p (%p) -- %d\",x,y,xx,w,tdata,img->pix(),\n                //    (uint8_t*)fdata - from->pix());\n\n                auto cnt = wordH;\n                auto bot = min(sh, y + h);\n\n                #define COLS(s) ((v >> (s)) & 0xf)\n                #define COL(s) COLS(s)\n                \n                #define STEPA(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETLOW(s); \\\n                    y++; \n                #define STEPB(s)  \\\n                    if (COL(s) && 0 <= y && y < bot) SETHIGH(s); \\\n                    y++; tdata++;\n                 #define STEPAQ(s)  \\\n                    if (COL(s)) SETLOW(s); \n                #define STEPBQ(s)  \\\n                    if (COL(s)) SETHIGH(s); \\\n                    tdata++;\n\n                // perf: expanded version 5% faster\n                #define ORDER(A,B) A(0); B(4); A(8); B(12); A(16); B(20); A(24); B(28)\n                //#define ORDER(A,B) for (int k = 0; k < 32; k += 8) { A(k); B(4+k); }\n                #define LOOP(A,B,xbot) while (cnt--) { \\\n                            auto v = *fdata++; \\\n                            if (0 <= y && y <= xbot - 8) { \\\n                                ORDER(A ## Q,  B ## Q); \\\n                                y += 8; \\\n                            } else { \\\n                                ORDER(A, B); \\\n                            } \\\n                        }\n                #define LOOPS(xbot) if (y & 1) \\\n                        LOOP(STEPB, STEPA, xbot) \\\n                    else \\\n                        LOOP(STEPA, STEPB, xbot)\n\n                if (color >= 0) {\n                #define SETHIGH(s) *tdata = (*tdata & 0x0f) | ((COLS(s)) << 4)\n                #define SETLOW(s) *tdata = (*tdata & 0xf0) | COLS(s)\n                    LOOPS(sh)\n                } else if (color == -2) {\n                    #undef COL\n                    #define COL(s) 1\n                    LOOPS(bot)\n                } else {\n                    #undef COL\n                    #define COL(s) COLS(s)\n                    #undef SETHIGH\n                    #define SETHIGH(s) if(*tdata & 0xf0) return true\n                    #undef SETLOW\n                    #define SETLOW(s) if(*tdata & 0x0f) return true\n                    LOOPS(sh)\n                }\n    } }\n    else if (tbp == 1 && fbp == 1) {\n        auto left = img->pix() - imgBase;\n        auto right = img->pix(0, img->height() - 1) - imgBase;\n        LOOPHD {\n                y = y0;\n\n\n                auto data = fromBase + fromH * xx;\n                auto off = imgBase + imgH * x;\n                auto off0 = off + left;\n                auto off1 = off + right;\n\n                int shift = (y & 7);\n\n                int y1 = y + h + (y & 7);\n                int prev = 0;\n\n                while (y < y1 - 8) {\n                    int curr = *data++ << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = (curr >> 0) | (prev >> 8);\n\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                    off++;\n                    prev = curr;\n                    y += 8;\n                }\n\n                int left = y1 - y; \n                if (left > 0) {\n                    int curr = *data << shift;\n                    if (off0 <= off && off <= off1) {\n                        uint8_t v = ((curr >> 0) | (prev >> 8)) & (0xff >> (8 - left));\n                        if (color == -1) {\n                            if (*off & v)\n                                return true;\n                        } else {\n                            *off |= v;\n                        }\n                    }\n                }\n        }\n        }\n        else if (tbp == 4 && fbp == 1)  {\n            if (y < 0) {\n                fromBase = from->pix(0, -y);\n                imgBase = img->pix();\n            }\n                // icon mode\n            LOOPHD {\n                auto fdata = fromBase + fromH * xx;\n                auto tdata = imgBase + imgH * x;\n\n                unsigned mask = 0x01;\n                auto v = *fdata++;\n                int off = (y & 1) ? 1 : 0;\n                if (y < 0) {\n                    mask <<= -y & 7;\n                    off = 0;\n                }\n                for (int i = off; i < len+off; ++i) {\n                    if (mask == 0x100) {\n                        mask = 0x01;\n                        v = *fdata++;\n                    }\n                    if (v & mask) {\n                        if (i & 1)\n                            *tdata = (*tdata & 0x0f) | (color << 4);\n                        else\n                            *tdata = (*tdata & 0xf0) | color;\n                    }\n                    mask <<= 1;\n                    if (i & 1)\n                        tdata++;\n                }\n            }\n        }\n\n    return false;\n}\n\n/**\n * Draw given image on the current image\n */\n//%\nvoid drawImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    if (img->bpp() == 4 && from->bpp() == 4) {\n        drawImageCore(img, from, x, y, -2);\n    } else {\n        fillRect(img, x, y, from->width(), from->height(), 0);\n        drawImageCore(img, from, x, y, 0);\n    }\n}\n\n/**\n * Draw given image with transparent background on the current image\n */\n//%\nvoid drawTransparentImage(Image_ img, Image_ from, int x, int y) {\n    img->makeWritable();\n    drawImageCore(img, from, x, y, 0);\n}\n\n/**\n * Check if the current image \"collides\" with another\n */\n//%\nbool overlapsWith(Image_ img, Image_ other, int x, int y) {\n    return drawImageCore(img, other, x, y, -1);\n}\n\n// Image_ format:\n//  byte 0: magic 0xe4 - 4 bit color; 0xe1 is monochromatic\n//  byte 1: width in pixels\n//  byte 2: height in pixels\n//  byte 3: padding (should be zero)\n//  byte 4...N: data 4 bits per pixels, high order nibble printed first, lines aligned to 32 bit\n//  words byte 4...N: data 1 bit per pixels, high order bit printed first, lines aligned to byte\n\n//%\nvoid _drawIcon(Image_ img, Buffer icon, int xy, int c) {\n    if (!isValidImage(icon) || icon->data[0] != 0xe1)\n        return;\n\n    img->makeWritable();\n    auto ii = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    drawImageCore(img, ii, XX(xy), YY(xy), c);\n    decrRC(ii);\n}\n\nstatic void drawLineLow(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int yi = 1;\n    if (dy < 0) {\n        yi = -1;\n        dy = -dy;\n    }\n    int D = 2 * dy - dx;\n    dx <<= 1;\n    dy <<= 1;\n    int y = y0;\n    for (int x = x0; x <= x1; ++x) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            y += yi;\n            D -= dx;\n        }\n        D += dy;\n    }\n}\n\nstatic void drawLineHigh(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    int xi = 1;\n    if (dx < 0) {\n        xi = -1;\n        dx = -dx;\n    }\n    int D = 2 * dx - dy;\n    dx <<= 1;\n    dy <<= 1;\n    int x = x0;\n    for (int y = y0; y <= y1; ++y) {\n        setCore(img, x, y, c);\n        if (D > 0) {\n            x += xi;\n            D -= dy;\n        }\n        D += dx;\n    }\n}\n\nvoid drawLine(Image_ img, int x0, int y0, int x1, int y1, int c) {\n    if (x1 < x0) {\n        drawLine(img, x1, y1, x0, y0, c);\n        return;\n    }\n\n    int w = x1 - x0;\n    int h = y1 - y0;\n\n    if (h == 0) {\n        if (w == 0)\n            setPixel(img, x0, y0, c);\n        else\n            fillRect(img, x0, y0, w + 1, 1, c);\n        return;\n    }\n\n    if (w == 0) {\n        if (h > 0)\n            fillRect(img, x0, y0, 1, h + 1, c);\n        else\n            fillRect(img, x0, y1, 1, -h + 1, c);\n        return;\n    }\n\n    if (x1 < 0 || x0 >= img->width())\n        return;\n    if (x0 < 0) {\n        y0 -= (h * x0 / w);\n        x0 = 0;\n    }\n    if (x1 >= img->width()) {\n        int d = (img->width() - 1) - x1;\n        y1 += (h * d / w);\n        x1 = img->width() - 1;\n    }\n\n    if (y0 < y1) {\n        if (y0 >= img->height() || y1 < 0)\n            return;\n        if (y0 < 0) {\n            x0 -= (w * y0 / h);\n            y0 = 0;\n        }\n        if (y1 >= img->height()) {\n            int d = (img->height() - 1) - y1;\n            x1 += (w * d / h);\n            y1 = img->height();\n        }\n    } else {\n        if (y1 >= img->height() || y0 < 0)\n            return;\n        if (y1 < 0) {\n            x1 -= (w * y1 / h);\n            y1 = 0;\n        }\n        if (y0 >= img->height()) {\n            int d = (img->height() - 1) - y0;\n            x0 += (w * d / h);\n            y0 = img->height();\n        }\n    }\n\n    img->makeWritable();\n\n    if (h < 0) {\n        h = -h;\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x1, y1, x0, y0, c);\n    } else {\n        if (h < w)\n            drawLineLow(img, x0, y0, x1, y1, c);\n        else\n            drawLineHigh(img, x0, y0, x1, y1, c);\n    }\n}\n\n//%\nvoid _drawLine(Image_ img, int xy, int wh, int c) {\n    drawLine(img, XX(xy), YY(xy), XX(wh), YY(wh), c);\n}\n\n} // namespace ImageMethods\n\nnamespace image {\n/**\n * Create new empty (transparent) image\n */\n//%\nImage_ create(int width, int height) {\n    Image_ r = mkImage(width, height, IMAGE_BITS);\n    if (r)\n        memset(r->pix(), 0, r->pixLength());\n    else\n        target_panic(PANIC_INVALID_IMAGE);\n    return r;\n}\n\n/**\n * Create new image with given content\n */\n//%\nImage_ ofBuffer(Buffer buf) {\n    if (!isValidImage(buf))\n        return NULL;\n    return new (gcAllocate(sizeof(RefImage))) RefImage(buf);\n}\n\n/**\n * Double the size of an icon\n */\n//%\nBuffer doubledIcon(Buffer icon) {\n    if (!isValidImage(icon))\n        return NULL;\n\n    auto r = new (gcAllocate(sizeof(RefImage))) RefImage(icon);\n    auto t = ImageMethods::doubled(r);\n    auto res = mkBuffer(t->data(), t->length());\n    decrRC(r);\n    decrRC(t);\n\n    return res;\n}\n\n} // namespace image\n\n// This is  6.5x faster than standard on word-aligned copy\n// probably should move to codal\n\n#ifndef __linux__\nextern \"C\" void *memcpy(void *dst, const void *src, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3) && !((uintptr_t)src & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t *d = (uint32_t *)dst;\n        const uint32_t *s = (const uint32_t *)src;\n        while (cnt--) {\n            *d++ = *s++;\n        }\n        sz &= 3;\n        dst = d;\n        src = s;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n    uint8_t *ss = (uint8_t *)src;\n\n    while (sz--) {\n        *dd++ = *ss++;\n    }\n\n    return dst;\n}\n\nextern \"C\" void *memset(void *dst, int v, size_t sz) {\n    if (sz >= 4 && !((uintptr_t)dst & 3)) {\n        size_t cnt = sz >> 2;\n        uint32_t vv = 0x01010101 * v;\n        uint32_t *d = (uint32_t *)dst;\n        while (cnt--) {\n            *d++ = vv;\n        }\n        sz &= 3;\n        dst = d;\n    }\n\n    uint8_t *dd = (uint8_t *)dst;\n\n    while (sz--) {\n        *dd++ = v;\n    }\n\n    return dst;\n}\n#endif",
      "image.d.ts": "//% fixedInstances decompileIndirectFixedInstances\ninterface Image {\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"fill rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/fill-rect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw line in %picture=variables_get from x %x0 y %y0 to x %x1 y %y1 %c=colorindexpicker\"\n    //% help=images/image/draw-line\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect blockNamespace=\"images\" inlineInputMode=\"inline\" group=\"Drawing\"\n    //% block=\"draw rectangle in %picture=variables_get at x %x y %y width %w height %h %c=colorindexpicker\"\n    //% help=images/image/draw-rect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"set %picture=variables_get color at x %x y %y to %c=colorindexpicker\"\n    //% help=images/image/set-pixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"%picture=variables_get color at x %x y %y\"\n    //% help=images/image/get-pixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill blockNamespace=\"images\" group=\"Drawing\"\n    //% block=\"fill %picture=variables_get with %c=colorindexpicker\"\n    //% help=images/image/fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone blockNamespace=\"images\" group=\"Create\"\n    //% block=\"clone %picture=variables_get\"\n    //% help=images/image/clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get horizontally\"\n    //% help=images/image/flip-x\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"flip %picture=variables_get vertically\"\n    //% help=images/image/flip-y\n    flipY(): void;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll blockNamespace=\"images\" group=\"Transformations\"\n    //% help=images/image/scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace blockNamespace=\"images\" group=\"Transformations\"\n    //% block=\"change color in %picture=variables_get from %from=colorindexpicker to %to=colorindexpicker\"\n    //% help=images/image/replace\n    replace(from: int32, to: int32): void;\n}\n\ndeclare namespace image {\n    //% blockNamespace=\"images\"\n    //% block=\"create image width %width height %height\" group=\"Create\"\n    //% help=images/create\n    function create(width: number, height: number): Image;\n}",
      "image.ts": "type color = number\n\nnamespace image {\n    export function repeatY(count: number, image: Image) {\n        let arr = [image]\n        while (--count > 0)\n            arr.push(image)\n        return concatY(arr)\n    }\n\n    export function concatY(images: Image[]) {\n        let w = 0\n        let h = 0\n        for (let img of images) {\n            w = Math.max(img.width, w)\n            h += img.height\n        }\n        let r = image.create(w, h)\n        let y = 0\n        for (let img of images) {\n            let x = (w - img.width) >> 1\n            r.drawImage(img, x, y)\n            y += img.height\n        }\n        return r\n    }\n}\n\n\n//% fixedInstances\ninterface Image {\n    /**\n     * Draw an icon (monochromatic image) using given color\n     */\n    //% helper=imageDrawIcon\n    drawIcon(icon: Buffer, x: number, y: number, c: color): void;\n\n    /**\n     * Fill a rectangle\n     */\n    //% helper=imageFillRect\n    fillRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Draw a line\n     */\n    //% helper=imageDrawLine\n    drawLine(x0: number, y0: number, x1: number, y1: number, c: color): void;\n\n    /**\n     * Draw an empty rectangle\n     */\n    //% helper=imageDrawRect\n    drawRect(x: number, y: number, w: number, h: number, c: color): void;\n\n    /**\n     * Returns an image rotated by -90, 0, 90, 180, 270 deg clockwise\n     */\n    //% helper=imageRotated\n    rotated(deg: number): Image;\n}\n\nnamespace helpers {\n    //% shim=ImageMethods::_drawLine\n    function _drawLine(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_fillRect\n    function _fillRect(img: Image, xy: number, wh: number, c: color): void { }\n\n    //% shim=ImageMethods::_drawIcon\n    function _drawIcon(img: Image, icon: Buffer, xy: number, c: color): void { }\n\n    function pack(x: number, y: number) {\n        return (Math.clamp(-30000, 30000, x | 0) & 0xffff) | (Math.clamp(-30000, 30000, y | 0) << 16)\n    }\n\n    export function imageDrawIcon(img: Image, icon: Buffer, x: number, y: number, c: color): void {\n        _drawIcon(img, icon, pack(x, y), c)\n    }\n    export function imageFillRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _fillRect(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawLine(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        _drawLine(img, pack(x, y), pack(w, h), c)\n    }\n    export function imageDrawRect(img: Image, x: number, y: number, w: number, h: number, c: color): void {\n        if (w == 0 || h == 0) return\n        w--\n        h--\n        imageDrawLine(img, x, y, x + w, y, c)\n        imageDrawLine(img, x, y, x, y + h, c)\n        imageDrawLine(img, x + w, y + h, x + w, y, c)\n        imageDrawLine(img, x + w, y + h, x, y + h, c)\n    }\n\n    /**\n     * Returns an image rotated by 90, 180, 270 deg clockwise\n     */\n    export function imageRotated(img: Image, deg: number) {\n        if (deg == -90 || deg == 270) {\n            let r = img.transposed();\n            r.flipY();\n            return r;\n        } else if (deg == 180 || deg == -180) {\n            let r = img.clone();\n            r.flipX();\n            r.flipY();\n            return r;\n        } else if (deg == 90) {\n            let r = img.transposed();\n            r.flipX();\n            return r;\n        } else {\n            return null;\n        }\n    }\n\n}\n",
      "ns.ts": " ",
      "pxt.json": "{\n    \"name\": \"screen---linux\",\n    \"description\": \"The screen library\",\n    \"files\": [\n        \"screen.cpp\",\n        \"image.cpp\",\n        \"image.ts\",\n        \"text.ts\",\n        \"frame.ts\",\n        \"shims.d.ts\",\n        \"fieldeditors.ts\",\n        \"targetoverrides.ts\",\n        \"ns.ts\",\n        \"image.d.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "screen.cpp": "#include \"pxt.h\"\n#include \"pins.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <linux/fb.h>\n#include <linux/kd.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <pthread.h>\n\nnamespace pxt {\nclass WDisplay {\n  public:\n    uint32_t currPalette[16];\n    bool newPalette;\n    volatile bool painted;\n    volatile bool dirty;\n\n    uint8_t *screenBuf;\n    Image_ lastImg;\n\n    int width, height;\n\n    int fb_fd;\n    uint32_t *fbuf;\n    struct fb_fix_screeninfo finfo;\n    struct fb_var_screeninfo vinfo;\n\n    int eventId;\n\n    pthread_mutex_t mutex;\n\n    WDisplay();\n    void updateLoop();\n    void update(Image_ img);\n};\n\nSINGLETON(WDisplay);\n\nstatic void *updateDisplay(void *wd) {\n    ((WDisplay *)wd)->updateLoop();\n    return NULL;\n}\n\nvoid WDisplay::updateLoop() {\n    int cur_page = 1;\n    int frameNo = 0;\n\n    int sx = vinfo.xres / width;\n    int sy = vinfo.yres / height;\n    if (sx > sy)\n        sx = sy;\n    else\n        sy = sx;\n\n    sx &= ~1;\n\n    int offx = (vinfo.xres - width * sx) / 2;\n    int offy = (vinfo.yres - height * sy) / 2;\n    int screensize = finfo.line_length * vinfo.yres;\n    uint32_t skip = offx;\n\n    offx &= ~1;\n\n    memset(fbuf, 0x33, screensize * 2);\n\n    dirty = true;\n\n    for (;;) {\n        auto start0 = current_time_us();\n\n        while (!dirty)\n            sleep_core_us(2000);\n        \n        //auto start = current_time_us();\n\n        pthread_mutex_lock(&mutex);\n        dirty = false;\n        uint16_t *dst =\n            (uint16_t *)fbuf + cur_page * screensize / 2 + offx + offy * finfo.line_length / 2;\n        uint32_t *d2 = (uint32_t*)dst;\n        for (int yy = 0; yy < height; yy++) {\n            auto shift = yy & 1 ? 4 : 0;\n            for (int i = 0; i < sy; ++i) {\n                auto src = screenBuf + yy / 2;\n                for (int xx = 0; xx < width; ++xx) {\n                    int c = this->currPalette[(*src >> shift) & 0xf];\n                    src += height / 2;\n                    for (int j = 0; j < sx / 2; ++j)\n                        *d2++ = c;\n                }\n                d2 += skip;\n            }\n        }\n        pthread_mutex_unlock(&mutex);\n\n        //auto len = current_time_us() - start;\n\n        painted = true;\n        raiseEvent(DEVICE_ID_NOTIFY_ONE, eventId);\n\n        vinfo.yoffset = cur_page * vinfo.yres;\n        ioctl(fb_fd, FBIOPAN_DISPLAY, &vinfo);\n        ioctl(fb_fd, FBIO_WAITFORVSYNC, 0);\n        cur_page = !cur_page;\n        frameNo++;\n\n        auto fulllen = current_time_us() - start0;\n        // throttle it to 40fps (really 30fps)\n        if (fulllen < 25000) {\n            ioctl(fb_fd, FBIO_WAITFORVSYNC, 0);\n        }\n\n        //auto tot = current_time_us() - start;\n        //if (frameNo % 37 == 0)\n        //    DMESG(\"copy %d us, tot %d us delay %d us\",  (int)len, (int)tot, (int)(start-start0));\n    }\n}\n\nWDisplay::WDisplay() {\n    pthread_mutex_init(&mutex, NULL);\n\n    width = getConfig(CFG_DISPLAY_WIDTH, 160);\n    height = getConfig(CFG_DISPLAY_HEIGHT, 128);\n    screenBuf = new uint8_t[width * height / 2 + 20];\n    lastImg = NULL;\n    newPalette = false;\n\n    registerGC((TValue*)&lastImg);\n\n    eventId = allocateNotifyEvent();\n\n    int tty_fd = open(\"/dev/tty0\", O_RDWR);\n    ioctl(tty_fd, KDSETMODE, KD_GRAPHICS);\n\n    fb_fd = open(\"/dev/fb0\", O_RDWR);\n\n    if (fb_fd < 0)\n        target_panic(PANIC_SCREEN_ERROR);\n\n    ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo);\n    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);\n\n    DMESG(\"FB: %s at %dx%d %dx%d bpp=%d\", finfo.id, vinfo.xres, vinfo.yres, vinfo.xres_virtual,\n          vinfo.yres_virtual, vinfo.bits_per_pixel);\n\n    vinfo.yres_virtual = vinfo.yres * 2;\n    vinfo.xres_virtual = vinfo.xres;\n    vinfo.bits_per_pixel = 16;\n\n    ioctl(fb_fd, FBIOPUT_VSCREENINFO, &vinfo);\n    ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo);\n    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);\n\n    DMESG(\"FB: %s at %dx%d %dx%d bpp=%d %d\", finfo.id, vinfo.xres, vinfo.yres, vinfo.xres_virtual,\n          vinfo.yres_virtual, vinfo.bits_per_pixel, finfo.line_length);\n\n    fbuf = (uint32_t *)mmap(0, finfo.line_length * vinfo.yres_virtual, PROT_READ | PROT_WRITE,\n                            MAP_SHARED, fb_fd, (off_t)0);\n\n    pthread_t upd;\n    pthread_create(&upd, NULL, updateDisplay, this);\n    pthread_detach(upd);\n}\n\n//%\nvoid setPalette(Buffer buf) {\n    auto display = getWDisplay();\n    if (48 != buf->length)\n        target_panic(PANIC_SCREEN_ERROR);\n    for (int i = 0; i < 16; ++i) {\n        uint8_t r = buf->data[i * 3];\n        uint8_t g = buf->data[i * 3 + 1];\n        uint8_t b = buf->data[i * 3 + 2];\n        // display->currPalette[i] = (r << 16) | (g << 8) | (b << 0);\n        r >>= 3;\n        g >>= 2;\n        b >>= 3;\n        uint16_t cc = (r << 11) | (g << 5) | (b << 0);\n         display->currPalette[i] = (cc << 16) | cc;\n    }\n    display->newPalette = true;\n}\n\nvoid WDisplay::update(Image_ img) {\n    if (img && img != lastImg) {\n        decrRC(lastImg);\n        incrRC(img);\n        lastImg = img;\n    }\n    img = lastImg;\n\n    if (img && img->isDirty()) {\n        if (img->bpp() != 4 || img->width() != width || img->height() != height)\n            target_panic(PANIC_SCREEN_ERROR);\n\n        img->clearDirty();\n\n        if (!painted) {\n            // race is possible (though very unlikely), but in such case we just\n            // wait for next frame paint\n            waitForEvent(DEVICE_ID_NOTIFY, eventId);\n        }\n        painted = false;\n\n        pthread_mutex_lock(&mutex);\n        dirty = true;\n        if (newPalette) {\n            newPalette = false;\n        }\n        memcpy(screenBuf, img->pix(), img->pixLength());\n        pthread_mutex_unlock(&mutex);\n    }\n}\n\n//%\nvoid updateScreen(Image_ img) {\n    getWDisplay()->update(img);\n}\n\n//%\nvoid updateStats(String msg) {\n    // DMESG(\"render: %s\", msg->data);\n}\n} // namespace pxt",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface Image {\n    /**\n     * Get the width of the image\n     */\n    //% property shim=ImageMethods::width\n    width: int32;\n\n    /**\n     * Get the height of the image\n     */\n    //% property shim=ImageMethods::height\n    height: int32;\n\n    /**\n     * True iff the image is monochromatic (black and white)\n     */\n    //% property shim=ImageMethods::isMono\n    isMono: boolean;\n\n    /**\n     * Sets all pixels in the current image from the other image, which has to be of the same size and\n     * bpp.\n     */\n    //% shim=ImageMethods::copyFrom\n    copyFrom(from: Image): void;\n\n    /**\n     * Set pixel color\n     */\n    //% shim=ImageMethods::setPixel\n    setPixel(x: int32, y: int32, c: int32): void;\n\n    /**\n     * Get a pixel color\n     */\n    //% shim=ImageMethods::getPixel\n    getPixel(x: int32, y: int32): int32;\n\n    /**\n     * Fill entire image with a given color\n     */\n    //% shim=ImageMethods::fill\n    fill(c: int32): void;\n\n    /**\n     * Return a copy of the current image\n     */\n    //% shim=ImageMethods::clone\n    clone(): Image;\n\n    /**\n     * Flips (mirrors) pixels horizontally in the current image\n     */\n    //% shim=ImageMethods::flipX\n    flipX(): void;\n\n    /**\n     * Flips (mirrors) pixels vertically in the current image\n     */\n    //% shim=ImageMethods::flipY\n    flipY(): void;\n\n    /**\n     * Returns a transposed image (with X/Y swapped)\n     */\n    //% shim=ImageMethods::transposed\n    transposed(): Image;\n\n    /**\n     * Every pixel in image is moved by (dx,dy)\n     */\n    //% shim=ImageMethods::scroll\n    scroll(dx: int32, dy: int32): void;\n\n    /**\n     * Stretches the image horizontally by 100%\n     */\n    //% shim=ImageMethods::doubledX\n    doubledX(): Image;\n\n    /**\n     * Stretches the image vertically by 100%\n     */\n    //% shim=ImageMethods::doubledY\n    doubledY(): Image;\n\n    /**\n     * Replaces one color in an image with another\n     */\n    //% shim=ImageMethods::replace\n    replace(from: int32, to: int32): void;\n\n    /**\n     * Stretches the image in both directions by 100%\n     */\n    //% shim=ImageMethods::doubled\n    doubled(): Image;\n\n    /**\n     * Draw given image on the current image\n     */\n    //% shim=ImageMethods::drawImage\n    drawImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Draw given image with transparent background on the current image\n     */\n    //% shim=ImageMethods::drawTransparentImage\n    drawTransparentImage(from: Image, x: int32, y: int32): void;\n\n    /**\n     * Check if the current image \"collides\" with another\n     */\n    //% shim=ImageMethods::overlapsWith\n    overlapsWith(other: Image, x: int32, y: int32): boolean;\n}\ndeclare namespace image {\n\n    /**\n     * Create new empty (transparent) image\n     */\n    //% shim=image::create\n    function create(width: int32, height: int32): Image;\n\n    /**\n     * Create new image with given content\n     */\n    //% shim=image::ofBuffer\n    function ofBuffer(buf: Buffer): Image;\n\n    /**\n     * Double the size of an icon\n     */\n    //% shim=image::doubledIcon\n    function doubledIcon(icon: Buffer): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "targetoverrides.ts": "/**\n * Tagged image literal converter\n */\n//% shim=@f4 helper=image::ofBuffer blockIdentity=\"images._spriteImage\"\n//% groups=[\"0.\",\"1#\",\"2T\",\"3t\",\"4N\",\"5n\",\"6G\",\"7g\",\"8\",\"9\",\"aAR\",\"bBP\",\"cCp\",\"dDO\",\"eEY\",\"fFW\"]\nfunction img(lits: any, ...args: any[]): Image { return null }\n\n// set palette before creating screen, so the JS version has the right BPP\nimage.setPalette(hex`__palette`)\nlet screen = image.create(160, 120)\n\nnamespace image {\n    //% shim=pxt::setPalette\n    export function setPalette(buf: Buffer) { }\n}\n\nnamespace _screen_internal {\n    //% shim=pxt::updateScreen\n    function updateScreen(img: Image): void { }\n    //% shim=pxt::updateStats\n    function updateStats(msg: string): void { }\n\n    control.__screen.setupUpdate(() => updateScreen(screen))\n    control.EventContext.onStats = function (msg: string) {\n        updateStats(msg);\n    }\n}\n",
      "text.ts": "namespace image {\n\n    export interface Font {\n        charWidth: number;\n        charHeight: number;\n        data: Buffer;\n        doubledCache?: Font;\n    }\n\n    //% whenUsed\n    export const font8: Font = {\n        charWidth: 8,\n        charHeight: 8,\n        // source https://github.com/dhepper/font8x8\n        data: hex`\n20000000000000000000 21000000065f5f060000 22000003030003030000 2300147f7f147f7f1400 2400242e6b6b3a120000\n2500466630180c666200 2600307a4f5d377a4800 27000407030000000000 2800001c3e6341000000 29000041633e1c000000\n2a00082a3e1c1c3e2a08 2b0008083e3e08080000 2c000080e06000000000 2d000808080808080000 2e000000606000000000\n2f006030180c06030100 30003e7f71594d7f3e00 310040427f7f40400000 3200627359496f660000 3300226349497f360000\n3400181c16537f7f5000 3500276745457d390000 36003c7e4b4979300000 3700030371790f070000 3800367f49497f360000\n3900064f49693f1e0000 3a000000666600000000 3b000080e66600000000 3c00081c366341000000 3d002424242424240000\n3e00004163361c080000 3f00020351590f060000 40003e7f415d5d1f1e00 41007c7e13137e7c0000 4200417f7f49497f3600\n43001c3e634141632200 4400417f7f41633e1c00 4500417f7f495d416300 4600417f7f491d010300 47001c3e634151737200\n48007f7f08087f7f0000 490000417f7f41000000 4a00307040417f3f0100 4b00417f7f081c776300 4c00417f7f4140607000\n4d007f7f0e1c0e7f7f00 4e007f7f060c187f7f00 4f001c3e6341633e1c00 5000417f7f49090f0600 51001e3f21717f5e0000\n5200417f7f09197f6600 5300266f4d5973320000 540003417f7f41030000 55007f7f40407f7f0000 56001f3f60603f1f0000\n57007f7f3018307f7f00 580043673c183c674300 5900074f78784f070000 5a00476371594d677300 5b00007f7f4141000000\n5c000103060c18306000 5d000041417f7f000000 5e00080c0603060c0800 5f008080808080808080 60000000030704000000\n6100207454543c784000 6200417f3f4848783000 6300387c44446c280000 6400307848493f7f4000 6500387c54545c180000\n6600487e7f4903020000 670098bca4a4f87c0400 6800417f7f08047c7800 690000447d7d40000000 6a0060e08080fd7d0000\n6b00417f7f10386c4400 6c0000417f7f40000000 6d007c7c18381c7c7800 6e007c7c04047c780000 6f00387c44447c380000\n700084fcf8a4243c1800 7100183c24a4f8fc8400 7200447c784c041c1800 7300485c545474240000 740000043e7f44240000\n75003c7c40403c7c4000 76001c3c60603c1c0000 77003c7c7038707c3c00 7800446c3810386c4400 79009cbca0a0fc7c0000\n7a004c64745c4c640000 7b0008083e7741410000 7c000000007777000000 7d004141773e08080000 7e000203010302030100\n7f000000000000000000\n`\n    }\n\n    export function doubledFont(f: Font): Font {\n        if (f.doubledCache) return f.doubledCache\n        let byteHeight = (f.charHeight + 7) >> 3\n        let sz = f.charWidth * byteHeight\n        let numChars = f.data.length / (sz + 2)\n        let newByteHeight = ((f.charHeight * 2) + 7) >> 3\n        let nsz = f.charWidth * 2 * newByteHeight\n        let data = control.createBuffer((nsz + 2) * numChars)\n        let tmp = control.createBuffer(4 + sz)\n        tmp[0] = 0xe1\n        tmp[1] = f.charWidth\n        tmp[2] = f.charHeight\n        let dst = 0\n        for (let i = 0; i < f.data.length; i += 2 + sz) {\n            tmp.write(4, f.data.slice(i + 2, sz))\n            let dbl = image.doubledIcon(tmp).slice(4)\n            data[dst] = f.data[i]\n            data[dst + 1] = f.data[i + 1]\n            data.write(dst + 2, dbl)\n            dst += 2 + dbl.length\n        }\n        f.doubledCache = {\n            charWidth: f.charWidth * 2,\n            charHeight: f.charHeight * 2,\n            data: data\n        }\n        return f.doubledCache\n    }\n\n    //% whenUsed\n    export const font5: Font = {\n        charWidth: 6,\n        charHeight: 5,\n        // source https://github.com/lancaster-university/microbit-dal/blob/master/source/core/MicroBitFont.cpp\n        data: hex`\n2000000000000000 2100001700000000 2200000300030000 23000a1f0a1f0a00 24000a17151d0a00 2500130904121900\n26000a15150a1000 2700000300000000 2800000e11000000 290000110e000000 2a00000a040a0000 2b0000040e040000\n2c00001008000000 2d00000404040000 2e00000800000000 2f00100804020100 30000e11110e0000 310000121f100000\n3200191515120000 33000911150b0000 34000c0a091f0800 3500171515150900 3600081416150800 3700110905030100\n38000a1515150a00 390002150d050200 3a00000a00000000 3b0000100a000000 3c0000040a110000 3d00000a0a0a0000\n3e0000110a040000 3f00020115050200 40000e1115090e00 41001e05051e0000 42001f15150a0000 43000e1111110000\n44001f11110e0000 45001f1515110000 46001f0505010000 47000e1111150c00 48001f04041f0000 4900111f11000000\n4a000911110f0100 4b001f040a110000 4c001f1010100000 4d001f0204021f00 4e001f0204081f00 4f000e11110e0000\n50001f0505020000 5100060919160000 52001f05050a1000 5300121515090000 540001011f010100 55000f10100f0000\n5600070810080700 57001f0804081f00 58001b04041b0000 590001021c020100 5a00191513110000 5b00001f11110000\n5c00010204081000 5d000011111f0000 5e00000201020000 5f00101010101000 6000000102000000 61000c12121e1000\n62001f1414080000 63000c1212120000 64000814141f0000 65000e1515120000 6600041e05010000 67000215150f0000\n68001f0404180000 6900001d00000000 6a000010100d0000 6b001f040a100000 6c00000f10100000 6d001e0204021e00\n6e001e02021c0000 6f000c12120c0000 70001e0a0a040000 7100040a0a1e0000 72001c0202020000 730010140a020000\n7400000f14141000 75000e10101e1000 7600060810080600 77001e1008101e00 7800120c0c120000 7900121408040200\n7a00121a16120000 7b0000041f110000 7c00001f00000000 7d00111f04000000 7e00000404080800 d3000c1213130c00\nf3000c12130d0000 04010e05051e1000 05010609191f0800 06010c1213131200 07010c1213130000 18010f0b1b190000\n19010e151d1a0000 41011f1412100000 4201100f14120000 43011f0205081f00 44011e03031c0000 5a0110140b030200\n5b0110140b030000 7901121a17130000 7a01121a17130000 7b01121b17120000 7c01121b17120000`,\n    }\n}\n\ninterface Image {\n    //% helper=imagePrint\n    print(text: string, x: number, y: number, color?: number, font?: image.Font): void;\n\n    //% helper=imagePrintCenter\n    printCenter(text: string, y: number, color?: number, font?: image.Font): void;\n}\n\nnamespace helpers {\n    export function imagePrintCenter(img: Image, text: string, y: number, color?: number, font?: image.Font) {\n        if (!font) font = image.font8\n        let w = text.length * font.charWidth\n        let x = (screen.width - w) / 2\n        imagePrint(img, text, x, y, color, font)\n    }\n\n    export function imagePrint(img: Image, text: string, x: number, y: number, color?: number, font?: image.Font) {\n        x |= 0\n        y |= 0\n        if (!font) font = image.font8\n        if (!color) color = 1\n        let x0 = x\n        let cp = 0\n        let byteHeight = (font.charHeight + 7) >> 3\n        let charSize = byteHeight * font.charWidth\n        let imgBuf = control.createBuffer(4 + charSize)\n        let dataSize = 2 + charSize\n        let fontdata = font.data\n        let lastchar = Math.idiv(fontdata.length, dataSize) - 1\n        imgBuf[0] = 0xe1\n        imgBuf[1] = font.charWidth\n        imgBuf[2] = font.charHeight\n        while (cp < text.length) {\n            let ch = text.charCodeAt(cp++)\n            if (ch == 10) {\n                y += font.charHeight + 2\n                x = x0\n            }\n\n            if (ch < 32)\n                continue // skip control chars\n\n            // decompose Korean characters\n            let arr = [ch]\n            if (44032 <= ch && ch <= 55203) {\n                ch -= 44032\n                arr = [\n                    Math.idiv(ch, 588) + 0x1100,\n                    (Math.idiv(ch, 28) % 21) + 0x1161,\n                ]\n                ch %= 28\n                if (ch)\n                    arr.push(ch % 28 + 0x11a7)\n            }\n\n            for (let cc of arr) {\n                let l = 0\n                let r = lastchar\n                let off = 0 // this should be a space (0x0020)\n                let guess = (ch - 32) * dataSize\n                if (fontdata.getNumber(NumberFormat.UInt16LE, guess) == cc)\n                    off = guess\n                else {\n                    while (l <= r) {\n                        let m = l + ((r - l) >> 1);\n                        let v = fontdata.getNumber(NumberFormat.UInt16LE, m * dataSize)\n                        if (v == cc) {\n                            off = m * dataSize\n                            break\n                        }\n                        if (v < cc)\n                            l = m + 1\n                        else\n                            r = m - 1\n                    }\n                }\n\n                imgBuf.write(4, fontdata.slice(off + 2, charSize))\n                img.drawIcon(imgBuf, x, y, color)\n                x += font.charWidth\n            }\n        }\n    }\n}\n"
    },
    "game": {
      "ask.ts": "namespace game {\n    /**\n     * Prompts the user for a boolean question\n     * @param title\n     * @param subtitle\n     */\n    //% group=\"Gameplay\"\n    //% weight=89 help=game/ask\n    //% blockId=gameask block=\"ask %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function ask(title: string, subtitle?: string): boolean {\n        game.eventContext(); // initialize the game\n        control.pushEventContext();\n        game.showDialog(title, subtitle, \"A = OK, B = CANCEL\");\n        let answer: boolean = null;\n        controller.A.onEvent(ControllerButtonEvent.Pressed, () => answer = true);\n        controller.B.onEvent(ControllerButtonEvent.Pressed, () => answer = false);\n        pauseUntil(() => answer !== null);\n        control.popEventContext();\n        return answer;\n    }\n}",
      "background.ts": "enum BackgroundAlignment {\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"right\"\n    Right,\n    //% block=\"top\"\n    Top,\n    //% block=\"bottom\"\n    Bottom,\n    //% block=\"center\"\n    Center\n}\n\nnamespace scene {\n    export class Background {\n        color: number;\n        _image: Image;\n        camera: Camera;\n        private _layers: BackgroundLayer[];\n\n        constructor(camera: Camera) {\n            this.color = 0;\n            this.camera = camera;\n            this._layers = [];\n        }\n\n        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignment) {\n            const layer = new BackgroundLayer(distance, alignment, pic);\n            this._layers.push(layer);\n            this._layers.sort((a, b) => b.distance - a.distance);\n            return layer;\n        }\n\n        get image() {\n            if (!this._image)\n                this._image = image.create(screen.width, screen.height);\n            return this._image;\n        }\n        \n        set image(image: Image) {\n            this._image = image;\n        }\n\n        render() {\n            screen.fill(this.color);\n            if (this._image)\n                screen.drawImage(this._image, 0, 0)\n            if (this._layers) {\n                this._layers.forEach(layer => {\n                    // compute displacement based on distance\n                    const ox = Math.round(this.camera.offsetX / (1 + layer.distance));\n                    const oy = Math.round(this.camera.offsetY / (1 + layer.distance));\n                    layer.render(ox, oy);\n                });\n            }\n        }\n    }\n\n\n    export class BackgroundLayer {\n        distance: number;\n        img: Image;\n        repeatX: boolean;\n        repeatY: boolean;\n        alignX: BackgroundAlignment;\n        alignY: BackgroundAlignment;\n\n        constructor(distance: number, alignment: BackgroundAlignment, img: Image) {\n            this.distance = Math.max(1, distance);\n            this.img = img;\n            switch (alignment) {\n                case BackgroundAlignment.Center:\n                    this.repeatX = true;\n                    this.repeatY = true;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Left:\n                case BackgroundAlignment.Right:\n                    this.repeatX = false;\n                    this.repeatY = true;\n                    this.alignX = alignment;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Top:\n                case BackgroundAlignment.Bottom:\n                    this.repeatX = true;\n                    this.repeatY = false;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = alignment;\n                    break;\n            }\n        }\n\n        render(offsetX: number, offsetY: number) {\n            const w = screen.width;\n            const h = screen.height;\n            const pw = this.img.width;\n            const ph = this.img.height;\n\n            if (!pw || !ph) return; // empty image.\n\n            // left, top aligned\n            let rx = -offsetX;\n            let ry = -offsetY;\n\n            switch (this.alignX) {\n                case BackgroundAlignment.Right: rx -= (w + pw); break;\n                case BackgroundAlignment.Center: rx -= (w + pw) >> 1; break;\n            }\n            switch (this.alignY) {\n                case BackgroundAlignment.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignment.Center: ry -= (h + ph) >> 1; break;\n            }\n\n            rx %= w; if (rx < 0) rx += w;\n            ry %= h; if (ry < 0) ry += h;\n\n            // avoid subpixel aliasing\n            rx = Math.floor(rx);\n            ry = Math.floor(ry);\n\n            let y = 0;\n            let py = 0;\n            while (y < h) {\n                py = y % ph;\n                let dh = Math.min(ph - py, h - ry);\n                let x = 0;\n                let rxl = rx;\n                while (x < w) {\n                    let px = x % pw;\n                    let dw = Math.min(pw - px, w - rxl);\n                    screen.drawImage(this.img, rxl, ry);\n                    rxl = (rxl + dw) % w;\n                    x += this.repeatX ? dw : w;\n                }\n                ry = (ry + dh) % h;\n                y += this.repeatY ? dh : h;\n            }\n        }\n    }\n}",
      "camera.ts": "namespace scene {\n    export class Camera {\n        offsetX: number;\n        offsetY: number;\n        sprite: Sprite;\n        private oldOffsetX: number;\n        private oldOffsetY: number;\n\n        constructor() {\n            this.offsetX = 0;\n            this.offsetY = 0;\n\n            this.oldOffsetX = 0;\n            this.oldOffsetY = 0;\n        }\n\n        update() {\n            const scene = game.currentScene();\n\n            // if sprite, follow sprite\n            if (this.sprite) {\n                this.offsetX = this.sprite.x - (screen.width >> 1);\n                this.offsetY = this.sprite.y - (screen.height >> 1);\n            }\n\n            // don't escape tile map\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this.offsetX = scene.tileMap.offsetX(this.offsetX);\n                this.offsetY = scene.tileMap.offsetY(this.offsetY);\n            }\n\n            this.offsetX |= 0;\n            this.offsetY |= 0;\n\n            if (this.oldOffsetX != this.offsetX\n                || this.oldOffsetY != this.offsetY) {\n                this.oldOffsetX = this.offsetX;\n                this.oldOffsetY = this.offsetY;\n            }\n        }\n    }\n}",
      "controller.ts": "namespace controller {\n    interface ControlledSprite {\n        s: Sprite;\n        vx: number;\n        vy: number;\n    }\n\n    let controlledSprites: ControlledSprite[];\n\n    /**\n     * Control a sprite using the direction buttons from the controller. Note that this\n     * control will take over the vx and vy of the sprite and overwrite any changes\n     * made unless a 0 is passed.\n     *\n     * @param sprite The Sprite to control\n     * @param vx The velocity used for horizontal movement when left/right is pressed\n     * @param vy The velocity used for vertical movement when up/down is pressed\n     */\n    //% blockId=\"game_control_sprite\" block=\"control sprite $sprite=variables_get(mySprite) with vx $vx vy $vy\"\n    //% weight=100\n    //% vx.defl=100 vy.defl=100\n    //% help=controller/control-sprite\n    export function controlSprite(sprite: Sprite, vx: number, vy: number) {\n        if (!sprite) return;\n        if (!controlledSprites) {\n            controlledSprites = [];\n            game.currentScene().eventContext.registerFrameHandler(19, () => {\n                control.enablePerfCounter(\"controller\")\n                controlledSprites.forEach(controlled => {\n                    if (controlled.vx) {\n                        controlled.s.vx = 0;\n\n                        if (controller.right.isPressed()) {\n                            controlled.s.vx = controlled.vx;\n                        }\n                        if (controller.left.isPressed()) {\n                            controlled.s.vx = -controlled.vx;\n                        }\n                    }\n\n                    if (controlled.vy) {\n                        controlled.s.vy = 0;\n\n                        if (controller.down.isPressed()) {\n                            controlled.s.vy = controlled.vy;\n                        }\n                        if (controller.up.isPressed()) {\n                            controlled.s.vy = -controlled.vy;\n                        }\n                    }\n                });\n            });\n        }\n\n        for (let i = 0; i < controlledSprites.length; i++) {\n            if (controlledSprites[i].s.id === sprite.id) {\n                controlledSprites[i].vx = vx;\n                controlledSprites[i].vy = vy;\n                return;\n            }\n        }\n        controlledSprites.push({ s: sprite, vx: vx, vy: vy });\n    }\n}\n",
      "game.ts": "/**\n * Game transitions and dialog\n **/\n//% color=#008272 weight=99 icon=\"\\uf111\"\n//% groups='[\"Gameplay\", \"Prompt\"]'\nnamespace game {\n    /**\n     * Determins if diagnostics are shown\n     */\n    export let debug = false;\n    export let gameOverSound: () => void = undefined;\n\n    let _scene: scene.Scene;\n    let _sceneStack: scene.Scene[];\n\n    export function currentScene(): scene.Scene {\n        init();\n        return _scene;\n    }\n\n    let __waitAnyButton: () => void\n    let __isOver = false;\n\n    export function setWaitAnyButton(f: () => void) {\n        __waitAnyButton = f\n    }\n\n    export function waitAnyButton() {\n        if (__waitAnyButton) __waitAnyButton()\n        else pause(3000)\n    }\n\n    export function eventContext(): control.EventContext {\n        init();\n        return _scene.eventContext;\n    }\n\n    function init() {\n        if (!_scene) _scene = new scene.Scene(control.pushEventContext());\n        _scene.init();\n    }\n\n    export function pushScene() {\n        init();\n        if (!_sceneStack) _sceneStack = [];\n        _sceneStack.push(_scene);\n        _scene = undefined;\n        init();\n    }\n\n    export function popScene() {\n        init();\n        if (_sceneStack && _sceneStack.length) {\n            _scene = _sceneStack.pop();\n            control.popEventContext();\n        }\n    }\n\n    function showDialogBackground(h: number, c: number) {\n        const top = (screen.height - h) >> 1;\n        screen.fillRect(0, top, screen.width, h, 0)\n        screen.drawLine(0, top, screen.width, top, 1)\n        screen.drawLine(0, top + h - 1, screen.width, top + h - 1, 1)\n\n        return top;\n    }\n\n    export function showDialog(title: string, subtitle: string, footer?: string) {\n        init();\n        const font = image.font8;\n        let h = 8;\n        if (title)\n            h += font.charHeight;\n        if (subtitle)\n            h += 2 + font.charHeight\n        h += 8;\n        const top = showDialogBackground(h, 9)\n        if (title)\n            screen.print(title, 8, top + 8, screen.isMono ? 1 : 7, font);\n        if (subtitle)\n            screen.print(subtitle, 8, top + 8 + font.charHeight + 2, screen.isMono ? 1 : 6, font);\n        if (footer) {\n            screen.print(\n                footer,\n                screen.width - footer.length * font.charWidth - 8,\n                screen.height - font.charHeight - 2,\n                1,\n                font\n            )\n        }\n    }\n\n    function meltScreen() {\n        for (let i = 0; i < 10; ++i) {\n            for (let j = 0; j < 1000; ++j) {\n                let x = Math.randomRange(0, screen.width - 1)\n                let y = Math.randomRange(0, screen.height - 3)\n                let c = screen.getPixel(x, y)\n                screen.setPixel(x, y + 1, c)\n                screen.setPixel(x, y + 2, c)\n            }\n            pause(100)\n        }\n    }\n\n    /**\n     * Finish the game and display the score\n     */\n    //% group=\"Gameplay\"\n    //% blockId=gameOver block=\"game over||win %win\"\n    //% weight=80 help=game/over\n    export function over(win: boolean = false) {\n        init();\n        if (__isOver) return\n        __isOver = true;\n        // clear all handlers\n        control.pushEventContext();\n        // one last screenshot\n        takeScreenshot();\n        control.runInParallel(() => {\n            if (gameOverSound) gameOverSound();\n            meltScreen();\n            let top = showDialogBackground(44, 4)\n            screen.printCenter(win ? \"YOU WIN!\" : \"GAME OVER!\", top + 8, screen.isMono ? 1 : 5, image.font8)\n            if (info.hasScore()) {\n                screen.printCenter(\"Score:\" + info.score(), top + 23, screen.isMono ? 1 : 2, image.font8)\n                if (info.score() > info.highScore()) {\n                    info.saveHighScore();\n                    screen.printCenter(\"New High Score!\", top + 34, screen.isMono ? 1 : 2, image.font5);\n                } else {\n                    screen.printCenter(\"HI\" + info.highScore(), top + 34, screen.isMono ? 1 : 2, image.font8);\n                }\n            }\n            pause(2000) // wait for users to stop pressing keys\n            waitAnyButton()\n            control.reset()\n        })\n    }\n\n    /**\n     * Tells the game host to grab a screenshot\n     */\n    //% shim=game::takeScreenshot\n    declare function takeScreenshot(): void;\n\n    /**\n     * Update the position and velocities of sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/update weight=100 afterOnStart=true\n    //% blockId=gameupdate block=\"on game update\"\n    //% blockAllowMultiple=1\n    export function onUpdate(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(20, a);\n    }\n\n    /**\n     * Run code on an interval of time. This executes before game.onUpdate()\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/interval weight=99 afterOnStart=true\n    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n    //% blockAllowMultiple=1\n    export function onUpdateInterval(period: number, a: () => void): void {\n        init();\n        if (!a || period < 0) return;\n        let timer = 0;\n        game.eventContext().registerFrameHandler(19, () => {\n            const time = control.millis();\n            if (timer <= time) {\n                timer = time + period;\n                a();\n            }\n        });\n    }\n\n    /**\n     * Draw on screen before sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/paint weight=10 afterOnStart=true\n    export function onPaint(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(75, a);\n    }\n}",
      "hitbox.ts": "namespace game {\n    export class Hitbox {\n        parent: Sprite;\n        ox: number;\n        oy: number;\n        width: number;\n        height: number;\n\n        constructor(parent: Sprite, width: number, height: number, ox: number, oy: number) {\n            this.width = width;\n            this.height = height;\n            this.parent = parent;\n            this.ox = ox;\n            this.oy = oy;\n        }\n\n        get left() {\n            return this.parent.left + this.ox;\n        }\n\n        get top() {\n            return this.parent.top + this.oy;\n        }\n\n        get right() {\n            return this.left + this.width - 1;\n        }\n\n        get bottom() {\n            return this.top + this.height - 1;\n        }\n    }\n\n\n    export function calculateHitBoxes(s: Sprite): Hitbox[] {\n        const i = s.image;\n        let minX = i.width;\n        let minY = i.height;\n        let maxX = 0;\n        let maxY = 0;\n\n        for (let c = 0; c < i.width; c++) {\n            for (let r = 0; r < i.height; r++) {\n                if (i.getPixel(c, r)) {\n                    minX = Math.min(minX, c);\n                    minY = Math.min(minY, r);\n                    maxX = Math.max(maxX, c);\n                    maxY = Math.max(maxY, r);\n                }\n            }\n        }\n\n        const width = maxX - minX + 1;\n        const height = maxY - minY + 1;\n        if (width <= 0 || height <= 0) {\n            return [];\n        }\n        else if (width < 16 && height < 16) {\n            return [new Hitbox(s, width, height, minX, minY)]\n        }\n\n        const rows = Math.idiv(height, 15) + 1;\n        const columns = Math.idiv(width, 15) + 1;\n        const boxes: Hitbox[] = [];\n        for (let c = 0; c < columns; c++) {\n            let boxWidth = 15;\n            if (c === columns - 1) {\n                boxWidth = width % 15;\n            }\n\n            for (let r = 0; r < rows; r++) {\n                let boxHeight = 15;\n                if (r === rows - 1) {\n                    boxHeight = height % 15;\n                }\n                if (boxWidth > 0 && boxHeight > 0)\n                    boxes.push(new Hitbox(s, boxWidth, boxHeight, minX + c * 15, minY + r * 15));\n            }\n        }\n        return boxes;\n    }\n}",
      "info.ts": "\n/**\n * Head-up display\n *\n*/\n//% color=#AA5585 weight=80 icon=\"\\uf2bb\"\nnamespace info {\n\n    enum Visibility {\n        None = 0,\n        Countdown = 1 << 0,\n        Score = 1 << 1,\n        Life = 1 << 2,\n        All = ~(~0 << 3)\n    }\n\n    let _score: number = null;\n    let _highScore: number = null;\n    let _life: number = null;\n    let _hud: boolean = false;\n    let _gameEnd: number = undefined;\n    let _heartImage: Image;\n    let _multiplierImage: Image;\n    let _bgColor: number;\n    let _borderColor: number;\n    let _fontColor: number;\n    let _countdownExpired: boolean;\n    let _visibilityFlag: number = Visibility.None;\n\n\n    let _lifeOverHandler: () => void;\n    let _countdownEndHandler: () => void;\n\n    /**\n     * Color of the HUD display\n     */\n    let color = 1;\n\n    function initHUD() {\n        if (_hud) return;\n        _hud = true;\n\n        _heartImage = _heartImage || defaultHeartImage();\n\n        _multiplierImage = _multiplierImage || img`\n        1 . . . 1\n        . 1 . 1 .\n        . . 1 . .\n        . 1 . 1 .\n        1 . . . 1\n        `;\n\n        _bgColor = screen.isMono ? 0 : 1;\n        _borderColor = screen.isMono ? 1 : 3;\n        _fontColor = screen.isMono ? 1 : 3;\n        game.eventContext().registerFrameHandler(95, () => {\n            control.enablePerfCounter(\"info\")\n            // show score\n            if (_score !== null && _visibilityFlag & Visibility.Score) {\n                drawScore();\n            }\n            // show life\n            if (_life !== null && _visibilityFlag & Visibility.Life) {\n                drawLives();\n                if (_life <= 0) {\n                    _life = null;\n                    if (_lifeOverHandler) {\n                        _lifeOverHandler();\n                    }\n                    else {\n                        game.over();\n                    }\n                }\n            }\n            // show countdown\n            if (_gameEnd !== undefined && _visibilityFlag & Visibility.Countdown) {\n                drawTimer(_gameEnd - control.millis())\n                let t = Math.max(0, _gameEnd - control.millis()) / 1000;\n                if (t <= 0) {\n                    t = 0;\n                    if (!_countdownExpired) {\n                        _countdownExpired = true;\n                        if (_countdownEndHandler) {\n                            _countdownEndHandler();\n                        }\n                        else {\n                            game.over();\n                        }\n                    }\n                }\n            }\n        })\n    }\n\n    function defaultHeartImage() {\n        return screen.isMono ?\n        img`\n        . 1 1 . 1 1 . .\n        1 . . 1 . . 1 .\n        1 . . . . . 1 .\n        1 . . . . . 1 .\n        . 1 . . . 1 . .\n        . . 1 . 1 . . .\n        . . . 1 . . . .\n`         :\n        img`\n        . c 2 2 . 2 2 .\n        c 2 2 2 2 2 4 2\n        c 2 2 2 2 4 2 2\n        c 2 2 2 2 2 2 2\n        . c 2 2 2 2 2 .\n        . . c 2 2 2 . .\n        . . . c 2 . . .\n        `;\n\n    }\n\n    function initScore() {\n        if (_score !== null) return\n        _score = 0;\n        _highScore = updateHighScore(_score);\n        updateFlag(Visibility.Score, true);\n        initHUD();\n    }\n\n    function initLife() {\n        if (_life !== null) return\n        _life = 3;\n        updateFlag(Visibility.Life, true);\n        initHUD();\n    }\n\n    /**\n     * Get the current score if any\n     */\n    //% weight=95 blockGap=8\n    //% blockId=hudScore block=\"score\"\n    //% help=info/score\n    export function score() {\n        initScore()\n        return _score || 0;\n    }\n\n    //%\n    export function hasScore() {\n        return _score !== null\n    }\n\n    /**\n     * Get the last recorded high score\n     */\n    //% weight=94\n    //% blockId=highScore block=\"high score\"\n    //% help=info/high-score\n    export function highScore(): number {\n        initScore();\n        return _highScore || 0;\n    }\n\n    /**\n     * Set the score\n     */\n    //% weight=93 blockGap=8\n    //% blockId=hudsetScore block=\"set score to %value\"\n    //% help=info/set-score\n    export function setScore(value: number) {\n        initScore()\n        _score = value | 0\n    }\n\n    /**\n     * Change the score by the given amount\n     * @param value the amount of change, eg: 1\n     */\n    //% weight=92\n    //% blockId=hudChangeScoreBy block=\"change score by %value\"\n    //% help=info/change-score-by\n    export function changeScoreBy(value: number) {\n        initScore();\n        setScore(_score + value)\n    }\n\n    /**\n     * Updates the high score based on the current score\n     */\n    export function saveHighScore() {\n        if (_score) {\n            updateHighScore(_score);\n        }\n    }\n\n    /**\n     * Get the number of lives\n     */\n    //% weight=85 blockGap=8\n    //% blockId=hudLife block=\"life\"\n    //% help=info/life\n    export function life() {\n        initLife()\n        return _life\n    }\n\n    //%\n    export function hasLife() {\n        return _life !== null\n    }\n\n    /**\n     * Set the number of lives\n     * @param value the number of lives, eg: 3\n     */\n    //% weight=84 blockGap=8\n    //% blockId=hudSetLife block=\"set life to %value\"\n    //% help=info/set-life\n    export function setLife(value: number) {\n        initLife()\n        _life = value | 0\n    }\n\n    /**\n     * Change the lives by the given amount\n     * @param value the change of lives, eg: -1\n     */\n    //% weight=83\n    //% blockId=hudChangeLifeBy block=\"change life by %value\"\n    //% help=info/change-life-by\n    export function changeLifeBy(value: number) {\n        initLife();\n        setLife(_life + value)\n    }\n\n    /**\n     * Run code when the player's life reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% weight=82\n    //% blockId=gamelifeevent block=\"on life zero\"\n    //% help=info/on-life-zero\n    export function onLifeZero(handler: () => void) {\n        _lifeOverHandler = handler;\n    }\n\n    /**\n     * Start a countdown of the given duration in seconds\n     * @param duration the duration of the countdown, eg: 10\n     */\n    //% blockId=gamecountdown block=\"start countdown %duration (s)\"\n    //% help=info/start-countdown weight=79 blockGap=8\n    export function startCountdown(duration: number) {\n        initHUD();\n        _gameEnd = control.millis() + duration * 1000;\n        updateFlag(Visibility.Countdown, true);\n        _countdownExpired = false;\n    }\n\n    /**\n     * Stop the current countdown and hides the timer display\n     */\n    //% blockId=gamestopcountdown block=\"stop countdown\" weight=78\n    //% help=info/stop-countdown\n    export function stopCountdown() {\n        _gameEnd = undefined;\n        updateFlag(Visibility.Countdown, false);\n        _countdownExpired = true;\n    }\n\n    /**\n     * Run code when the countdown reaches 0. If this function\n     * is not called then game.over() is called instead\n     */\n    //% blockId=gamecountdownevent block=\"on countdown end\" weight=77\n    //% help=info/on-countdown-end\n    export function onCountdownEnd(handler: () => void) {\n        _countdownEndHandler = handler;\n    }\n\n    /**\n     * Replaces the image used to represent the player's lives. Images\n     * should be no larger than 8x8\n     */\n    //%\n    export function setLifeImage(image: Image) {\n        _heartImage = image;\n    }\n\n    /**\n     * Set whether life should be displayed\n     * @param on if true, lives are shown; otherwise, lives are hidden\n     */\n    export function showLife(on: boolean) {\n        initLife();\n        updateFlag(Visibility.Life, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    export function showScore(on: boolean) {\n        initScore();\n        updateFlag(Visibility.Score, on);\n    }\n\n    /**\n     * Set whether score should be displayed\n     * @param on if true, score is shown; otherwise, score is hidden\n     */\n    export function showCountdown(on: boolean) {\n        updateFlag(Visibility.Countdown, on);\n    }\n\n\n    function updateFlag(flag: Visibility, on: boolean) {\n        if (on) _visibilityFlag |= flag;\n        else _visibilityFlag &= Visibility.All ^ flag;\n    }\n\n    /**\n     * Sets the color of the borders around the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    export function setBorderColor(color: number) {\n        _borderColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the background of the score, countdown, and life\n     * elements. Defaults to 1\n     * @param color The index of the color (0-15)\n     */\n    export function setBackgroundColor(color: number) {\n        _bgColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Sets the color of the text used in the score, countdown, and life\n     * elements. Defaults to 3\n     * @param color The index of the color (0-15)\n     */\n    export function setFontColor(color: number) {\n        _fontColor = Math.min(Math.max(color, 0), 15) | 0;\n    }\n\n    /**\n     * Get the current color of the borders around the score, countdown, and life\n     * elements\n     */\n    export function borderColor(): number {\n        return _borderColor ? _borderColor : 3;\n    }\n\n    /**\n     * Get the current color of the background of the score, countdown, and life\n     * elements\n     */\n    export function backgroundColor(): number {\n        return _bgColor ? _bgColor : 1;\n    }\n\n    /**\n     * Get the current color of the text usded in the score, countdown, and life\n     * elements\n     */\n    export function fontColor(): number {\n        return _fontColor ? _fontColor : 3;\n    }\n    \n    function drawTimer(millis: number) {\n        if (millis < 0) millis = 0;\n        millis |= 0;\n\n        const font = image.font8;\n        const smallFont = image.font5;\n        const seconds = Math.idiv(millis, 1000);\n        const width = font.charWidth * 5 - 2;\n        let left = (screen.width >> 1) - (width >> 1) + 1;\n        let color1 = _fontColor;\n        let color2 = _bgColor;\n\n        if (seconds < 10 && (seconds & 1) && !screen.isMono) {\n            const temp = color1;\n            color1 = color2;\n            color2 = temp;\n        }\n\n        screen.fillRect(left - 3, 0, width + 6, font.charHeight + 3, _borderColor)\n        screen.fillRect(left - 2, 0, width + 4, font.charHeight + 2, color2)\n\n\n        if (seconds < 60) {\n            left += 3\n            const top = 1;\n            const remainder = Math.idiv(millis % 1000, 10);\n\n            screen.print(formatDecimal(seconds) + \".\", left, top, color1, font)\n            const decimalLeft = left + 3 * font.charWidth - 2;\n            screen.print(formatDecimal(remainder), decimalLeft, top + 2, color1, smallFont)\n        }\n        else {\n            const minutes = Math.idiv(seconds, 60);\n            const remainder = seconds % 60;\n            screen.print(formatDecimal(minutes) + \":\" + formatDecimal(remainder), left, 1, color1, font);\n        }\n    }\n\n    function drawScore() {\n        const s = score() | 0;\n\n        let font: image.Font;\n        let offsetY: number;\n        if (s >= 1000000) {\n            offsetY = 2;\n            font = image.font5;\n        }\n        else {\n            offsetY = 1;\n            font = image.font8;\n        }\n\n        const num = s.toString();\n        const width = num.length * font.charWidth;\n\n        screen.fillRect(screen.width - width - 2, 0, screen.width, image.font8.charHeight + 3, _borderColor)\n        screen.fillRect(screen.width - width - 1, 0, screen.width, image.font8.charHeight + 2, _bgColor)\n        screen.print(num, screen.width - width, offsetY, _fontColor, font);\n    }\n\n    function drawLives() {\n        if (_life <= 0) return;\n\n        const font = image.font8;\n        if (_life <= 4) {\n            screen.fillRect(0, 0, _life * (_heartImage.width + 1) + 3, _heartImage.height + 4, _borderColor);\n            screen.fillRect(0, 0, _life * (_heartImage.width + 1) + 2,  _heartImage.height + 3, _bgColor);\n            for (let i = 0; i < _life; i++) {\n                screen.drawTransparentImage(_heartImage, 1 + i * (_heartImage.width + 1), 1);\n            }\n        }\n        else {\n            const num = _life.toString();\n            const textWidth = num.length * font.charWidth - 1;\n            screen.fillRect(0, 0, _heartImage.width + _multiplierImage.width + textWidth + 5, _heartImage.height + 4, _borderColor)\n            screen.fillRect(0, 0, _heartImage.width + _multiplierImage.width + textWidth + 4, _heartImage.height + 3, _bgColor)\n            screen.drawTransparentImage(_heartImage, 1, 1);\n\n            let mult = _multiplierImage.clone();\n            mult.replace(1, _fontColor);\n\n            screen.drawTransparentImage(mult, _heartImage.width + 2,  font.charHeight - _multiplierImage.height - 1);\n            screen.print(num, _heartImage.width + 3 + _multiplierImage.width, 1, _fontColor, font);\n        }\n    }\n\n    function formatDecimal(val: number) {\n        val |= 0;\n        if (val < 10) {\n            return \"0\" + val;\n        }\n        return val.toString();\n    }\n}\n\ndeclare namespace info {\n    /**\n     * Sends the current score and the new high score\n     */\n    //% shim=info::updateHighScore\n    function updateHighScore(score: number): number;\n}\n",
      "mathUtil.ts": "namespace Math {\n    /**\n     * Returns a random boolean that is true the given percentage of the time.\n     * @param percentage The percentage chance that the returned value will be true from 0 - 100\n     */\n    //% weight=2\n    //% blockId=percentchance block=\"%percentage|\\\\% chance\"\n    //% percentage.min=0 percentage.max=100;\n    export function percentChance(percentage: number): boolean {\n        if (percentage >= 100) {\n            return true;\n        }\n        else if (percentage <= 0) {\n            return false;\n        }\n        return Math.randomRange(0, 99) < percentage;\n    }\n\n    /**\n     * Returns a random element from the given list\n     * @param list The list to choose an element from\n     */\n    //% weight=1\n    //% blockId=pickrandomarray block=\"random item from %list=variables_get\"\n    export function pickRandom<T>(list: T[]) {\n        if (!list || list.length == 0) {\n            return undefined;\n        }\n        return list[Math.randomRange(0, list.length - 1)];\n    }\n}",
      "metrics.ts": "namespace performance {\n\n}",
      "obstacle.ts": "namespace sprites {\n    enum ObstacleFlags {\n        Moved = 1 << 4,\n        Dead = 1 << 5\n    }\n\n    export interface Obstacle {\n        x: number;\n        y: number;\n        left: number;\n        right: number;\n        top: number;\n        bottom: number;\n        width: number;\n        height: number;\n        layer: number;\n        image: Image;\n        tileIndex: number;\n    }\n\n    export class StaticObstacle implements Obstacle {\n        layer: number;\n        image: Image;\n        tileIndex: number;\n\n        top: number;\n        left: number;\n\n        constructor(image: Image, top: number, left: number, layer: number, tileIndex?: number) {\n            this.image = image;\n            this.layer = layer;\n            this.top = top;\n            this.left = left;\n            this.tileIndex = tileIndex;\n        }\n\n        get x(): number {\n            return this.left + this.width >> 1;\n        }\n\n        get y(): number {\n            return this.top + this.height >> 1;\n        }\n\n        get height(): number {\n            return this.image.height;\n        }\n\n        get width(): number {\n            return this.image.width;\n        }\n\n        get bottom(): number {\n            return this.top + this.height;\n        }\n\n        get right(): number {\n            return this.left + this.width;\n        }\n    }\n}",
      "physics.ts": "class PhysicsEngine {\n    constructor() {\n    }\n\n    /**\n     * Adds sprite to the physics\n     * @param sprite\n     */\n    addSprite(sprite: Sprite) { }\n\n    removeSprite(sprite: Sprite) { }\n\n    moveSprite(s: Sprite, tm: tiles.TileMap, dx: number, dy: number) { }\n\n    draw() { }\n\n    /** Apply physics */\n    move(dt: number) { }\n\n    /**\n     * Apply collisions\n     */\n    collisions() { }\n\n    overlaps(sprite: Sprite): Sprite[] { return []; }\n}\n\nconst MAX_DISTANCE = 15; // pixels\nconst MAX_TIME_STEP = 0.1; // seconds\nconst MAX_VELOCITY = MAX_DISTANCE / MAX_TIME_STEP;\nconst GAP = 0.1;\n\n/**\n * A physics engine that does simple AABB bounding box check\n */\nclass ArcadePhysicsEngine extends PhysicsEngine {\n    protected sprites: Sprite[];\n    protected map: sprites.SpriteMap;\n\n    constructor() {\n        super();\n        this.sprites = [];\n    }\n\n    addSprite(sprite: Sprite) {\n        this.sprites.push(sprite);\n    }\n\n    removeSprite(sprite: Sprite) {\n        this.sprites.removeElement(sprite);\n    }\n\n    draw() {\n        if (this.map)\n            this.map.draw();\n    }\n\n    move(dt: number) {\n        dt = Math.min(MAX_TIME_STEP, dt);\n        const dt2 = dt / 2;\n\n        const tm = game.currentScene().tileMap;\n\n        for (let s of this.sprites) {\n            const ovx = constrain(s.vx);\n            const ovy = constrain(s.vy);\n\n            s.vx = constrain(s.vx + s.ax * dt)\n            s.vy = constrain(s.vy + s.ay * dt)\n\n            this.moveSprite(s, tm, (s.vx + ovx) * dt2, (s.vy + ovy) * dt2);\n        }\n    }\n\n    collisions() {\n        control.enablePerfCounter(\"phys_collisions\")\n\n        // 1: clear obstacles\n        for (let i = 0; i < this.sprites.length; ++i)\n            this.sprites[i].clearObstacles();\n\n        // 2: refresh non-ghost collision map\n        const colliders = this.sprites.filter(sprite => !(sprite.flags & sprites.Flag.Ghost));\n\n        if (colliders.length < 10) {\n            // not enough sprite, just brute force it\n            this.map = undefined;\n        } else {\n            if (!this.map) this.map = new sprites.SpriteMap();\n            this.map.update(colliders);\n        }\n\n        // 3: go through sprite and handle collisions\n        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        for (const sprite of colliders) {\n            const overSprites = scene.physicsEngine.overlaps(sprite);\n            for (const overlapper of overSprites) {\n                // overlap handler\n                const tmpsprite = sprite;\n                const tmp = overlapper;\n                const oh = sprite.overlapHandler;\n                if (oh)\n                    oh(tmp)\n                scene.overlapHandlers\n                    .filter(h => h.type == sprite.type && h.otherType == overlapper.type)\n                    .forEach(h => h.handler(tmpsprite, tmp));\n            }\n\n            const xDiff = sprite.x - sprite._lastX;\n            const yDiff = sprite.y - sprite._lastY;\n            if ((xDiff !== 0 || yDiff !== 0) && Math.abs(xDiff) < MAX_DISTANCE && Math.abs(yDiff) < MAX_DISTANCE) {\n                // Undo the move\n                sprite.x = sprite._lastX;\n                sprite.y = sprite._lastY;\n\n                // Now move it with the tilemap in mind\n                this.moveSprite(sprite, tm, xDiff, yDiff);\n            }\n        }\n    }\n\n    /**\n     * Returns sprites that overlap with the given sprite. If type is non-zero, also filter by type.\n     * @param sprite\n     * @param layer\n     */\n    overlaps(sprite: Sprite): Sprite[] {\n        if (this.map)\n            return this.map.overlaps(sprite);\n        else {\n            // brute force\n            const layer = sprite.layer;\n            const r: Sprite[] = [];\n            const n = this.sprites.length;\n            for (let i = 0; i < n; ++i) {\n                if ((layer & this.sprites[i].layer)\n                    && sprite.overlapsWith(this.sprites[i]))\n                    r.push(this.sprites[i]);\n            }\n            return r;\n        }\n    }\n\n    public moveSprite(s: Sprite, tm: tiles.TileMap, dx: number, dy: number) {\n        if (dx === 0 && dy === 0) {\n            s._lastX = s.x;\n            s._lastY = s.y;\n            return;\n        }\n\n        if (tm && tm.enabled && !(s.flags & sprites.Flag.Ghost)) {\n            s._hitboxes.forEach(box => {\n                const t0 = box.top >> 4;\n                const r0 = box.right >> 4;\n                const b0 = box.bottom >> 4;\n                const l0 = box.left >> 4;\n\n                if (dx > 0) {\n                    let topCollide = tm.isObstacle(r0 + 1, t0);\n                    if (topCollide || tm.isObstacle(r0 + 1, b0)) {\n                        const nextRight = box.right + dx;\n                        const maxRight = ((r0 + 1) << 4) - GAP\n                        if (nextRight > maxRight) {\n                            dx -= (nextRight - maxRight);\n                            s.registerObstacle(CollisionDirection.Right, tm.getObstacle(r0 + 1, topCollide ? t0 : b0))\n                        }\n                    }\n                }\n                else if (dx < 0) {\n                    const topCollide = tm.isObstacle(l0 - 1, t0);\n                    if (topCollide || tm.isObstacle(l0 - 1, b0)) {\n                        const nextLeft = box.left + dx;\n                        const minLeft = (l0 << 4) + GAP;\n                        if (nextLeft < minLeft) {\n                            dx -= (nextLeft - minLeft);\n                            s.registerObstacle(CollisionDirection.Left, tm.getObstacle(l0 - 1, topCollide ? t0 : b0))\n                        }\n                    }\n                }\n\n                if (dy > 0) {\n                    const rightCollide = tm.isObstacle(r0, b0 + 1);\n                    if (rightCollide || tm.isObstacle(l0, b0 + 1)) {\n                        const nextBottom = box.bottom + dy;\n                        const maxBottom = ((b0 + 1) << 4) - GAP;\n                        if (nextBottom > maxBottom) {\n                            dy -= (nextBottom - maxBottom);\n                            s.registerObstacle(CollisionDirection.Bottom, tm.getObstacle(rightCollide ? r0 : l0, b0 + 1))\n                        }\n                    }\n                }\n                else if (dy < 0) {\n                    const rightCollide = tm.isObstacle(r0, t0 - 1);\n                    if (tm.isObstacle(r0, t0 - 1) || tm.isObstacle(l0, t0 - 1)) {\n                        const nextTop = box.top + dy;\n                        const minTop = (t0 << 4) + GAP;\n                        if (nextTop < minTop) {\n                            dy -= (nextTop - minTop);\n                            s.registerObstacle(CollisionDirection.Top, tm.getObstacle(rightCollide ? r0 : l0, t0 - 1))\n                        }\n                    }\n                }\n\n                // Now check each corner and bump out if necessary. This step is needed for\n                // the case where a hitbox goes diagonally into the corner of a tile.\n                const t1 = (box.top + dy) >> 4;\n                const r1 = (box.right + dx) >> 4;\n                const b1 = (box.bottom + dy) >> 4;\n                const l1 = (box.left + dx) >> 4;\n\n                if (tm.isObstacle(r1, t1)) {\n                    // bump left\n                    dx -= (box.right + dx - ((r1 << 4) - GAP))\n                    s.registerObstacle(CollisionDirection.Right, tm.getObstacle(r1, t1));\n                }\n                else if (tm.isObstacle(l1, t1)) {\n                    // bump right\n                    dx -= (box.left + dx - (((l1 + 1) << 4) + GAP));\n                    s.registerObstacle(CollisionDirection.Left, tm.getObstacle(l1, t1));\n                }\n                else {\n                    const rightCollide = tm.isObstacle(r1, b1);\n                    if (rightCollide || tm.isObstacle(l1, b1)) {\n                        // bump up because that is usually better for platformers\n                        dy -= (box.bottom + dy - ((b1 << 4) - GAP));\n                        s.registerObstacle(CollisionDirection.Bottom, tm.getObstacle(rightCollide ? r1 : l1, b1));\n                    }\n                }\n            });\n        }\n\n        s.x += dx;\n        s.y += dy;\n        s._lastX = s.x;\n        s._lastY = s.y;\n    }\n}\n\nfunction constrain(v: number) {\n    if (v > MAX_VELOCITY)\n        return MAX_VELOCITY\n    if (v < -MAX_VELOCITY)\n        return -MAX_VELOCITY\n    return v\n    //return Math.abs(v) > MAX_VELOCITY ? Math.sign(v) * MAX_VELOCITY : v;\n}",
      "prompt.ts": "namespace game {\n    export interface PromptTheme {\n        colorPrompt: number;\n        colorInput: number;\n        colorInputHighlighted: number;\n        colorInputText: number;\n        colorAlphabet: number;\n        colorCursor: number;\n        colorBackground: number;\n        colorBottomBackground: number;\n        colorBottomText: number;\n    }\n\n    /**\n     * Ask the player for a string value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of characters the user can enter (1 - 24)\n     */\n    //% group=\"Gameplay\"\n    //% weight=10 help=game/ask-for-string\n    //% blockId=gameaskforstring block=\"ask for string with text %message || and max length %answerLength\"\n    //% message.defl=\"\"\n    //% answerLength.defl=\"12\"\n    //% answerLength.min=1\n    //% answerLength.max=24\n    //% group=\"Prompt\"\n    export function askForString(message: string, answerLength = 12) {\n        let p = new game.Prompt();\n        const result = p.show(message, answerLength);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8;\n    //% whenUsed=true\n    const PADDING = 4;\n    //% whenUsed=true\n    const PROMPT_LINE_SPACING = 2;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 26;\n    //% whenUsed=true\n    const ALPHABET_ROW_LENGTH = 12;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 2;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_WIDTH = Math.floor(CONTENT_WIDTH / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const CELL_HEIGHT = CELL_WIDTH;\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING + CELL_WIDTH / 2 + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * ALPHABET_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_ALPHABET_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING + BOTTOM_BAR_ALPHABET_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_TOP = screen.height - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_SHIFT_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 3) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n    //% whenUsed=true\n    const CONFIRM_BUTTON_LEFT = screen.width - BOTTOM_BAR_BUTTON_WIDTH;\n\n    // Dimensions of the alphabet area\n    //% whenUsed=true\n    const ALPHABET_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_TOP = CONTENT_TOP + CONTENT_HEIGHT - ALPHABET_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_INPUT_MARGIN = 10;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = ALPHABET_TOP - INPUT_HEIGHT - ALPHABET_INPUT_MARGIN;\n\n    // Dimensions of prompt message area\n    //% whenUsed=true\n    const PROMPT_HEIGHT = INPUT_TOP - CONTENT_TOP;\n\n    //% whenUsed=true\n    const lowerShiftText = \"ABC\";\n    //% whenUsed=true\n    const upperShiftText = \"abc\";\n    //% whenUsed=true\n    const digitsUpper = [\" \", \",\", \".\", \"?\", \"!\", \":\", \";\", \"\\\"\", \"(\", \")\"];\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class Prompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        private cursor: Sprite;\n        private shiftButton: Sprite;\n        private confirmButton: Sprite;\n\n        private letters: Sprite[];\n        private inputs: Sprite[];\n\n        private confirmPressed: boolean;\n        private cursorRow: number;\n        private cursorColumn: number;\n        private upper: boolean;\n        private inputIndex: number;\n        private blink: boolean;\n        private frameCount: number;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.upper = false;\n            this.inputIndex = 0;\n        }\n\n        show(message: string, answerLength: number) {\n            this.message = message;\n            this.answerLength = answerLength;\n            this.inputIndex = 0;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.draw();\n            this.registerHandlers();\n            this.confirmPressed = false;\n\n            pauseUntil(() => this.confirmPressed);\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return this.result;\n        }\n\n        private draw() {\n            this.drawPromptText();\n            this.drawKeyboard();\n            this.drawInputarea();\n            this.drawBottomBar();\n        }\n\n        private drawPromptText() {\n            const prompt = sprites.create(layoutText(this.message, CONTENT_WIDTH, PROMPT_HEIGHT, this.theme.colorPrompt), -1);\n            prompt.x = screen.width / 2\n            prompt.y = CONTENT_TOP + Math.floor((PROMPT_HEIGHT - prompt.height) / 2) + Math.floor(prompt.height / 2);\n        }\n\n        private drawInputarea() {\n            const answerLeft = ROW_LEFT + Math.floor(\n                ((CELL_WIDTH * ALPHABET_ROW_LENGTH) -\n                    CELL_WIDTH * Math.min(this.answerLength, ALPHABET_ROW_LENGTH)) / 2);\n\n            this.inputs = [];\n            for (let i = 0; i < this.answerLength; i++) {\n                const blank = image.create(CELL_WIDTH, CELL_HEIGHT);\n                this.drawInput(blank, \"\", this.theme.colorInput);\n\n                const col = i % ALPHABET_ROW_LENGTH;\n                const row = Math.floor(i / ALPHABET_ROW_LENGTH);\n\n                const s = sprites.create(blank, -1);\n                s.x = answerLeft + col * CELL_WIDTH;\n                s.y = INPUT_TOP + row * CELL_HEIGHT;\n                this.inputs.push(s);\n            }\n        }\n\n        private drawKeyboard() {\n            const cursorImage = image.create(CELL_WIDTH, CELL_HEIGHT);\n            cursorImage.fill(this.theme.colorCursor);\n            this.cursor = sprites.create(cursorImage, -1);\n            this.cursor.z = -1;\n            this.updateCursor();\n\n            this.letters = [];\n            for (let j = 0; j < 36; j++) {\n                const letter = image.create(CELL_WIDTH, CELL_HEIGHT);\n\n                const col2 = j % ALPHABET_ROW_LENGTH;\n                const row2 = Math.floor(j / ALPHABET_ROW_LENGTH);\n\n                const t = sprites.create(letter, -1);\n                t.x = ROW_LEFT + col2 * CELL_WIDTH;\n                t.y = ALPHABET_TOP + row2 * CELL_HEIGHT;\n\n                this.letters.push(t);\n            }\n            this.updateKeyboard();\n        }\n\n        private drawBottomBar() {\n            const bg = image.create(screen.width, BOTTOM_BAR_HEIGHT);\n            bg.fill(this.theme.colorBottomBackground);\n\n            const bgSprite = sprites.create(bg, -1);\n            bgSprite.x = screen.width / 2;\n            bgSprite.y = BOTTOM_BAR_TOP + BOTTOM_BAR_HEIGHT / 2;\n            bgSprite.z = -1;\n\n            this.shiftButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.shiftButton.x = Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.shiftButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.confirmButton = sprites.create(image.create(BOTTOM_BAR_BUTTON_WIDTH, BOTTOM_BAR_HEIGHT), -1);\n            this.confirmButton.x = CONFIRM_BUTTON_LEFT + Math.floor(BOTTOM_BAR_BUTTON_WIDTH / 2);\n            this.confirmButton.y = BOTTOM_BAR_TOP + Math.ceil(BOTTOM_BAR_HEIGHT / 2);\n\n            this.updateButtons();\n        }\n\n        private updateButtons() {\n            if (this.cursorRow === 3 && this.cursorColumn % 2 !== 1) {\n                this.shiftButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.shiftButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            if (this.upper) {\n                this.shiftButton.image.print(upperShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n            else {\n                this.shiftButton.image.print(lowerShiftText, BOTTOM_BAR_SHIFT_X, BOTTOM_BAR_TEXT_Y);\n            }\n\n\n            if (this.cursorRow === 3 && this.cursorColumn % 2) {\n                this.confirmButton.image.fill(this.theme.colorCursor);\n            }\n            else {\n                this.confirmButton.image.fill(this.theme.colorBottomBackground);\n            }\n\n            this.confirmButton.image.print(confirmText, BOTTOM_BAR_CONFIRM_X, BOTTOM_BAR_TEXT_Y);\n        }\n\n        private updateCursor() {\n            if (this.cursorRow === 3) {\n                this.cursor.image.fill(0);\n                this.updateButtons();\n            }\n            else {\n                this.cursor.x = ROW_LEFT + this.cursorColumn * CELL_WIDTH;\n                this.cursor.y = ALPHABET_TOP + this.cursorRow * CELL_HEIGHT;\n            }\n        }\n\n        private updateSelectedInput() {\n            if (this.inputIndex < this.answerLength) {\n                const u = this.inputs[this.inputIndex];\n                if (this.blink) {\n                    this.drawInput(u.image, \"\", this.theme.colorInput);\n                }\n                else {\n                    this.drawInput(u.image, \"\", this.theme.colorInputHighlighted)\n                }\n            }\n        }\n\n        private updateKeyboard() {\n            const len = this.letters.length;\n            for (let k = 0; k < len; k++) {\n                const img = this.letters[k].image;\n                img.fill(0);\n                img.print(getCharForIndex(k, this.upper), LETTER_OFFSET_X, LETTER_OFFSET_Y);\n            }\n        }\n\n        private drawInput(img: Image, char: string, color: number) {\n            img.fill(0);\n            img.fillRect(BLANK_PADDING, CELL_HEIGHT - 1, CELL_WIDTH - BLANK_PADDING * 2, 1, color)\n\n            if (char) {\n                img.print(char, LETTER_OFFSET_X, LETTER_OFFSET_Y, this.theme.colorInputText, font);\n            }\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n\n\n            this.frameCount = 0;\n            this.blink = true;\n\n            game.onUpdate(() => {\n                this.frameCount = (this.frameCount + 1) % 30;\n\n                if (this.frameCount === 0) {\n                    this.blink = !this.blink;\n\n                    this.updateSelectedInput();\n                }\n            })\n        }\n\n        private moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === 3) {\n                    this.cursor.image.fill(this.theme.colorCursor);\n                    this.cursorRow = 2;\n\n                    if (this.cursorColumn % 2) {\n                        this.cursorColumn = ALPHABET_ROW_LENGTH - 1;\n                    }\n                    else {\n                        this.cursorColumn = 0;\n                    }\n\n                    this.updateButtons();\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(3, this.cursorRow + 1);\n\n                if (this.cursorRow === 3) {\n                    // Go to closest button\n                    this.cursorColumn = this.cursorColumn > 5 ? 1 : 0;\n                }\n            }\n\n            this.updateCursor();\n        }\n\n        private moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % ALPHABET_ROW_LENGTH;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (ALPHABET_ROW_LENGTH - 1)) % ALPHABET_ROW_LENGTH;\n            }\n\n            this.updateCursor();\n        }\n\n        private confirm() {\n            if (this.cursorRow === 3) {\n                if (this.cursorColumn % 2) {\n                    this.confirmPressed = true;\n                }\n                else {\n                    this.upper = !this.upper;\n                    this.updateKeyboard();\n                    this.updateButtons();\n                }\n            }\n            else {\n                if (this.inputIndex >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * ALPHABET_ROW_LENGTH\n                const letter = getCharForIndex(index, this.upper);\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                const sprite = this.inputs[this.inputIndex];\n                this.changeInputIndex(1);\n                this.drawInput(sprite.image, letter, this.theme.colorInput);\n            }\n        }\n\n        private delete() {\n            if (this.inputIndex <= 0) return;\n\n            if (this.inputIndex < this.answerLength) {\n                this.drawInput(this.inputs[this.inputIndex].image, \"\", this.theme.colorInput);\n            }\n\n            this.result = this.result.substr(0, this.result.length - 1);\n\n            this.changeInputIndex(-1);\n        }\n\n        private changeInputIndex(delta: number) {\n            this.inputIndex += delta;\n            this.frameCount = 0\n            this.blink = false;\n            this.updateSelectedInput();\n        }\n    }\n\n    function layoutText(message: string, width: number, height: number, color: number) {\n        const lineHeight = font.charHeight + PROMPT_LINE_SPACING;\n\n        const lineLength = Math.floor(width / font.charWidth);\n        const numLines = Math.floor(height / lineHeight);\n\n        let lines: string[] = [];\n        let word: string;\n        let line: string;\n\n        let pushWord = () => {\n            if (line) {\n                if (line.length + word.length + 1 > lineLength) {\n                    lines.push(line);\n                    line = word;\n                }\n                else {\n                    line = line + \" \" + word;\n                }\n            }\n            else {\n                line = word;\n            }\n\n            word = null;\n        }\n\n        for (let l = 0; l < message.length; l++) {\n            const char = message.charAt(l);\n\n            if (char === \" \") {\n                if (word) {\n                    pushWord();\n                }\n                else {\n                    word = \" \";\n                }\n            }\n            else if (!word) {\n                word = char;\n            }\n            else {\n                word += char;\n            }\n        }\n\n        if (word) {\n            pushWord();\n        }\n\n        if (line) {\n            lines.push(line);\n        }\n\n        let maxLineWidth = 0;\n        for (let m = 0; m < lines.length; m++) {\n            maxLineWidth = Math.max(maxLineWidth, lines[m].length);\n        }\n\n        const actualWidth = maxLineWidth * font.charWidth;\n        const actualHeight = lines.length * lineHeight;\n\n        const res = image.create(actualWidth, actualHeight);\n\n        for (let n = 0; n < lines.length; n++) {\n            if ((n + 1) > numLines) break;\n            res.print(lines[n], 0, n * lineHeight, color, font);\n        }\n\n        return res;\n    }\n\n    function getCharForIndex(index: number, upper: boolean) {\n        if (index < 26) {\n            return String.fromCharCode(index + (upper ? 65 : 97));\n        }\n        else {\n            if (upper) {\n                return digitsUpper[index - 26];\n            }\n            else {\n                return \"\" + (index - 26);\n            }\n        }\n    }\n}",
      "pxt.json": "{\n    \"name\": \"game\",\n    \"description\": \"The game and sprite library - beta\",\n    \"files\": [\n        \"controller.ts\",\n        \"hitbox.ts\",\n        \"sprites.ts\",\n        \"sprite.ts\",\n        \"spritemap.ts\",\n        \"spriteevents.ts\",\n        \"metrics.ts\",\n        \"obstacle.ts\",\n        \"physics.ts\",\n        \"info.ts\",\n        \"background.ts\",\n        \"tilemap.ts\",\n        \"camera.ts\",\n        \"scene.ts\",\n        \"scenes.ts\",\n        \"textDialogs.ts\",\n        \"game.ts\",\n        \"prompt.ts\",\n        \"ask.ts\",\n        \"targetoverrides.cpp\",\n        \"targetoverrides.ts\",\n        \"mathUtil.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"controller\": \"*\",\n        \"screen\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "scene.ts": "/**\n * Control the background, tiles and camera\n */\n//% groups='[\"Background\", \"Tiles\", \"Camera\"]'\nnamespace scene {\n    export enum Flag {\n        NeedsSorting = 1 << 1,\n    }\n\n    export interface SpriteHandler {\n        type: number;\n        handler: (sprite: Sprite) => void;\n    }\n\n    export interface OverlapHandler {\n        type: number;\n        otherType: number;\n        handler: (sprite: Sprite, otherSprite: Sprite) => void;\n    }\n\n    export interface CollisionHandler {\n        type: number;\n        tile: number;\n        handler: (sprite: Sprite) => void\n    }\n\n    export class Scene {\n        eventContext: control.EventContext;\n        background: Background;\n        tileMap: tiles.TileMap;\n        allSprites: SpriteLike[];\n        private spriteNextId: number;\n        spritesByKind: Sprite[][];\n        physicsEngine: PhysicsEngine;\n        camera: scene.Camera;\n        flags: number;\n        destroyedHandlers: SpriteHandler[];\n        createdHandlers: SpriteHandler[];\n        overlapHandlers: OverlapHandler[];\n        collisionHandlers: CollisionHandler[];\n\n        constructor(eventContext: control.EventContext) {\n            this.eventContext = eventContext;\n            this.flags = 0;\n            this.physicsEngine = new ArcadePhysicsEngine();\n            this.camera = new scene.Camera();\n            this.background = new Background(this.camera);\n            this.destroyedHandlers = [];\n            this.createdHandlers = [];\n            this.overlapHandlers = [];\n            this.collisionHandlers = [];\n            this.spritesByKind = [];\n        }\n\n        init() {\n            if (this.allSprites) return;\n\n            this.allSprites = [];\n            this.spriteNextId = 0;\n            scene.setBackgroundColor(0)\n            // update controller state\n            this.eventContext.registerFrameHandler(8, () => {\n                control.enablePerfCounter(\"controller_update\")\n                const dt = this.eventContext.deltaTime;\n                controller.__update(dt);\n            })\n            // update sprites in tilemap\n            this.eventContext.registerFrameHandler(9, () => {\n                control.enablePerfCounter(\"tilemap_update\")\n                if (this.tileMap) {\n                    this.tileMap.update(this.camera);\n                }\n            })\n            // apply physics 10\n            this.eventContext.registerFrameHandler(10, () => {\n                control.enablePerfCounter(\"physics\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.move(dt);\n            })\n            // user update 20\n            // apply collisions 30\n            this.eventContext.registerFrameHandler(30, () => {\n                control.enablePerfCounter(\"collisions\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.collisions();\n                this.camera.update();\n                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n            })\n            // render background 60\n            this.eventContext.registerFrameHandler(60, () => {\n                control.enablePerfCounter(\"render background\")\n                this.background.render();\n            })\n            // paint 75\n            // render sprites 90\n            this.eventContext.registerFrameHandler(90, () => {\n                control.enablePerfCounter(\"sprite_draw\")\n                if (this.flags & Flag.NeedsSorting)\n                this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n                for (const s of this.allSprites)\n                    s.__draw(this.camera);\n            })\n            // render diagnostics\n            this.eventContext.registerFrameHandler(150, () => {\n                if (game.debug)\n                    this.physicsEngine.draw();\n                // clear flags\n                this.flags = 0;\n            });\n            // update screen\n            this.eventContext.registerFrameHandler(200, control.__screen.update);\n        }\n\n        addSprite(sprite: SpriteLike) {\n            this.allSprites.push(sprite);\n            sprite.id = this.spriteNextId++;\n        }\n    }\n}",
      "scenes.ts": "/**\n * Control the background, tiles and camera\n */\n//% weight=88 color=\"#401255\" icon=\"\\uf1bb\"\n//% groups='[\"Screen\", \"Tiles\", \"Collisions\", \"Camera\"]'\n//% blockGap=8\nnamespace scene {\n    /**\n     * Get the width of the screen in pixels\n     */\n    //% blockId=scenescreenwidth block=\"screen width\"\n    //% group=\"Screen\"\n    //% weight=100 blockGap=8\n    //% help=scene/screen-width\n    export function screenWidth(): number {\n        return screen.width;\n    }\n\n    /**\n     * Gets the height of the screen in pixels\n     */\n    //% blockId=scenescreenheight block=\"screen height\"\n    //% group=\"Screen\"\n    //% weight=99\n    //% help=scene/screen-width\n    export function screenHeight(): number {\n        return screen.height;\n    }\n\n    /**\n     * Set the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=25\n    //% blockId=gamesetbackgroundcolor block=\"set background color to %color=colorindexpicker\"\n    //% help=scene/set-background-color\n    export function setBackgroundColor(color: number) {\n        const scene = game.currentScene();\n        scene.background.color = color;\n    }\n\n    /**\n     * Get the game background color\n     * @param color\n     */\n    //% group=\"Screen\"\n    //% weight=22\n    //% blockId=gamebackgroundcolor block=\"background color\"\n    //% help=scene/background-color\n    export function backgroundColor() : number {\n        const scene = game.currentScene();\n        return scene.background.color;\n    }\n\n    /**\n     * Set a picture as the background\n     */\n    //% group=\"Screen\"\n    //% weight=24\n    //% blockId=gamesetbackgroundimage block=\"set background image to %img=background_image_picker\"\n    //% help=scene/set-background-image\n    export function setBackgroundImage(img: Image) {\n        const scene = game.currentScene();\n        scene.background.image = img;\n    }\n\n    /**\n     * Get the current background image\n     */\n    //% weight=22\n    //% group=\"Screen\"\n    //% blockId=gamebackgroundimage block=\"background image\"\n    //% help=scene/background-image\n    export function backgroundImage(): Image {\n        const scene = game.currentScene();\n        return scene.background.image;\n    }\n\n    /**\n     * Adds a moving background layer\n     * @param distance distance of the layer which determines how fast it moves, eg: 10\n     * @param img\n     */\n    //% group=\"Screen\"\n    //% weight=10\n    export function addBackgroundLayer(image: Image, distance?: number, alignment?: BackgroundAlignment) {\n        const scene = game.currentScene();\n        if (image)\n            scene.background.addLayer(image, distance || 100, alignment || BackgroundAlignment.Bottom);\n    }\n\n    /**\n     * Set the map for placing tiles in the scene\n     * @param map\n     */\n    //% blockId=gamesettilemap block=\"set tile map to %map=tilemap_image_picker\"\n    //% group=\"Tiles\"\n    //% help=scene/set-tile-map\n    export function setTileMap(map: Image) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setMap(map);\n    }\n\n    /**\n     * Set a tile at the given index\n     * @param tile\n     * @param index\n     */\n    //% blockId=gamesettileat block=\"set %tile=gamegettile to %index=colorindexpicker\"\n    //% group=\"Tiles\"\n    //% weight=30\n    //% help=scene/set-tile-at\n    export function setTileAt(tile: tiles.Tile, index: number) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setTileAt(tile.x >> 4, tile.y >> 4, index);\n    }\n\n    /**\n     * Set an image as a tile at the given index. Tiles should be a 16x16 image\n     * @param index\n     * @param img\n     */\n    //% blockId=gamesettile block=\"set tile %index=colorindexpicker to %img=screen_image_picker||with wall %wall=toggleOnOff\"\n    //% group=\"Tiles\"\n    //% help=scene/set-tile\n    export function setTile(index: number, img: Image, wall?: boolean) {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        scene.tileMap.setTile(index, img, !!wall);\n    }\n\n    /**\n     * Get the tile at a position in the tile map\n     * @param col\n     * @param row\n     */\n    //% blockId=gamegettile block=\"tile col %col row %row\"\n    //% group=\"Tiles\" blockSetVariable=\"myTile\"\n    //% help=scene/get-tile\n    export function getTile(col: number, row: number): tiles.Tile {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTile(col, row);\n    }\n\n    /**\n     * Get all tiles in the tile map with the given index.\n     * @param index\n     */\n    //% blockId=gamegettilestype block=\"array of all %index=colorindexpicker tiles\"\n    //% group=\"Tiles\" blockSetVariable=\"tile list\"\n    //% help=scene/get-tiles-by-type\n    export function getTilesByType(index: number): tiles.Tile[] {\n        const scene = game.currentScene();\n        if (!scene.tileMap)\n            scene.tileMap = new tiles.TileMap();\n        return scene.tileMap.getTilesByType(index);\n    }\n\n    /**\n     * Set the game camera to follow a sprite\n     * @param sprite\n     */\n    //% blockId=camerafollow block=\"camera follow sprite %sprite=variables_get(mySprite)\"\n    //% group=\"Camera\"\n    //% help=scene/camera-follow-sprite\n    export function cameraFollowSprite(sprite: Sprite) {\n        const scene = game.currentScene();\n        scene.camera.sprite = sprite;\n    }\n\n    /**\n     * Moves the camera center to a coordinate position\n     * @param sprite\n     */\n    //% blockId=camerapos block=\"center camera at x %x y %y\"\n    //% group=\"Camera\"\n    //% help=scene/center-camera-at\n    export function centerCameraAt(x: number, y: number) {\n        const scene = game.currentScene();\n        scene.camera.sprite = undefined;\n        scene.camera.offsetX = x - (screen.width >> 1);\n        scene.camera.offsetY = y - (screen.height >> 1);\n    }\n}\n",
      "sprite.ts": "enum SpriteFlag {\n    //% block=\"ghost\"\n    Ghost = sprites.Flag.Ghost,\n    //% block=\"auto destroy\"\n    AutoDestroy = sprites.Flag.AutoDestroy,\n    //% block=\"stay in screen\"\n    StayInScreen = sprites.Flag.StayInScreen\n}\n\nenum CollisionDirection {\n    //% block=\"left\"\n    Left = 0,\n    //% block=\"top\"\n    Top = 1,\n    //% block=\"right\"\n    Right = 2,\n    //% block=\"bottom\"\n    Bottom = 3\n}\n\ninterface SpriteLike {\n    z: number;\n    id: number;\n    __update(camera: scene.Camera, dt: number): void;\n    __draw(camera: scene.Camera): void;\n}\n\nenum FlipOption {\n    //% block=none\n    None,\n    //% block=\"flip x\"\n    FlipX,\n    //% block=\"flip y\"\n    FlipY,\n    //% block=\"flip x+y\"\n    FlipXY\n}\n\n/**\n * A sprite on the screen\n **/\n//% blockNamespace=sprites color=\"#4B7BEC\" blockGap=8\nclass Sprite implements SpriteLike {\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x (horizontal position)\"\n    x: number\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y (vertical position)\"\n    y: number\n    private _z: number\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    vx: number\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    vy: number\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    ax: number\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    ay: number\n\n    _type: number;\n\n    /**\n     * A bitset of layer. Each bit is a layer, default is 1.\n     */\n    //% group=\"Properties\"\n    layer: number;\n\n    _lastX: number;\n    _lastY: number;\n\n    _action: number; //Used with animation library\n\n    /**\n     * Time to live in game ticks. The lifespan decreases by 1 on each game update\n     * and the sprite gets destroyed when it reaches 0.\n     */\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"lifespan\"\n    lifespan: number;\n    private _image: Image;\n    private _obstacles: sprites.Obstacle[];\n\n    private updateSay: (dt: number, camera: scene.Camera) => void;\n    private sayBubbleSprite: Sprite;\n\n    _hitboxes: game.Hitbox[];\n\n    flags: number\n    id: number\n\n    overlapHandler: (other: Sprite) => void;\n    collisionHandlers: (() => void)[][];\n    private destroyHandler: () => void;\n\n    constructor(img: Image) {\n        this.x = screen.width >> 1;\n        this.y = screen.height >> 1;\n        this._z = 0\n        this._lastX = this.x;\n        this._lastY = this.y;\n        this.vx = 0\n        this.vy = 0\n        this.ax = 0\n        this.ay = 0\n        this.flags = 0\n        this.setImage(img);\n        this.type = -1; // not a member of any type by default\n        this.layer = 1; // by default, in layer 1\n        this.lifespan = undefined;\n    }\n\n    /**\n     * Gets the current image\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n    //% weight=8\n    get image(): Image {\n        return this._image;\n    }\n\n    /**\n     * Sets the image on the sprite\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n    //% weight=7 help=sprites/sprite/set-image\n    setImage(img: Image) {\n        if (!img) return; // don't break the sprite\n\n        // Identify old upper left corner\n        let oMinX = img.width;\n        let oMinY = img.height;\n        let oMaxX = 0;\n        let oMaxY = 0;\n\n        for (let i = 0; this._hitboxes && i < this._hitboxes.length; ++i) {\n            let box = this._hitboxes[i];\n            oMinX = Math.min(oMinX, box.ox);\n            oMinY = Math.min(oMinY, box.oy);\n            oMaxX = Math.max(oMaxX, box.ox + box.width - 1);\n            oMaxY = Math.max(oMaxY, box.oy + box.height - 1);\n        }\n\n        this._image = img;\n        this._hitboxes = game.calculateHitBoxes(this);\n\n        // Identify new upper left corner\n        let nMinX = img.width;\n        let nMinY = img.height;\n        let nMaxX = 0;\n        let nMaxY = 0;\n\n        for (let i = 0; i < this._hitboxes.length; ++i) {\n            let box = this._hitboxes[i];\n            nMinX = Math.min(nMinX, box.ox);\n            nMinY = Math.min(nMinY, box.oy);\n            nMaxX = Math.max(nMaxX, box.ox + box.width - 1);\n            nMaxY = Math.max(nMaxY, box.oy + box.height - 1);\n        }\n\n        const minXDiff = oMinX - nMinX;\n        const minYDiff = oMinY - nMinY;\n        const maxXDiff = oMaxX - nMaxX;\n        const maxYDiff = oMaxY - nMaxY;\n\n        const scene = game.currentScene();\n        const tmap = scene.tileMap;\n\n        if (tmap && tmap.enabled && this.width <= 16 && this.height <= 16) {\n            const l = (nMinX + this.left) >> 4;\n            const r = (nMaxX + this.left) >> 4;\n            const t = (nMinY + this.top) >> 4;\n            const b = (nMaxY + this.top) >> 4;\n\n            if (tmap.isObstacle(l, t) && (minXDiff > 0 || minYDiff > 0)) {\n                scene.physicsEngine.moveSprite(this, scene.tileMap, minXDiff, minYDiff);\n            } else if (tmap.isObstacle(r, t) && (maxXDiff < 0 || minYDiff > 0)) {\n                scene.physicsEngine.moveSprite(this, scene.tileMap, maxXDiff, minYDiff);\n            } else if (tmap.isObstacle(l, b) && (minXDiff > 0 || maxYDiff < 0)) {\n                scene.physicsEngine.moveSprite(this, scene.tileMap, minXDiff, maxYDiff);\n            } else if (tmap.isObstacle(r, b) && (maxXDiff < 0 || maxYDiff < 0)) {\n                scene.physicsEngine.moveSprite(this, scene.tileMap, maxXDiff, maxYDiff);\n            }\n        }\n    }\n\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    get z(): number {\n        return this._z;\n    }\n\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    set z(value: number) {\n        if (value != this._z) {\n            this._z = value;\n            game.currentScene().flags |= scene.Flag.NeedsSorting;\n        }\n    }\n\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"width\"\n    get width() {\n        return this._image.width\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"height\"\n    get height() {\n        return this._image.height\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    get left() {\n        return this.x - (this.width >> 1)\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    set left(value: number) {\n        this.x = value + (this.width >> 1);\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    get right() {\n        return this.left + this.width\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    set right(value: number) {\n        this.x = value - (this.width >> 1);\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    get top() {\n        return this.y - (this.height >> 1)\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    set top(value: number) {\n        this.y = value + (this.height >> 1);\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    get bottom() {\n        return this.top + this.height\n    }\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    set bottom(value: number) {\n        this.y = value - (this.height >> 1);\n    }\n    /**\n     * The type of sprite\n     */\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"kind\"\n    get type() {\n        return this._type;\n    }\n    /**\n     * The type of sprite\n     */\n    //% group=\"Properties\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"kind\"\n    set type(value: number) {\n        if (value == undefined || this._type === value) return;\n\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (this._type >= 0 && spritesByKind[this._type])\n            spritesByKind[this._type].removeElement(this);\n\n        if (value >= 0) {\n            if (!spritesByKind[value]) spritesByKind[value] = [];\n            spritesByKind[value].push(this);\n        }\n\n        this._type = value;\n    }\n\n    /**\n     * Set the sprite position\n     * @param x horizontal position\n     * @param y vertical position\n     */\n    //% group=\"Properties\"\n    //% weight=100\n    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n    //% help=sprites/sprite/set-position\n    setPosition(x: number, y: number): void {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Display a speech bubble with the text, for the given time\n     * @param text the text to say, eg: \":)\"\n     * @param time time to keep text on\n     */\n    //% group=\"Properties\"\n    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n    //% inlineInputMode=inline\n    //% help=sprites/sprite/say\n    say(text: string, timeOnScreen?: number, textColor = 15, textBoxColor = 1) {\n\n        if (!text) {\n            this.updateSay = undefined;\n            if (this.sayBubbleSprite) {\n                this.sayBubbleSprite.destroy();\n            }\n            return;\n        }\n\n        \n\n        let pixelsOffset = 0;\n        let holdTextSeconds = 1.5;\n        let bubblePadding = 4;\n        let maxTextWidth = 100;\n        let font = image.font8;\n        let startX = 2;\n        let startY = 2;\n        let bubbleWidth = text.length * font.charWidth + bubblePadding;\n        let maxOffset = text.length * font.charWidth - maxTextWidth;\n        let bubbleOffset: number;\n        // sets the defaut scroll speed in pixels per second\n        let speed = 45;\n\n        // Calculates the speed of the scroll if scrolling is needed and a time is specified\n        if (timeOnScreen && maxOffset > 0) {\n            speed = (maxOffset + (2 * maxTextWidth)) / (timeOnScreen / 1000);\n            speed = Math.max(speed, 45);\n            holdTextSeconds = maxTextWidth / speed;\n            holdTextSeconds = Math.min(holdTextSeconds, 1.5);\n        } \n\n        if (timeOnScreen) {\n            timeOnScreen = timeOnScreen + control.millis();\n        }\n\n        if (!this._hitboxes || this._hitboxes.length == 0) {\n            bubbleOffset = 0;\n        } else {\n            bubbleOffset = this._hitboxes[0].top;\n            for (let i = 0; i < this._hitboxes.length; i++) {\n                bubbleOffset = Math.min(bubbleOffset, this._hitboxes[i].top);\n            }\n\n            // Gets the length from sprites location to its highest hitbox\n            bubbleOffset = this.y - bubbleOffset;\n        }\n\n\n        if (bubbleWidth > maxTextWidth + bubblePadding) {\n            bubbleWidth = maxTextWidth + bubblePadding;\n        } else {\n            maxOffset = -1;\n        }\n\n        // Destroy previous sayBubbleSprite to prevent leaking\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n\n        this.sayBubbleSprite = sprites.create(image.create(bubbleWidth, font.charHeight + bubblePadding), -1);\n\n        this.sayBubbleSprite.setFlag(SpriteFlag.Ghost, true);\n        this.updateSay = (dt, camera) => {\n            // Update box stuff as long as timeOnScreen doesn't exist or it can still be on the screen\n            if (!timeOnScreen || timeOnScreen > control.millis()) {\n                this.sayBubbleSprite.image.fill(textBoxColor);\n                // The minus 2 is how much transparent padding there is under the sayBubbleSprite\n                this.sayBubbleSprite.y = this.y - bubbleOffset - ((font.charHeight + bubblePadding) >> 1) - 2;\n                this.sayBubbleSprite.x = this.x;\n\n                if (!this.isOutOfScreen(camera)) {\n                    const ox = camera.offsetX;\n                    const oy = camera.offsetY;\n\n                    if (this.sayBubbleSprite.left - ox < 0) {\n                        this.sayBubbleSprite.left = 0;\n                    }\n\n                    if (this.sayBubbleSprite.right - ox > screen.width) {\n                        this.sayBubbleSprite.right = screen.width;\n                    }\n\n                    // If sprite bubble above the sprite gets cut off on top, place the bubble below the sprite\n                    if (this.sayBubbleSprite.top - oy < 0) {\n                        this.sayBubbleSprite.y = (this.sayBubbleSprite.y - 2 * this.y) * -1;\n                    }\n                }\n\n                // Pauses at beginning of text for holdTextSeconds length\n                if (holdTextSeconds > 0) {\n                    holdTextSeconds -= game.eventContext().deltaTime;\n                    // If scrolling has reached the end, start back at the beginning\n                    if (holdTextSeconds <= 0 && pixelsOffset > 0) {\n                        pixelsOffset = 0;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                } else {\n                    pixelsOffset += dt * speed;\n\n                    // Pause at end of text for holdTextSeconds length\n                    if (pixelsOffset >= maxOffset) {\n                        pixelsOffset = maxOffset;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                }\n                // If maxOffset is negative it won't scroll\n                if (maxOffset < 0) {\n                    this.sayBubbleSprite.image.print(text, startX, startY, textColor, font);\n                } else {\n                    this.sayBubbleSprite.image.print(text, startX - pixelsOffset, startY, textColor, font);\n                }\n\n                // Left side padding\n                this.sayBubbleSprite.image.fillRect(0, 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Right side padding\n                this.sayBubbleSprite.image.fillRect(bubbleWidth - (bubblePadding >> 1), 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Corners removed\n                this.sayBubbleSprite.image.setPixel(0, 0, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, 0, 0);\n                this.sayBubbleSprite.image.setPixel(0, font.charHeight + bubblePadding - 1, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, font.charHeight + bubblePadding - 1, 0);\n            } else {\n                // If can't update because of timeOnScreen then destroy the sayBubbleSprite and reset updateSay\n                this.sayBubbleSprite.destroy();\n                this.updateSay = undefined;\n            }\n        }\n    }\n\n    /**\n     * Indicates if the sprite is outside the screen\n     */\n    //%\n    isOutOfScreen(camera: scene.Camera): boolean {\n        const ox = camera.offsetX;\n        const oy = camera.offsetY;\n        return this.right - ox < 0 || this.bottom - oy < 0 || this.left - ox > screen.width || this.top - oy > screen.height;\n    }\n\n    __draw(camera: scene.Camera) {\n        if (this.isOutOfScreen(camera)) return;\n\n        const l = this.left - camera.offsetX;\n        const t = this.top - camera.offsetY;\n        screen.drawTransparentImage(this._image, l, t)\n\n        // debug info\n        if (game.debug) {\n            let color = 1;\n            this._hitboxes.forEach(box => {\n                this._image.drawRect(box.ox, box.oy, box.width, box.height, color);\n                color++;\n                if (color >= 15) color = 1;\n            });\n        }\n    }\n\n    __update(camera: scene.Camera, dt: number) {\n        if (this.lifespan !== undefined) {\n            this.lifespan -= dt * 1000;\n            if (this.lifespan <= 0) {\n                this.lifespan = undefined;\n                this.destroy();\n            }\n        }\n        if ((this.flags & sprites.Flag.AutoDestroy)\n            && this.isOutOfScreen(camera)) {\n            this.destroy()\n        }\n\n        if (this.flags & sprites.Flag.StayInScreen) {\n            if (this.left < camera.offsetX) {\n                this.left = camera.offsetX;\n            }\n            else if (this.right > camera.offsetX + screen.width) {\n                this.right = camera.offsetX + screen.width;\n            }\n\n            if (this.top < camera.offsetY) {\n                this.top = camera.offsetY;\n            }\n            else if (this.bottom > camera.offsetY + screen.height) {\n                this.bottom = camera.offsetY + screen.height;\n            }\n        }\n        // Say text\n        if (this.updateSay) {\n            this.updateSay(dt, camera);\n        }\n    }\n\n    /**\n     * Set a sprite flag\n     */\n    //% group=\"Properties\"\n    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n    //% flag.defl=SpriteFlag.StayInScreen\n    //% help=sprites/sprite/set-flag\n    setFlag(flag: SpriteFlag, on: boolean) {\n        if (on) this.flags |= flag\n        else this.flags = ~(~this.flags | flag);\n    }\n\n    /**\n     * Check if this sprite overlaps another sprite\n     * @param other\n     */\n    //% group=\"Overlaps\"\n    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n    //% help=sprites/sprite/overlaps-with\n    overlapsWith(other: Sprite) {\n        control.enablePerfCounter(\"overlapsCPP\")\n        if (other == this) return false;\n        if (this.flags & sprites.Flag.Ghost)\n            return false\n        if (other.flags & sprites.Flag.Ghost)\n            return false\n        return other._image.overlapsWith(this._image, this.left - other.left, this.top - other.top)\n    }\n\n    /**\n     * Registers code when the sprite overlaps with another sprite\n     * @param spriteType sprite type to match\n     * @param handler\n     */\n    //% group=\"Overlaps\"\n    //% afterOnStart=true\n    //% help=sprites/sprite/on-overlap\n    onOverlap(handler: (other: Sprite) => void) {\n        this.overlapHandler = handler;\n    }\n\n    /**\n     * Registers code when the sprite collides with an obstacle\n     * @param direction\n     * @param handler\n     */\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    onCollision(direction: CollisionDirection, tileIndex: number, handler: () => void) {\n        if (!this.collisionHandlers)\n            this.collisionHandlers = [];\n\n        direction = Math.max(0, Math.min(3, direction | 0));\n\n        if (!this.collisionHandlers[direction])\n            this.collisionHandlers[direction] = [];\n\n        this.collisionHandlers[direction][tileIndex] = handler;\n    }\n\n    /**\n     * Check if there is an obstacle in the given direction\n     * @param direction\n     */\n    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/is-hitting-tile\n    isHittingTile(direction: CollisionDirection): boolean {\n        return this._obstacles && !!this._obstacles[direction];\n    }\n\n    /**\n     * Get the obstacle sprite in a given direction if any\n     * @param direction\n     */\n    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/tile-hit-from\n    tileHitFrom(direction: CollisionDirection): number {\n        return (this._obstacles && this._obstacles[direction]) ? this._obstacles[direction].tileIndex : -1;\n    }\n\n    clearObstacles() {\n        this._obstacles = undefined;\n    }\n\n    registerObstacle(direction: CollisionDirection, other: sprites.Obstacle) {\n        if (other == undefined) return;\n        if (!this._obstacles)\n            this._obstacles = [];\n        this._obstacles[direction] = other;\n\n        const handler = (this.collisionHandlers && this.collisionHandlers[direction]) ? this.collisionHandlers[direction][other.tileIndex] : undefined;\n        if (handler) handler();\n        const scene = game.currentScene();\n        scene.collisionHandlers\n            .filter(h => h.type == this.type && h.tile == other.tileIndex)\n            .forEach(h => h.handler(this));\n    }\n\n    /**\n     * Run code when the sprite is destroyed\n     * @param handler\n     */\n    //% group=\"Lifecycle\"\n    //% weight=9\n    onDestroyed(handler: () => void) {\n        this.destroyHandler = handler\n    }\n\n    /**\n     * Destroy the sprite\n     */\n    //% group=\"Lifecycle\"\n    //% weight=10\n    //% blockId=spritedestroy block=\"destroy %sprite(mySprite)\"\n    //% help=sprites/sprite/destroy\n    destroy() {\n        if (this.flags & sprites.Flag.Destroyed)\n            return\n        this.flags |= sprites.Flag.Destroyed\n        const scene = game.currentScene();\n        // When current sprite is destroyed, destroys sayBubbleSprite if defined\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n        scene.allSprites.removeElement(this);\n        if (this.type >= 0 && scene.spritesByKind[this.type])\n            scene.spritesByKind[this.type].removeElement(this);\n        scene.physicsEngine.removeSprite(this);\n        if (this.destroyHandler)\n            this.destroyHandler();\n        scene.destroyedHandlers\n            .filter(h => h.type == this.type)\n            .forEach(h => h.handler(this));\n    }\n\n    toString() {\n        return `${this.id}(${this.x},${this.y})->(${this.vx},${this.vy})`;\n    }\n}",
      "spriteevents.ts": "namespace sprites {\n    /**\n     * Gets the sprite type\n     */\n    //% blockHidden=1 shim=ENUM_GET\n    //% blockId=spritetype block=\"$kind\" enumInitialMembers=\"Player,Enemy\"\n    //% enumName=SpriteKind enumMemberName=kind enumPromptHint=\"e.g. Coin, Fireball, Asteroid...\"\n    export function _spriteType(kind: number): number {\n        return kind;\n    }\n\n    /**\n     * Run code when a certain kind of sprite is created\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\" draggableParameters weight=97\n    //% blockId=spritesoncreated block=\"on created $sprite of kind $kind=spritetype\"\n    //% help=sprites/on-created\n    export function onCreated(kind: number, handler: (sprite: Sprite) => void): void {\n        if (!handler || kind == undefined) return;\n\n        const scene = game.currentScene();\n        scene.createdHandlers.push({\n            type: kind,\n            handler: handler\n        })\n    }\n\n    /**\n     * Run code when a certain kind of sprite is destroyed\n     * @param kind\n     * @param sprite\n     */\n    //% group=\"Lifecycle\"\n    //% weight=96 draggableParameters\n    //% blockId=spritesondestroyed block=\"on destroyed $sprite of kind $kind=spritetype \"\n    //% help=sprites/on-destroyed\n    export function onDestroyed(kind: number, handler: (sprite: Sprite) => void) {\n        if (!handler || kind == undefined) return;\n\n        const scene = game.currentScene();\n        scene.destroyedHandlers.push({\n            type: kind,\n            handler: handler\n        })\n    }\n\n    /**\n     * Run code when two kinds of sprites overlap\n     */\n    //% group=\"Overlaps\"\n    //% weight=100 draggableParameters\n    //% blockId=spritesoverlap block=\"on $sprite of kind $kind=spritetype overlaps $otherSprite of kind $otherKind=spritetype\"\n    //% help=sprites/on-overlap\n    export function onOverlap(kind: number, otherKind: number, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n        if (kind == undefined || otherKind == undefined ||!handler) return;\n\n        const scene = game.currentScene();\n        scene.overlapHandlers.push({\n            type: kind,\n            otherType: otherKind,\n            handler: handler\n        })\n    }\n}\n\nnamespace scene {\n    /**\n     * Run code when a certain kind of sprite hits a tile\n     * @param direction\n     * @param tile\n     * @param handler\n     */\n    //% group=\"Collisions\"\n    //% weight=100 draggableParameters\n    //% blockId=spritesollisions block=\"on $sprite of kind $kind=spritetype hits wall $tile=colorindexpicker\"\n    //% help=scene/on-hit-tile\n    export function onHitTile(kind: number, tile: number, handler: (sprite: Sprite) => void) {\n        if (kind == undefined || !handler) return;\n\n        const scene = game.currentScene();\n        scene.collisionHandlers.push({\n            type: kind,\n            tile: tile,\n            handler: handler\n        })\n    }\n}",
      "spritemap.ts": "namespace sprites {\n    export class SpriteMap {\n        private cellWidth: number;\n        private cellHeight: number;\n        private rowCount: number;\n        private columnCount: number;\n        private buckets: Sprite[][];\n\n        constructor() {\n            this.buckets = [];\n        }\n\n        /**\n         * Returns a potential list of neighbors\n         */\n        neighbors(sprite: Sprite): Sprite[] {\n            if (this.isOob(sprite)) return [];\n\n            const n: Sprite[] = [];\n            const layer = sprite.layer;\n            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n            n.removeElement(sprite);\n            return n;\n        }\n\n        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n        overlaps(sprite: Sprite): Sprite[] {\n            const n = this.neighbors(sprite);\n            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n        }\n\n        draw() {\n            for (let x = 0; x < this.columnCount; ++x) {\n                for (let y = 0; y < this.rowCount; ++y) {\n                    const left = x * this.cellWidth;\n                    const top = y * this.cellHeight;\n                    const k = this.key(left, top);\n                    const b = this.buckets[k];\n                    if (b && b.length)\n                        screen.drawRect(left, top, this.cellWidth, this.cellHeight, 5);\n                }\n            }\n        }\n\n        /**\n         * Recompute hashes for all objects\n         */\n        update(sprites: Sprite[]) {\n            this.buckets = [];\n\n            // rescale buckets\n            let maxWidth = 0;\n            let maxHeight = 0;\n            for (const sprite of sprites) {\n                if (sprite.width > maxWidth) maxWidth = sprite.width;\n                if (sprite.height > maxHeight) maxHeight = sprite.height;\n            }\n\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n\n            this.cellWidth = Math.clamp(8, areaWidth >> 2, maxWidth * 2);\n            this.cellHeight = Math.clamp(8, areaHeight >> 2, maxHeight * 2);\n            this.rowCount = Math.idiv(areaHeight, this.cellHeight)\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth)\n\n\n            for (const sprite of sprites)\n                this.insertAABB(sprite);\n        }\n\n        private key(x: number, y: number): number {\n            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n            return xi + yi * this.columnCount;\n        }\n\n        private insertAtKey(x: number, y: number, sprite: Sprite) {\n            const k = this.key(x, y);\n            let bucket = this.buckets[k];\n            if (!bucket)\n                bucket = this.buckets[k] = [];\n            if (bucket.indexOf(sprite) < 0)\n                bucket.push(sprite);\n        }\n\n        private isOob(sprite: Sprite): boolean {\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n            return sprite.right < 0 || sprite.left > areaWidth || sprite.bottom < 0 || sprite.top > areaHeight;\n        }\n\n        private insertAABB(sprite: Sprite) {\n            // is object completely out of space?\n            if (this.isOob(sprite) || (sprite.flags & sprites.Flag.Ghost))\n                return;\n\n            const left = sprite.left;\n            const top = sprite.top;\n            const xn = Math.idiv(sprite.width + this.cellWidth - 1, this.cellWidth);\n            const yn = Math.idiv(sprite.height + this.cellHeight - 1, this.cellHeight);\n            for (let x = 0; x <= xn; x++)\n                for (let y = 0; y <= yn; y++)\n                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n        }\n\n        private mergeAtKey(x: number, y: number, layer: number, n: Sprite[]) {\n            const k = this.key(x, y);\n            const bucket = this.buckets[k];\n            if (bucket) {\n                for (const sprite of bucket)\n                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n                        n.push(sprite);\n            }\n        }\n\n        toString() {\n            return `${this.buckets.length} buckets, ${this.buckets.filter(b => !!b).length} filled`;\n        }\n    }\n}",
      "sprites.ts": "/*\nFrame handlers:\n 10 - physics and collisions\n 20 - frame()\n 60 - screen/sprite background\n 90 - drawing sprites\n 95 - drawing score\n100 - loops.menu()\n200 - screen refresh\n*/\n\n/**\n * Sprites on screen\n */\n//% weight=98 color=\"#4B7BEC\" icon=\"\\uf1d8\"\n//% groups='[\"Create\", \"Properties\", \"Overlaps\", \"Collisions\", \"Lifecycle\"]'\nnamespace sprites {\n\n    /**\n     * Create a new sprite from an image\n     * @param img the image\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritetype\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=mySprite\n    //% weight=100 help=sprites/create\n    export function create(img: Image, kind?: number): Sprite {\n        const scene = game.currentScene();\n        const sprite = new Sprite(img)\n        sprite.type = kind;\n        scene.addSprite(sprite);\n        scene.physicsEngine.addSprite(sprite);\n\n        // run on created handlers\n        scene.createdHandlers\n            .filter(h => h.type == kind)\n            .forEach(h => h.handler(sprite));\n\n        return sprite\n    }\n\n    /**\n     * Return an array of all sprites of the given kind.\n     * @param kind the target kind\n     */\n    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritetype\"\n    //% blockNamespace=\"arrays\" blockSetVariable=\"sprite list\"\n    //% weight=87\n    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (!(kind >= 0) || !spritesByKind[kind]) return [];\n        else return spritesByKind[kind].slice(0, spritesByKind[kind].length);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritetype || from sprite %sprite=variables_get\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    export function createProjectile(img: Image, vx: number, vy: number, kind: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind);\n        s.vx = vx\n        s.vy = vy\n\n        // put it at the edge of the screen so that it moves towards the middle\n\n        if (vx < 0)\n            s.x = screen.width + (s.width >> 1) - 1\n        else if (vx > 0)\n            s.x = -(s.width >> 1) + 1\n\n        if (vy < 0)\n            s.y = screen.height + (s.height >> 1) - 1\n        else if (vy > 0)\n            s.y = -(s.height >> 1) + 1\n\n        s.flags |= sprites.Flag.AutoDestroy;\n\n        if (sprite) {\n            s.x = sprite.x;\n            s.y = sprite.y;\n        }\n\n        return s\n    }\n\n    /**\n     * Creates a new sprite of the given kind and adds it to the game. Use this\n     * with the \"on sprite created\" event.\n     * @param kind the kind of sprite to create\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spritecreateempty block=\"create empty sprite of kind %kind=spritetype\"\n    //% weight=98\n    export function createEmptySprite(kind: number): void {\n        sprites.create(image.create(1, 1), kind);\n    }\n\n    export enum Flag {\n        Ghost = 1, // doesn't collide with other sprites\n        Destroyed = 2,\n        AutoDestroy = 4, // remove the sprite when no longer visible\n        StayInScreen = 8, // sprite cannot move outside the camera region\n    }\n}\n",
      "targetoverrides.cpp": "// Overriden in target\n\n#include \"pxt.h\"\n\nnamespace game {\n    //%\n    void takeScreenshot() {\n        \n    }\n}\n\nnamespace info {\n    //%\n    int updateHighScore(int score) {\n        return score;\n    }\n}",
      "targetoverrides.ts": "// Overriden in target\n",
      "textDialogs.ts": "enum DialogLayout {\n    //% block=bottom\n    Bottom,\n    //% block=left\n    Left,\n    //% block=right\n    Right,\n    //% block=top\n    Top,\n    //% block=center\n    Center,\n    //% block=\"full screen\"\n    Full\n}\n\nnamespace game {\n    let dialogFrame: Image;\n    let dialogCursor: Image;\n    let dialogFont: image.Font;\n    let dialogTextColor: number;\n\n    export class BaseDialog {\n        image: Image;\n        frame: Image;\n        cursor: Image;\n\n        columns: number;\n        rows: number;\n        unit: number;\n\n        innerLeft: number;\n        innerTop: number;\n        cursorCount: number;\n\n        font: image.Font;\n        textColor: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            this.image = image.create(width, height);\n\n            this.frame = frame || dialogFrame || (dialogFrame = defaultFrame());\n\n            this.font = font || dialogFont || (dialogFont = image.font8);\n\n            this.cursor = cursor || dialogCursor || (dialogCursor = defaultCursorImage());\n\n            this.textColor = dialogTextColor == undefined ? dialogTextColor = 15 : dialogTextColor;\n\n            this.unit = Math.floor(this.frame.width / 3);\n            this.columns = Math.floor(width / this.unit);\n            this.rows = Math.floor(height / this.unit);\n\n            this.innerLeft = (width - (this.columns * this.unit)) >> 1;\n            this.innerTop = (height - (this.rows * this.unit)) >> 1;\n\n            this.cursorCount = 0;\n\n            this.drawBorder();\n            this.clearInterior();\n        }\n\n        update() {\n            this.clearInterior();\n            this.drawTextCore();\n            this.drawCursorRow();\n        }\n\n        setText(rawString: string) {\n            // implemented by subclass\n        }\n\n        drawTextCore() {\n            // Implemented by subclass\n        }\n\n        drawCursorRow() {\n            let offset = 0;\n            if (this.cursorCount > 20) {\n                offset = 1;\n            }\n\n            this.cursorCount = (this.cursorCount + 1) % 40;\n\n            this.image.drawTransparentImage(\n                this.cursor,\n                this.innerLeft + this.textAreaWidth() + this.unit + offset - this.cursor.width,\n                this.innerTop + this.unit + this.textAreaHeight() + 1 - this.cursorRowHeight()\n            )\n        }\n\n        protected drawBorder() {\n            for (let c = 0; c < this.columns; c++) {\n                if (c == 0) {\n                    this.drawPartial(0, 0, 0);\n                    this.drawPartial(6, 0, this.rows - 1);\n                }\n                else if (c === this.columns - 1) {\n                    this.drawPartial(2, c, 0);\n                    this.drawPartial(8, c, this.rows - 1);\n                }\n                else {\n                    this.drawPartial(1, c, 0);\n                    this.drawPartial(7, c, this.rows - 1);\n                }\n            }\n\n            for (let r = 1; r < this.rows - 1; r++) {\n                this.drawPartial(3, 0, r);\n                this.drawPartial(5, this.columns - 1, r);\n            }\n        }\n\n        protected clearInterior() {\n            for (let d = 1; d < this.columns - 1; d++) {\n                for (let s = 1; s < this.rows - 1; s++) {\n                    this.drawPartial(4, d, s)\n                }\n            }\n        }\n\n        protected drawPartial(index: number, colTo: number, rowTo: number) {\n            const x0 = this.innerLeft + colTo * this.unit;\n            const y0 = this.innerTop + rowTo * this.unit;\n\n            const xf = (index % 3) * this.unit;\n            const yf = Math.floor(index / 3) * this.unit;\n\n            for (let e = 0; e < this.unit; e++) {\n                for (let t = 0; t < this.unit; t++) {\n                    this.image.setPixel(\n                        x0 + e,\n                        y0 + t,\n                        this.frame.getPixel(xf + e, yf + t));\n                }\n            }\n        }\n\n        protected cursorRowHeight() {\n            return this.cursor.height + 1;\n        }\n\n        protected rowHeight() {\n            return this.font.charHeight + 1;\n        }\n\n        protected textAreaWidth() {\n            return this.image.width - ((this.innerLeft + this.unit) << 1) - 2;\n        }\n\n        protected textAreaHeight() {\n            return this.image.height - ((this.innerTop + this.unit) << 1) - 1;\n        }\n    }\n\n    export class Dialog extends BaseDialog {\n        chunks: string[];\n        chunkIndex: number;\n\n        constructor(width: number, height: number, frame?: Image, font?: image.Font, cursor?: Image) {\n            super(width, height, frame, font, cursor);\n\n            this.chunkIndex = 0;\n        }\n\n        hasNext() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex < this.chunks.length - 1;\n        }\n\n        hasPrev() {\n            if (!this.chunks || this.chunks.length === 0) return false;\n            return this.chunkIndex > 0;\n        }\n\n        nextPage() {\n            if (this.hasNext()) {\n                this.chunkIndex++;\n            }\n        }\n\n        prevPage() {\n            if (this.hasPrev()) {\n                this.chunkIndex--;\n            }\n        }\n\n        chunkText(str: string): string[] {\n            const charactersPerRow = Math.floor(this.textAreaWidth() / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(this.textAreaHeight() / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const screens: string[] = [];\n\n            let strIndex = 0;\n            let rowIndex = 0;\n            let current = \"\";\n\n            while (strIndex < str.length) {\n                const currRowCharacters = rowIndex < rowsOfCharacters - rowsWithCursor ?\n                                                                    charactersPerRow : charactersPerCursorRow;\n                const lastIndex = strIndex + currRowCharacters - 1;\n\n                if (str.charAt(lastIndex) === \" \" || lastIndex >= str.length - 1) {\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters;\n                }\n                else if (str.charAt(lastIndex + 1) === \" \") {\n                    // No need to break, but consume the space\n                    current += str.substr(strIndex, currRowCharacters);\n                    strIndex += currRowCharacters + 1;\n                }\n                else if (str.charAt(lastIndex - 1) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 1) + \" \";\n                    strIndex += currRowCharacters - 1;\n                }\n                else if (str.charAt(lastIndex - 2) === \" \") {\n                    // Move the whole word down to the next row\n                    current += str.substr(strIndex, currRowCharacters - 2) + \"  \";\n                    strIndex += currRowCharacters - 2;\n                }\n                else {\n                    // Insert a break\n                    current += str.substr(strIndex, currRowCharacters - 1) + \"-\";\n                    strIndex += currRowCharacters - 1;\n                }\n\n                rowIndex++;\n                if (rowIndex >= rowsOfCharacters) {\n                    rowIndex = 0;\n                    screens.push(current);\n                    current = \"\";\n                }\n            }\n\n            // Only pushes the last part of the message to the screen when current isn't empty\n            if (current) {\n                screens.push(current);\n            }\n\n            return screens;\n        }\n\n        setText(rawString: string) {\n            this.chunks = this.chunkText(rawString);\n            this.chunkIndex = 0;\n        }\n\n        drawTextCore() {\n            if (!this.chunks || this.chunks.length === 0) return;\n            const str = this.chunks[this.chunkIndex];\n            const availableWidth = this.textAreaWidth();\n            const availableHeight = this.textAreaHeight();\n\n            const charactersPerRow = Math.floor(availableWidth / this.font.charWidth);\n            const charactersPerCursorRow = Math.floor(charactersPerRow - (this.cursor.width / this.font.charWidth));\n            const rowsOfCharacters = Math.floor(availableHeight / this.rowHeight());\n            const rowsWithCursor = Math.ceil(this.cursor.height / this.rowHeight());\n\n            const textLeft = 1 + this.innerLeft + this.unit + ((availableWidth - charactersPerRow * this.font.charWidth) >> 1);\n            const textTop = 1 + this.innerTop + this.unit + ((availableHeight - rowsOfCharacters * this.rowHeight()) >> 1);\n\n            let current = 0;\n            for (let row = 0; row < rowsOfCharacters; row++) {\n                const currRowCharacters = row % rowsOfCharacters < rowsOfCharacters - rowsWithCursor ?\n                                                                    charactersPerRow : charactersPerCursorRow;\n\n                this.image.print(\n                    str.substr(current, currRowCharacters),\n                    textLeft,\n                    textTop + row * this.rowHeight(),\n                    this.textColor, this.font\n                )\n                current += currRowCharacters;\n            }\n        }\n    }\n\n    export class SplashDialog extends game.BaseDialog {\n        text: string;\n        subtext: string;\n\n        timer: number;\n        offset: number;\n        maxOffset: number;\n        maxSubOffset: number;\n\n        constructor(width: number, height: number) {\n            super(width, height, defaultSplashFrame(), image.font8)\n            this.maxOffset = -1;\n            this.maxSubOffset = -1;\n            this.textColor = 1;\n        }\n\n\n        setText(text: string) {\n            this.text = text;\n            this.offset = 0;\n            this.maxOffset = text.length * this.font.charWidth - screen.width + (this.unit << 1);\n            this.timer = 2;\n        }\n\n        setSubtext(sub: string) {\n            this.subtext = sub;\n            this.maxSubOffset = sub.length * (image.font5.charWidth) - screen.width + (this.unit << 1);\n        }\n\n        drawTextCore() {\n            const scrollMax = Math.max(this.maxOffset, this.maxSubOffset);\n            if (this.timer > 0) {\n                this.timer -= game.eventContext().deltaTime;\n                if (this.timer <= 0) {\n                    if (this.offset > 0) {\n                        this.offset = 0;\n                        this.timer = 2;\n                    }\n                }\n            }\n            else {\n                this.offset++;\n                if (this.offset >= scrollMax) {\n                    this.offset = scrollMax;\n                    this.timer = 2;\n                }\n            }\n            if (this.maxOffset < 0) {\n                const left = (this.image.width >> 1) - (this.text.length * this.font.charWidth >> 1)\n                this.image.print(this.text, left, 10, this.textColor, this.font)\n            }\n            else {\n                this.image.print(this.text, this.unit - this.offset, 10, this.textColor, this.font)\n            }\n\n            if (this.subtext) {\n                if (this.maxSubOffset < 0) {\n                    const left = (this.image.width >> 1) - (this.subtext.length * image.font5.charWidth >> 1)\n                    this.image.print(this.subtext, left, 20, this.textColor, image.font5);\n                }\n                else {\n                    this.image.print(this.subtext, this.unit - (Math.min(this.offset, this.maxSubOffset)), 20, this.textColor, image.font5);\n                }\n            }\n            this.drawBorder();\n        }\n    }\n\n    /**\n     * Show a long text string in a dialog box that will scroll\n     * using the \"A\" or \"down\" buttons. The previous section of the\n     * text is shown using the \"up\" button. This function\n     * halts execution until the last page of text is dismissed.\n     *\n     * @param str The text to display\n     * @param layout The layout to use for the dialog box\n     */\n    //% blockId=game_show_long_text group=\"Dialogs\"\n    //% block=\"show long text %str %layout\"\n    //% help=game/show-long-text\n    export function showLongText(str: string, layout: DialogLayout) {\n        // Clone the current screen so that it shows up behind the dialog\n        const temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n\n        let width: number;\n        let height: number;\n        let top: number;\n        let left: number;\n\n        switch (layout) {\n            case DialogLayout.Bottom:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = screen.height - height;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Top:\n                width = screen.width - 4;\n                height = Math.idiv(screen.height, 3) + 5;\n                top = 0;\n                left = screen.width - width >> 1;\n                break;\n            case DialogLayout.Left:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n            case DialogLayout.Right:\n                width = Math.idiv(screen.width, 3) + 5;\n                height = screen.height;\n                top = 0;\n                left = screen.width - width;\n                break;\n            case DialogLayout.Center:\n                width = Math.idiv(screen.width << 1, 3);\n                height = Math.idiv(screen.width << 1, 3);\n                top = (screen.height - height) >> 1;\n                left = (screen.width - width) >> 1;\n                break;\n            case DialogLayout.Full:\n                width = screen.width;\n                height = screen.height;\n                top = 0;\n                left = 0;\n                break;\n        }\n\n        const dialog = new Dialog(width, height);\n        const s = sprites.create(dialog.image, -1);\n        s.top = top;\n        s.left = left;\n\n        dialog.setText(str)\n        let pressed = true;\n        let done = false;\n\n        let upPressed = true;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed() || controller.down.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                if (dialog.hasNext()) {\n                    dialog.nextPage();\n                }\n                else {\n                    game.popScene();\n                    done = true;\n                }\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n\n            const moveBack = controller.up.isPressed();\n            if (moveBack && !upPressed) {\n                upPressed = true;\n                if (dialog.hasPrev()) {\n                    dialog.prevPage();\n                }\n            }\n            else if (upPressed && !moveBack) {\n                upPressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n\n    function defaultFrame() {\n        return screen.isMono ?\n        img`\n        1 1 1\n        1 . 1\n        1 1 1\n        `\n        :\n        img`\n        . . . . . . . . . . . .\n        . b b b b b b b b b b .\n        . b b b b b b b b b b c\n        . b b d 1 1 1 1 d b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b 1 1 1 1 1 1 b b c\n        . b b d 1 1 1 1 d b b c\n        . b b b b b b b b b b c\n        . b b b b b b b b b b c\n        . . c c c c c c c c c c\n        `\n    }\n\n    function defaultSplashFrame() {\n        return screen.isMono ?\n        img`\n        1 1 1\n        . . .\n        1 1 1\n        `\n        :\n        img`\n        1 1 1\n        f f f\n        1 1 1\n        `\n    }\n\n    function defaultCursorImage() {\n        return screen.isMono ?\n        img`\n        1 1 1 1 1 1 1 . . .\n        1 . . 1 . . . 1 . .\n        1 . 1 . 1 . . . 1 .\n        1 . 1 1 1 . . . . 1\n        1 . 1 . 1 . . . 1 .\n        1 . . . . . . 1 . .\n        1 1 1 1 1 1 1 . . .\n        . . . . . . . . . .\n        `\n        :\n        img`\n        7 7 7 7 7 7 7 . . .\n        7 7 7 1 7 7 7 7 . .\n        7 7 1 7 1 7 7 7 7 .\n        7 7 1 1 1 7 7 7 7 7\n        7 7 1 7 1 7 7 7 7 6\n        7 7 1 7 1 7 7 7 6 .\n        7 7 7 7 7 7 7 6 . .\n        . 6 6 6 6 6 6 . . .\n        `\n    }\n\n    /**\n     * Change the default dialog frame to a new image. Dialog frames\n     * are divided into three rows and three columns and are used to define\n     * the outer frame of the dialog box.\n     *\n     * @param frame A square image with a width and height divisible by three\n     */\n    //% blockId=game_dialog_set_frame group=\"Dialogs\"\n    //% block=\"set dialog frame to %frame=screen_image_picker\"\n    //% game/set-dialog-frame\n    export function setDialogFrame(frame: Image) {\n        dialogFrame = frame;\n    }\n\n    /**\n     * Change the default image used for the cursor that appears in the\n     * bottom left of the dialog box.\n     *\n     * @param cursor The image to use for the cursor\n     */\n    //% blockId=game_dialog_set_cursor group=\"Dialogs\"\n    //% block=\"set dialog cursor to %frame=screen_image_picker\"\n    //% help=game/set-dialog-cursor\n    export function setDialogCursor(cursor: Image) {\n        dialogCursor = cursor;\n    }\n\n    /**\n     * Change the color for the text in dialog boxes.\n     *\n     * @param color The index of the color 0-15\n     */\n    //% blockId=game_dialog_set_text_color group=\"Dialogs\"\n    //% block=\"set dialog text color to %color=colorindexpicker\"\n    //% help=game/set-dialog-text-color\n    export function setDialogTextColor(color: number) {\n        dialogTextColor = Math.floor(Math.min(15, Math.max(0, color)));\n    }\n\n    export function setDialogFont(font: image.Font) {\n        dialogFont = font;\n    }\n\n    /**\n     * Show a title and an optional subtitle menu\n     * @param title\n     * @param subtitle\n     */\n    //% weight=90 help=game/splash\n    //% blockId=gameSplash block=\"splash %title||%subtitle\"\n    //% group=\"Prompt\"\n    export function splash(title: string, subtitle?: string) {\n        const temp = screen.clone();\n        controller._setUserEventsEnabled(false);\n        game.pushScene();\n        scene.setBackgroundImage(temp);\n\n        const dialog = new SplashDialog(screen.width, subtitle ? 42 : 35);\n        dialog.setText(title);\n        if (subtitle) dialog.setSubtext(subtitle);\n\n        const s = sprites.create(dialog.image, -1);\n        let pressed = true;\n        let done = false;\n\n        game.onUpdate(() => {\n            dialog.update();\n            const currentState = controller.A.isPressed();\n            if (currentState && !pressed) {\n                pressed = true;\n                done = true;\n                game.popScene();\n            }\n            else if (pressed && !currentState) {\n                pressed = false;\n            }\n        })\n\n        pauseUntil(() => done);\n        controller._setUserEventsEnabled(true);\n    }\n}\n\n",
      "tilemap.ts": "namespace tiles {\n    class TileSet {\n        image: Image;\n        obstacle: boolean;\n        constructor(image: Image, collisions: boolean) {\n            this.image = image;\n            this.obstacle = collisions;\n        }\n    }\n\n    /**\n     * A tile in the tilemap\n     **/\n    //% blockNamespace=scene color=\"#401255\" blockGap=8\n    export class Tile {\n        private _row: number;\n        private _col: number;\n        private _map: Image;\n\n        constructor(col: number, row: number, map: Image) {\n            this._col = col;\n            this._row = row;\n            this._map = map;\n        }\n\n        get x(): number {\n            return this._col << 4;\n        }\n\n        get y(): number {\n            return this._row << 4;\n        }\n\n        get tileSet(): number {\n            return this._map.getPixel(this._col, this._row);\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tiles\"\n        //% weight=25\n        //% help=scene/place\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n\n            mySprite.x = this.x + 8;\n            mySprite.y = this.y + 8;\n        }\n    }\n\n    export class TileMap implements SpriteLike {\n        id: number;\n        z: number;\n\n        private _layer: number;\n\n        private _map: Image;\n        private _tileSets: TileSet[];\n\n        constructor() {\n            this._tileSets = [];\n            this._layer = 1;\n            this.z = -1;\n\n            const sc = game.currentScene();\n            sc.addSprite(this);\n            sc.flags |= scene.Flag.NeedsSorting;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << 4) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << 4) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setTile(index: number, img: Image, collisions?: boolean) {\n            if (this.isInvalidIndex(index)) return;\n            this._tileSets[index] = new TileSet(img, collisions);\n        }\n\n        setMap(map: Image) {\n            this._map = map;\n        }\n\n        public getTile(col: number, row: number): Tile {\n            if (this.isOutsideMap(col, row)) return undefined;\n            return new Tile(col, row, this._map);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setPixel(col, row, index);\n        }\n\n        public getTilesByType(index: number): Tile[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return undefined;\n\n            let output: Tile[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getPixel(col, row);\n                    if (currTile === index) {\n                        output.push(new Tile(col, row, this._map));\n                    }\n                }\n            }\n            return output;\n        }\n\n        __update(camera: scene.Camera, dt: number): void { }\n\n        /**\n         * Draws all visible\n         */\n        __draw(camera: scene.Camera): void {\n            if (!this.enabled) return;\n\n            const offsetX = camera.offsetX & 0xf;\n            const offsetY = camera.offsetY & 0xf;\n            const x0 = Math.max(0, camera.offsetX >> 4);\n            const xn = Math.min(this._map.width, ((camera.offsetX + screen.width) >> 4) + 1);\n            const y0 = Math.max(0, camera.offsetY >> 4);\n            const yn = Math.min(this._map.height, ((camera.offsetY + screen.height) >> 4) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getPixel(x, y);\n                    const tile = this._tileSets[index] || this.generateTile(index);\n                    if (tile) {\n                        screen.drawTransparentImage(tile.image, ((x - x0) << 4) - offsetX, ((y - y0) << 4) - offsetY)\n                    }\n                }\n            }\n        }\n\n        private generateTile(index: number): TileSet {\n            if (index == 0) return undefined;\n\n            const img = image.create(16, 16);\n            img.fill(index);\n            return this._tileSets[index] = new TileSet(img, false);\n        }\n\n        private isOutsideMap(col: number, row: number): boolean {\n            return !this.enabled || col < 0 || col >= this._map.width\n                    || row < 0 || row >= this._map.height;\n        }\n\n        private isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xf;\n        }\n\n        render(camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            if (game.debug) {\n                const offsetX = -camera.offsetX;\n                const offsetY = -camera.offsetY;\n                const x0 = Math.max(0, -(offsetX >> 4));\n                const xn = Math.min(this._map.width, (-offsetX + screen.width) >> 4);\n                const y0 = Math.max(0, -(offsetY >> 4));\n                const yn = Math.min(this._map.height, (-offsetY + screen.height) >> 4);\n                for (let x = x0; x <= xn; ++x) {\n                    screen.drawLine(\n                        (x << 4) + offsetX,\n                        offsetY,\n                        (x << 4) + offsetX,\n                        (this._map.height << 4) + offsetY, 1)\n                }\n                for (let y = y0; y <= yn; ++y) {\n                    screen.drawLine(\n                        offsetX,\n                        (y  << 4) + offsetY,\n                        (this._map.width << 4) + offsetX,\n                        (y << 4) + offsetY,\n                        1)\n                }\n            }\n        }\n\n        public update(camera: scene.Camera) {\n        }\n\n        public collisions(s: Sprite): sprites.Obstacle[] {\n            let overlappers: sprites.StaticObstacle[] = [];\n\n            if (this.enabled && (s.layer & this.layer) && !(s.flags & sprites.Flag.Ghost)) {\n                const x0 = Math.max(0, s.left >> 4);\n                const xn = Math.min(this._map.width, (s.right >> 4) + 1);\n                const y0 = Math.max(0, s.top >> 4);\n                const yn = Math.min(this._map.height, (s.bottom >> 4) + 1);\n\n                // let res = `x: ${x0}-${xn} y: ${y0}-${yn} HIT:`;\n                for (let x = x0; x <= xn; ++x) {\n                    const left = x << 4;\n                    for (let y = y0; y <= yn; ++y) {\n                        const index = this._map.getPixel(x, y);\n                        const tile = this._tileSets[index] || this.generateTile(index);\n                        if (tile && tile.obstacle) {\n                            const top = y << 4;\n                            if (tile.image.overlapsWith(s.image, s.left - left, s.top - top)) {\n                                overlappers.push(new sprites.StaticObstacle(tile.image, top, left, this.layer, index));\n                            }\n                        }\n                    }\n                }\n            }\n\n            return overlappers;\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this.isOutsideMap(col, row)) return true;\n\n            let t = this._tileSets[this._map.getPixel(col, row)];\n            return t && t.obstacle;\n        }\n\n        public getObstacle(col: number, row: number) {\n            if (!this.enabled) return undefined;\n            if (this.isOutsideMap(col, row)) return undefined;\n\n            const index = this._map.getPixel(col, row);\n            const tile = this._tileSets[index] || this.generateTile(index);\n            if (tile.obstacle) {\n                return new sprites.StaticObstacle(tile.image, row << 4, col << 4, this.layer, index);\n            }\n            return undefined;\n        }\n    }\n}\n"
    },
    "controller": {
      "controller.ts": "enum ControllerButtonEvent {\n    //% block=\"pressed\"\n    Pressed = KEY_DOWN,\n    //% block=\"released\"\n    Released = KEY_UP,\n    //% block=\"repeat\"\n    Repeated = SYSTEM_KEY_REPEAT\n}\n\n/**\n * Access to game controls\n */\n//% weight=97 color=\"#e15f41\" icon=\"\\uf11b\"\nnamespace controller {\n    let _userEventsEnabled = true;\n    let _activeButtons: Button[];\n\n    //% fixedInstances\n    export class Button {\n        public id: number;\n        public repeatDelay: number;\n        public repeatInterval: number;\n        private _pressed: boolean;\n        private _pressedElasped: number;\n        private _repeatCount: number;\n\n        constructor(id: number, buttonId?: number, upid?: number, downid?: number) {\n            this.id = id;\n            this._pressed = false;\n            this.repeatDelay = 500;\n            this.repeatInterval = 30;\n            this._repeatCount = 0;\n            control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => {\n                if (this._pressed) {\n                    this._pressed = false\n                    this.raiseButtonUp();\n                }\n            }, 16)\n            control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => {\n                if (!this._pressed) {\n                    this._pressed = true;\n                    this._pressedElasped = 0;\n                    this._repeatCount = 0;\n                    this.raiseButtonDown();\n                }\n            }, 16)\n            if (buttonId && upid && downid) {\n                control.internalOnEvent(buttonId, upid, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                control.internalOnEvent(buttonId, downid, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n            }\n\n            // register button in global list\n            if (!_activeButtons) _activeButtons = [];\n            _activeButtons.push(this);\n        }\n\n        private raiseButtonUp() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_UP, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_UP, this.id);\n        }\n\n        private raiseButtonDown() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_DOWN, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n        }\n\n        private raiseButtonRepeat() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_REPEAT, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n        }\n\n        /**\n         * Run some code when a button is pressed or released\n         */\n        //% weight=99 blockGap=8 help=controller/button/on-event\n        //% blockId=keyonevent block=\"on %button **button** %event\"\n        onEvent(event: ControllerButtonEvent, handler: () => void) {\n            control.onEvent(event, this.id, handler);\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/pause-until\n        //% blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n        pauseUntil(event: ControllerButtonEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=keyispressed block=\"is %button **button** pressed\"\n        isPressed() {\n            return this._pressed;\n        }\n\n        __update(dtms: number) {\n            if (!this._pressed) return;\n            this._pressedElasped += dtms;\n            // inital delay\n            if (this._pressedElasped < this.repeatDelay) \n                return;\n            \n            // do we have enough time to repeat\n            const count = Math.floor((this._pressedElasped - this.repeatDelay) / this.repeatInterval);\n            if (count != this._repeatCount) {\n                this.raiseButtonRepeat();\n                this._repeatCount = count;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"any\"\n    export const anyButton = new Button(0);\n\n    /**\n     * Get the horizontal movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=50 blockGap=8 help=controller/dx\n    //% blockId=keysdx block=\"dx (left-right buttons)||scaled by %step\"\n    //% step.defl=100\n    export function dx(step: number = 100) {\n        const ctx = control.eventContext();\n        if (!ctx) return 0;\n\n        if (controller.left.isPressed()) {\n            if (controller.right.isPressed()) return 0\n            else return -step * ctx.deltaTime;\n        }\n        else if (controller.right.isPressed()) return step * ctx.deltaTime\n        else return 0\n    }\n\n    /**\n     * Get the vertical movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=49 help=keys/dy\n    //% blockId=keysdy block=\"dy (up-down buttons)||scaled by %step\"\n    //% step.defl=100\n    export function dy(step: number = 100) {\n        const ctx = control.eventContext();\n        if (!ctx) return 0;\n\n        if (controller.up.isPressed()) {\n            if (controller.down.isPressed()) return 0\n            else return -step * ctx.deltaTime;\n        }\n        else if (controller.down.isPressed()) return step * ctx.deltaTime\n        else return 0\n    }\n\n    /**\n     * Pause the program until a button is pressed\n     */\n    //% weight=10\n    export function pauseUntilAnyButtonIsPressed() {\n        control.waitForEvent(KEY_DOWN, 0)\n    }\n\n    export function _setUserEventsEnabled(enabled: boolean) {\n        _userEventsEnabled = enabled;\n    }\n\n    /**\n     * Called by the game engine to update and/or raise events\n     */\n    export function __update(dt: number) {\n        if (!_activeButtons) return;\n        const dtms = (dt * 1000) | 0\n        _activeButtons.forEach(btn => btn.__update(dtms));\n    }\n}",
      "enums.ts": "const KEY_UP = 2048;\nconst KEY_DOWN = 2049;\nconst INTERNAL_KEY_UP = 2050;\nconst INTERNAL_KEY_DOWN = 2051;\nconst SYSTEM_KEY_UP = 2052;\nconst SYSTEM_KEY_DOWN = 2053;\nconst KEY_REPEAT = 2054;\nconst SYSTEM_KEY_REPEAT = 2055;\n",
      "pxt.json": "{\n    \"name\": \"controller\",\n    \"description\": \"Game controller\",\n    \"files\": [\n        \"enums.ts\",\n        \"controller.ts\",\n        \"targetoverrides.ts\"\n    ],\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"screen\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "targetoverrides.ts": "namespace controller {\n    //% fixedInstance block=\"left\"\n    export const left = new Button(1)\n    //% fixedInstance block=\"up\"\n    export const up = new Button(2)\n    //% fixedInstance block=\"right\"\n    export const right = new Button(3)\n    //% fixedInstance block=\"down\"\n    export const down = new Button(4)\n    //% fixedInstance block=\"A\"\n    export const A = new Button(5)\n    //% fixedInstance block=\"B\"\n    export const B = new Button(6)\n}"
    },
    "controller---hw": {
      "controller.ts": "enum ControllerButtonEvent {\n    //% block=\"pressed\"\n    Pressed = KEY_DOWN,\n    //% block=\"released\"\n    Released = KEY_UP,\n    //% block=\"repeat\"\n    Repeated = SYSTEM_KEY_REPEAT\n}\n\n/**\n * Access to game controls\n */\n//% weight=97 color=\"#e15f41\" icon=\"\\uf11b\"\nnamespace controller {\n    let _userEventsEnabled = true;\n    let _activeButtons: Button[];\n\n    //% fixedInstances\n    export class Button {\n        public id: number;\n        public repeatDelay: number;\n        public repeatInterval: number;\n        private _pressed: boolean;\n        private _pressedElasped: number;\n        private _repeatCount: number;\n\n        constructor(id: number, buttonId?: number, upid?: number, downid?: number) {\n            this.id = id;\n            this._pressed = false;\n            this.repeatDelay = 500;\n            this.repeatInterval = 30;\n            this._repeatCount = 0;\n            control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => {\n                if (this._pressed) {\n                    this._pressed = false\n                    this.raiseButtonUp();\n                }\n            }, 16)\n            control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => {\n                if (!this._pressed) {\n                    this._pressed = true;\n                    this._pressedElasped = 0;\n                    this._repeatCount = 0;\n                    this.raiseButtonDown();\n                }\n            }, 16)\n            if (buttonId && upid && downid) {\n                control.internalOnEvent(buttonId, upid, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                control.internalOnEvent(buttonId, downid, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n            }\n\n            // register button in global list\n            if (!_activeButtons) _activeButtons = [];\n            _activeButtons.push(this);\n        }\n\n        private raiseButtonUp() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_UP, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_UP, this.id);\n        }\n\n        private raiseButtonDown() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_DOWN, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n        }\n\n        private raiseButtonRepeat() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_REPEAT, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n        }\n\n        /**\n         * Run some code when a button is pressed or released\n         */\n        //% weight=99 blockGap=8 help=controller/button/on-event\n        //% blockId=keyonevent block=\"on %button **button** %event\"\n        onEvent(event: ControllerButtonEvent, handler: () => void) {\n            control.onEvent(event, this.id, handler);\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/pause-until\n        //% blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n        pauseUntil(event: ControllerButtonEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=keyispressed block=\"is %button **button** pressed\"\n        isPressed() {\n            return this._pressed;\n        }\n\n        __update(dtms: number) {\n            if (!this._pressed) return;\n            this._pressedElasped += dtms;\n            // inital delay\n            if (this._pressedElasped < this.repeatDelay) \n                return;\n            \n            // do we have enough time to repeat\n            const count = Math.floor((this._pressedElasped - this.repeatDelay) / this.repeatInterval);\n            if (count != this._repeatCount) {\n                this.raiseButtonRepeat();\n                this._repeatCount = count;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"any\"\n    export const anyButton = new Button(0);\n\n    /**\n     * Get the horizontal movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=50 blockGap=8 help=controller/dx\n    //% blockId=keysdx block=\"dx (left-right buttons)||scaled by %step\"\n    //% step.defl=100\n    export function dx(step: number = 100) {\n        const ctx = control.eventContext();\n        if (!ctx) return 0;\n\n        if (controller.left.isPressed()) {\n            if (controller.right.isPressed()) return 0\n            else return -step * ctx.deltaTime;\n        }\n        else if (controller.right.isPressed()) return step * ctx.deltaTime\n        else return 0\n    }\n\n    /**\n     * Get the vertical movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=49 help=keys/dy\n    //% blockId=keysdy block=\"dy (up-down buttons)||scaled by %step\"\n    //% step.defl=100\n    export function dy(step: number = 100) {\n        const ctx = control.eventContext();\n        if (!ctx) return 0;\n\n        if (controller.up.isPressed()) {\n            if (controller.down.isPressed()) return 0\n            else return -step * ctx.deltaTime;\n        }\n        else if (controller.down.isPressed()) return step * ctx.deltaTime\n        else return 0\n    }\n\n    /**\n     * Pause the program until a button is pressed\n     */\n    //% weight=10\n    export function pauseUntilAnyButtonIsPressed() {\n        control.waitForEvent(KEY_DOWN, 0)\n    }\n\n    export function _setUserEventsEnabled(enabled: boolean) {\n        _userEventsEnabled = enabled;\n    }\n\n    /**\n     * Called by the game engine to update and/or raise events\n     */\n    export function __update(dt: number) {\n        if (!_activeButtons) return;\n        const dtms = (dt * 1000) | 0\n        _activeButtons.forEach(btn => btn.__update(dtms));\n    }\n}",
      "enums.ts": "const KEY_UP = 2048;\nconst KEY_DOWN = 2049;\nconst INTERNAL_KEY_UP = 2050;\nconst INTERNAL_KEY_DOWN = 2051;\nconst SYSTEM_KEY_UP = 2052;\nconst SYSTEM_KEY_DOWN = 2053;\nconst KEY_REPEAT = 2054;\nconst SYSTEM_KEY_REPEAT = 2055;\n",
      "pxt.json": "{\n    \"name\": \"controller---hw\",\n    \"description\": \"Game controller\",\n    \"files\": [\n        \"enums.ts\",\n        \"controller.ts\",\n        \"targetoverrides.ts\"\n    ],\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"screen\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "targetoverrides.ts": "namespace controller {\n    //% fixedInstance block=\"left\"\n    export const left = new Button(1, input.buttonLeft.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n    //% fixedInstance block=\"up\"\n    export const up = new Button(2, input.buttonUp.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n    //% fixedInstance block=\"right\"\n    export const right = new Button(3, input.buttonRight.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n    //% fixedInstance block=\"down\"\n    export const down = new Button(4, input.buttonDown.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n\n    //% fixedInstance block=\"A\"\n    export const A = new Button(5, input.buttonA.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n    //% fixedInstance block=\"B\"\n    export const B = new Button(6, input.buttonB.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n\n    //% fixedInstance block=\"menu\"\n    export const menu = new Button(7, input.buttonMenu.id(), DAL.DEVICE_BUTTON_EVT_UP, DAL.DEVICE_BUTTON_EVT_DOWN);\n}"
    },
    "buttons": {
      "README.md": "# buttons\n\nA library to handle 2 buttons A and B.\n",
      "buttons.cpp": "#include \"pxt.h\"\n\n/*\n\nThese button events need CODAL work.\n\n    // % block=\"double click\"\n    DoubleClick = DEVICE_BUTTON_EVT_DOUBLE_CLICK,\n\n    // % block=\"hold\"\n    Hold = DEVICE_BUTTON_EVT_HOLD\n\n*/\n\n/**\n* User interaction on buttons\n*/\nenum class ButtonEvent {\n    //% block=\"click\"\n    Click = DEVICE_BUTTON_EVT_CLICK,\n    //% block=\"long click\"\n    LongClick = DEVICE_BUTTON_EVT_LONG_CLICK,\n    //% block=\"up\"\n    Up = DEVICE_BUTTON_EVT_UP,\n    //% block=\"down\"\n    Down = DEVICE_BUTTON_EVT_DOWN\n};\n\nnamespace pxt {\n//%\nButton *getButtonByPin(int pin, int flags) {\n    auto cpid = DEVICE_ID_FIRST_BUTTON + pin;\n    auto btn = (Button *)lookupComponent(cpid);\n    if (btn == NULL) {\n        auto pull = PullMode::None;\n        if ((flags & 0xf0) == 0x10)\n            pull = PullMode::Down;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::Up;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::None;\n        else\n            oops(3);\n        // GCTODO\n        btn = new Button(*lookupPin(pin), cpid, DEVICE_BUTTON_ALL_EVENTS,\n                         (ButtonPolarity)(flags & 0xf), pull);\n    }\n    return btn;\n}\n\n//%\nButton *getButtonByPinCfg(int key, int flags) {\n    int pin = getConfig(key);\n    if (pin == -1) target_panic(PANIC_NO_SUCH_CONFIG);\n    return getButtonByPin(pin, flags);\n}\n\n// This is for A, B, and AB\n//%\nAbstractButton *getButton(int id) {\n    int pa = getConfig(CFG_PIN_BTN_A);\n    int pb = getConfig(CFG_PIN_BTN_B);\n    int flags = getConfig(CFG_DEFAULT_BUTTON_MODE, BUTTON_ACTIVE_LOW_PULL_UP);\n    if (id == 0)\n        return getButtonByPin(pa, flags);\n    else if (id == 1)\n        return getButtonByPin(pb, flags);\n    else if (id == 2)\n        return getMultiButton(DEVICE_ID_BUTTON_AB, pa, pb, flags);\n    else {\n        target_panic(PANIC_INVALID_ARGUMENT);\n        return NULL;\n    }\n}\n\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags) {\n    auto btn = (MultiButton *)lookupComponent(id);\n    if (btn == NULL) {\n        auto bA = getButtonByPin(pinA, flags);\n        auto bB = getButtonByPin(pinB, flags);\n        // GCTODO\n        btn = new codal::MultiButton(bA->id, bB->id, id);\n\n        // A user has registered to receive events from the buttonAB multibutton.\n        // Disable click events from being generated by ButtonA and ButtonB, and defer the\n        // control of this to the multibutton handler.\n        //\n        // This way, buttons look independent unless a buttonAB is requested, at which\n        // point button A+B clicks can be correclty handled without breaking\n        // causal ordering.\n        bA->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        bB->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        btn->setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);\n    }\n    return btn;\n}\n}\n\n\nnamespace DigitalInOutPinMethods {\n\n/**\n * Get the push button (connected to GND) for given pin\n */\n//%\nButton_ pushButton(DigitalInOutPin pin) {\n    return pxt::getButtonByPin(pin->name, BUTTON_ACTIVE_LOW_PULL_UP);\n}\n\n}\n\n\n//% noRefCounting fixedInstances\nnamespace ButtonMethods {\n/**\t\n * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\t\n * @param button the button that needs to be clicked or used\t\n * @param event the kind of button gesture that needs to be detected\t\n * @param body code to run when the event is raised\t\n */\t\n//% help=input/button/on-event\t\n//% blockId=buttonEvent block=\"on %button|%event\"\t\n//% parts=\"buttons\"\t\n//% blockNamespace=input\t\n//% button.fieldEditor=\"gridpicker\"\t\n//% button.fieldOptions.width=220\t\n//% button.fieldOptions.columns=3\t\n//% weight=96 blockGap=12\t\n//% trackArgs=0\t\nvoid onEvent(Button_ button, ButtonEvent ev, Action body) {\t\n    registerWithDal(button->id, (int)ev, body);\t\n}    \n\n/**\n * Check if a button is pressed or not.\n * @param button the button to query the request\n */\n//% help=input/button/is-pressed\n//% block=\"%button|is pressed\"\n//% blockId=buttonIsPressed\n//% parts=\"buttons\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=50 blockGap=8\n//% trackArgs=0\nbool isPressed(Button_ button) {\n    return button->isPressed();\n}\n\n/**\n * See if the button was pressed again since the last time you checked.\n * @param button the button to query the request\n */\n//% help=input/button/was-pressed\n//% block=\"%button|was pressed\"\n//% blockId=buttonWasPressed\n//% parts=\"buttons\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% group=\"More\" weight=46 blockGap=8\n//% trackArgs=0\nbool wasPressed(Button_ button) {\n    return button->wasPressed();\n}\n\n/**\n* Gets the component identifier for the buton\n*/\n//%\nint id(Button_ button) {\n    return button->id;\n}\n\n}\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    /**\n     * User interaction on buttons\n     */\n\n    declare const enum ButtonEvent {\n    //% block=\"click\"\n    Click = 3,  // DEVICE_BUTTON_EVT_CLICK\n    //% block=\"long click\"\n    LongClick = 4,  // DEVICE_BUTTON_EVT_LONG_CLICK\n    //% block=\"up\"\n    Up = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"down\"\n    Down = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "pxt.json": "{\n    \"name\": \"buttons\",\n    \"description\": \"Button A and B drivers\",\n    \"files\": [\n        \"README.md\",\n        \"buttons.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Get the push button (connected to GND) for given pin\n     */\n    //% shim=DigitalInOutPinMethods::pushButton\n    pushButton(): Button;\n}\n\n\n\n    //% noRefCounting fixedInstances\ndeclare interface Button {\n    /**\t\n     * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\t\n     * @param button the button that needs to be clicked or used\t\n     * @param event the kind of button gesture that needs to be detected\t\n     * @param body code to run when the event is raised\t\n     */\n    //% help=input/button/on-event\t\n    //% blockId=buttonEvent block=\"on %button|%event\"\t\n    //% parts=\"buttons\"\t\n    //% blockNamespace=input\t\n    //% button.fieldEditor=\"gridpicker\"\t\n    //% button.fieldOptions.width=220\t\n    //% button.fieldOptions.columns=3\t\n    //% weight=96 blockGap=12\t\n    //% trackArgs=0 shim=ButtonMethods::onEvent\n    onEvent(ev: ButtonEvent, body: () => void): void;\n\n    /**\n     * Check if a button is pressed or not.\n     * @param button the button to query the request\n     */\n    //% help=input/button/is-pressed\n    //% block=\"%button|is pressed\"\n    //% blockId=buttonIsPressed\n    //% parts=\"buttons\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=50 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::isPressed\n    isPressed(): boolean;\n\n    /**\n     * See if the button was pressed again since the last time you checked.\n     * @param button the button to query the request\n     */\n    //% help=input/button/was-pressed\n    //% block=\"%button|was pressed\"\n    //% blockId=buttonWasPressed\n    //% parts=\"buttons\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% group=\"More\" weight=46 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::wasPressed\n    wasPressed(): boolean;\n\n    /**\n     * Gets the component identifier for the buton\n     */\n    //% shim=ButtonMethods::id\n    id(): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": ""
    },
    "music": {
      "README.md": "# music\n\nThe music library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "melodies.ts": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 The MicroPython-on-micro:bit Developers, as listed\nin the accompanying AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// Melodies from file microbitmusictunes.c https://github.com/bbcmicrobit/MicroPython\n\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    let _soundQueue: control.AnimationQueue;\n\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    function soundQueue(): control.AnimationQueue {\n        if (!_soundQueue) _soundQueue = new control.AnimationQueue();\n        return _soundQueue;\n    }\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    export function playSound(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        control.runInParallel(() => {\n            queue.cancel();\n            queue.runUntilDone(() => melody.playNextNote());\n        })\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    export function playSoundUntilDone(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        queue.runUntilDone(() => melody.playNextNote());\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=93\n    export function stopAllSounds() {\n        const queue = soundQueue();\n        queue.cancel();\n        music.rest(1);\n    }\n\n    class Melody {\n        static freqTable: number[];\n        notes: string;\n        duration: number;\n        octave: number;\n        pos: number;\n        tempo: number;\n\n        constructor(notes: string) {\n            this.notes = notes;\n            this.duration = 4; //Default duration (Crotchet)\n            this.octave = 4; //Middle octave\n            this.pos = 0;\n            this.tempo = 120; // default tempo\n            // TODO: use HEX literal\n            if (!Melody.freqTable)\n                Melody.freqTable = [31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 92, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902]\n        }\n\n        hasNextNote() {\n            return this.pos < this.notes.length;\n        }\n\n        scanNextNote(): string {\n            // eat space\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                    break;\n                this.pos++;\n            }\n\n            // read note\n            let note = \"\";\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                    break;\n                note += c;\n                this.pos++;\n            }\n            return note;\n        }\n\n        playNextNote(): boolean {\n            let currNote = this.scanNextNote();\n            if (!currNote)\n                return false;\n\n            enum Token {\n                Note = 0,\n                Octave = 1,\n                Beat = 2,\n                Tempo = 3\n            }\n\n            let note: number = 0;\n            let isrest: boolean = false;\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: this.octave = d; break;\n                        case Token.Beat: this.duration = Math.max(1, Math.min(16, d)); break;\n                        case Token.Tempo: this.tempo = Math.max(1, d); break;\n                    }\n                    token = \"\";\n                }\n            }\n            for (let i = 0; i < currNote.length; i++) {\n                let noteChar = currNote.charAt(i);\n                switch (noteChar) {\n                    case 'c': case 'C': note = 1; break;\n                    case 'd': case 'D': note = 3; break;\n                    case 'e': case 'E': note = 5; break;\n                    case 'f': case 'F': note = 6; break;\n                    case 'g': case 'G': note = 8; break;\n                    case 'a': case 'A': note = 10; break;\n                    case 'b': case 'B': note = 12; break;\n                    case 'r': case 'R': isrest = true; break;\n                    case '#': note++; break;\n                    case 'b': note--; break;\n                    case ':':\n                        consumeToken();\n                        tokenKind = Token.Beat;\n                        break;\n                    case '-':\n                        consumeToken();\n                        tokenKind = Token.Tempo;\n                        break;\n                    default:\n                        if(tokenKind == Token.Note)\n                            tokenKind = Token.Octave;\n                        token += noteChar;\n                        break;\n                }\n            }\n            consumeToken();\n            let beat = 15000 / this.tempo;\n            if (isrest) {\n                music.rest(this.duration * beat)\n            } else {\n                const keyNumber = note + (12 * (this.octave - 1));\n                const frequency = Melody.freqTable[keyNumber] || 0;\n                music.playTone(frequency, this.duration * beat);\n            }\n\n            return this.hasNextNote();\n        }\n    }\n}",
      "music.cpp": "#include \"pxt.h\"\n\n#include \"dmac.h\"\n#include \"SAMD21DAC.h\"\n#include \"Synthesizer.h\"\n#include \"CodalConfig.h\"\n\n#define NOTE_PAUSE 20\nclass WSynthesizer {\n  public:\n    Synthesizer synth;\n    SAMD21DAC dac;\n\n    WSynthesizer()\n        // DAC always on PA02 on SAMD21\n        : dac(*lookupPin(PA02), pxt::getWDMAC()->dmac, synth.output) {\n        synth.setSampleRate(dac.getSampleRate());\n        synth.setVolume(64);\n    }\n};\nSINGLETON(WSynthesizer);\n\nenum class SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n};\n\n\n// override analogWrite for PA02 to use DAC\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) {\n    if (name->name == PA02) {\n        auto pinAmp = LOOKUP_PIN(SPEAKER_AMP);\n        if (pinAmp) pinAmp->setDigitalValue(0);\n        getWSynthesizer()->dac.setValue(value);\n    } else\n        name->setAnalogValue(value);\n}\n}\n\nnamespace music {\n\nBuffer tone; // empty buffer to hold custom tone\nSoundOutputDestination soundOutputDestination = SoundOutputDestination::Speaker;\n\n// turns on/off the speaker amp\nvoid updateSpeakerAmp() {\n    // turn off speaker as needed\n    //auto pinAmp = LOOKUP_PIN(SPEAKER_AMP);\n    //if (pinAmp) {\n    //    bool on = SoundOutputDestination::Speaker == soundOutputDestination;\n    //    pinAmp->setDigitalValue(on ? 1 : 0);\n    //}\n}\n\n/**\n* Set a source of digital sound data (PCM) for making tones.\n* Samples are 1024 x 10bit unsigned PCM.\n* A reference to the buffer is kept to avoid the memory overhead, so changes to the buffer\n* values are reflected immediately to the sound output.\n*/\n//% help=music/set-tone\n//% weight=1 group=\"Tones\"\n//% deprecated\n//% blockId=music_set_tone block=\"set tone %buffer\"\nvoid setTone(Buffer buffer) {\n    if (!buffer) return;\n\n    if (buffer->length != TONE_WIDTH * sizeof(uint16_t))\n        return; // invalid length\n\n    if (!tone)\n        registerGC((TValue*)&tone);\n    decrRC(tone);\n    tone = buffer; // keep a reference to the buffer\n    incrRC(tone);\n\n    auto synth = &getWSynthesizer()->synth;\n    synth->setTone((const uint16_t*)tone->data);\n}\n\n/**\n* Turn the on-board speaker on or off.\n* @param out the destination for sounds generated by the synthesizer\n*/\n// weight=2\n// blockId=music_set_output block=\"set output %out\"\n// parts=\"speaker\" blockGap=8 advanced=true\nvoid setOutput(SoundOutputDestination out) {\n    if (out != soundOutputDestination) {\n        soundOutputDestination = out;\n        updateSpeakerAmp();\n    }\n}\n\n/**\n* Set the output volume of the sound synthesizer.\n* @param volume the volume 0...256, eg: 128\n*/\n//% blockId=synth_set_volume block=\"set volume %volume\"\n//% parts=\"speaker\"\n//% volume.min=0 volume.max=256\n//% help=music/set-volume\n//% weight=70\nvoid setVolume(int volume) {\n    auto synth = &getWSynthesizer()->synth;\n    synth->setVolume(max(0, min(1024, volume * 4)));\n}\n\n/**\n* Play a tone through the speaker for some amount of time.\n* @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n* @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n*/\n//% help=music/play-tone\n//% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n//% parts=\"headphone\" async\n//% blockNamespace=music\n//% weight=76 blockGap=8\nvoid playTone(int frequency, int ms) {\n    auto synth = &getWSynthesizer()->synth;\n\n    if (frequency <= 0) {\n        synth->setFrequency(0, max(1, ms));\n    } else {\n        if (ms > 0) {\n            int d = max(1, ms - NOTE_PAUSE); // allow for short rest\n            int r = max(1, ms - d);\n            synth->setFrequency((float) frequency, d);\n            synth->setFrequency(0, r);\n        } else {\n            // ring\n            synth->setFrequency((float) frequency);\n        }\n    }\n    fiber_sleep(1);\n}\n\n}",
      "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
      "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\nnamespace music {\n}",
      "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
      "pxt.json": "{\n    \"name\": \"music\",\n    \"description\": \"The music library\",\n    \"files\": [\n        \"README.md\",\n        \"music.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"melodies.ts\",\n        \"music.ts\",\n        \"piano.ts\",\n        \"ns.ts\",\n        \"speaker.svg\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtparts.json": "{\n   \"headphone\": {\n       \"numberOfPins\": 2,\n       \"visual\": {\n           \"image\": \"speaker.svg\",\n           \"width\": 90,\n           \"height\": 100,\n           \"pinDistance\": 15,\n           \"pinLocations\": [\n               {\"x\": 30, \"y\": 0},\n               {\"x\": 60, \"y\": 0}\n           ]\n       },\n       \"pinDefinitions\": [\n           {\"target\": \"ground\", \"style\": \"male\", \"orientation\": \"-Z\"},\n           {\"target\": \"D0\", \"style\": \"male\", \"orientation\": \"-Z\"}\n       ],\n       \"instantiation\": {\n           \"kind\": \"singleton\"\n       },\n       \"assembly\": [\n           {\"part\": true, \"pinIndices\": [0]},\n           {\"pinIndices\": [1]}\n       ]\n   }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface AnalogOutPin {}\ndeclare namespace music {\n\n    /**\n     * Set a source of digital sound data (PCM) for making tones.\n     * Samples are 1024 x 10bit unsigned PCM.\n     * A reference to the buffer is kept to avoid the memory overhead, so changes to the buffer\n     * values are reflected immediately to the sound output.\n     */\n    //% help=music/set-tone\n    //% weight=1 group=\"Tones\"\n    //% deprecated\n    //% blockId=music_set_tone block=\"set tone %buffer\" shim=music::setTone\n    function setTone(buffer: Buffer): void;\n\n    /**\n     * Set the output volume of the sound synthesizer.\n     * @param volume the volume 0...256, eg: 128\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=256\n    //% help=music/set-volume\n    //% weight=70 shim=music::setVolume\n    function setVolume(volume: int32): void;\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8 shim=music::playTone\n    function playTone(frequency: int32, ms: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "speaker.svg": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<svg viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g transform=\"matrix(1, 0, 0, 1, -0.00023, -58.230297)\">\n    <ellipse style=\"fill: rgb(70, 70, 70);\" cx=\"250.58\" cy=\"308.81\" rx=\"215\" ry=\"215\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 1.000001, -232.069031, 248.780606)\" cx=\"482.069\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -232.067871, 110.041956)\" cx=\"482.067\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"389.12\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"110.88\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"169.393\" rx=\"23.028\" ry=\"23.028\"/>\n    <g transform=\"matrix(1, 0, 0, 1, -0.000009, 0.000015)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.866026, 0.5, -0.5, 0.866026, 7.386552, -105.261086)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.5, 0.866026, -0.866026, 0.5, 246.635941, -171.170502)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.5, 0.866026, -0.866026, -0.5, 641.934998, 245.84082)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.500001, -0.866026, 0.866026, -0.500001, 108.063393, 678.85083)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n  </g>\n</svg>\n",
      "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
    },
    "music---pwm": {
      "README.md": "# music\n\nThe music library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "melodies.ts": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 The MicroPython-on-micro:bit Developers, as listed\nin the accompanying AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// Melodies from file microbitmusictunes.c https://github.com/bbcmicrobit/MicroPython\n\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    let _soundQueue: control.AnimationQueue;\n\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    function soundQueue(): control.AnimationQueue {\n        if (!_soundQueue) _soundQueue = new control.AnimationQueue();\n        return _soundQueue;\n    }\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    export function playSound(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        control.runInParallel(() => {\n            queue.cancel();\n            queue.runUntilDone(() => melody.playNextNote());\n        })\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    export function playSoundUntilDone(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        queue.runUntilDone(() => melody.playNextNote());\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=93\n    export function stopAllSounds() {\n        const queue = soundQueue();\n        queue.cancel();\n        music.rest(1);\n    }\n\n    class Melody {\n        static freqTable: number[];\n        notes: string;\n        duration: number;\n        octave: number;\n        pos: number;\n        tempo: number;\n\n        constructor(notes: string) {\n            this.notes = notes;\n            this.duration = 4; //Default duration (Crotchet)\n            this.octave = 4; //Middle octave\n            this.pos = 0;\n            this.tempo = 120; // default tempo\n            // TODO: use HEX literal\n            if (!Melody.freqTable)\n                Melody.freqTable = [31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 92, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902]\n        }\n\n        hasNextNote() {\n            return this.pos < this.notes.length;\n        }\n\n        scanNextNote(): string {\n            // eat space\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                    break;\n                this.pos++;\n            }\n\n            // read note\n            let note = \"\";\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                    break;\n                note += c;\n                this.pos++;\n            }\n            return note;\n        }\n\n        playNextNote(): boolean {\n            let currNote = this.scanNextNote();\n            if (!currNote)\n                return false;\n\n            enum Token {\n                Note = 0,\n                Octave = 1,\n                Beat = 2,\n                Tempo = 3\n            }\n\n            let note: number = 0;\n            let isrest: boolean = false;\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: this.octave = d; break;\n                        case Token.Beat: this.duration = Math.max(1, Math.min(16, d)); break;\n                        case Token.Tempo: this.tempo = Math.max(1, d); break;\n                    }\n                    token = \"\";\n                }\n            }\n            for (let i = 0; i < currNote.length; i++) {\n                let noteChar = currNote.charAt(i);\n                switch (noteChar) {\n                    case 'c': case 'C': note = 1; break;\n                    case 'd': case 'D': note = 3; break;\n                    case 'e': case 'E': note = 5; break;\n                    case 'f': case 'F': note = 6; break;\n                    case 'g': case 'G': note = 8; break;\n                    case 'a': case 'A': note = 10; break;\n                    case 'b': case 'B': note = 12; break;\n                    case 'r': case 'R': isrest = true; break;\n                    case '#': note++; break;\n                    case 'b': note--; break;\n                    case ':':\n                        consumeToken();\n                        tokenKind = Token.Beat;\n                        break;\n                    case '-':\n                        consumeToken();\n                        tokenKind = Token.Tempo;\n                        break;\n                    default:\n                        if(tokenKind == Token.Note)\n                            tokenKind = Token.Octave;\n                        token += noteChar;\n                        break;\n                }\n            }\n            consumeToken();\n            let beat = 15000 / this.tempo;\n            if (isrest) {\n                music.rest(this.duration * beat)\n            } else {\n                const keyNumber = note + (12 * (this.octave - 1));\n                const frequency = Melody.freqTable[keyNumber] || 0;\n                music.playTone(frequency, this.duration * beat);\n            }\n\n            return this.hasNextNote();\n        }\n    }\n}",
      "music.cpp": "#include \"pxt.h\"\n\n#define NOTE_PAUSE 20\n\nnamespace music {\n\n/**\n* Play a tone through the speaker for some amount of time.\n* @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n* @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n*/\n//% help=music/play-tone\n//% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n//% parts=\"headphone\" async\n//% blockNamespace=music\n//% weight=76 blockGap=8\nvoid playTone(int frequency, int ms) {\n  auto pitchPin = LOOKUP_PIN(SPEAKER_AMP);\n\n  if (!pitchPin)\n    return;\n\n  if (frequency <= 0) {\n    pitchPin->setAnalogValue(0);\n  } else {\n    pitchPin->setAnalogValue(getConfig(CFG_SPEAKER_VOLUME, 10));\n    pitchPin->setAnalogPeriodUs(1000000 / frequency);\n    if (ms > 0) {\n      int d = max(1, ms - NOTE_PAUSE); // allow for short rest\n      int r = max(1, ms - d);\n      fiber_sleep(d);\n      pitchPin->setAnalogValue(0);\n      fiber_sleep(r);\n    }\n  }\n}\n\n} // namespace music\n",
      "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
      "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\nnamespace music {\n}",
      "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
      "pxt.json": "{\n    \"name\": \"music---pwm\",\n    \"description\": \"The music library\",\n    \"files\": [\n        \"README.md\",\n        \"music.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"melodies.ts\",\n        \"music.ts\",\n        \"piano.ts\",\n        \"ns.ts\",\n        \"speaker.svg\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtparts.json": "{\n   \"headphone\": {\n       \"numberOfPins\": 2,\n       \"visual\": {\n           \"image\": \"speaker.svg\",\n           \"width\": 90,\n           \"height\": 100,\n           \"pinDistance\": 15,\n           \"pinLocations\": [\n               {\"x\": 30, \"y\": 0},\n               {\"x\": 60, \"y\": 0}\n           ]\n       },\n       \"pinDefinitions\": [\n           {\"target\": \"ground\", \"style\": \"male\", \"orientation\": \"-Z\"},\n           {\"target\": \"D0\", \"style\": \"male\", \"orientation\": \"-Z\"}\n       ],\n       \"instantiation\": {\n           \"kind\": \"singleton\"\n       },\n       \"assembly\": [\n           {\"part\": true, \"pinIndices\": [0]},\n           {\"pinIndices\": [1]}\n       ]\n   }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace music {\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8 shim=music::playTone\n    function playTone(frequency: int32, ms: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "speaker.svg": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<svg viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g transform=\"matrix(1, 0, 0, 1, -0.00023, -58.230297)\">\n    <ellipse style=\"fill: rgb(70, 70, 70);\" cx=\"250.58\" cy=\"308.81\" rx=\"215\" ry=\"215\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 1.000001, -232.069031, 248.780606)\" cx=\"482.069\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -232.067871, 110.041956)\" cx=\"482.067\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"389.12\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"110.88\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"169.393\" rx=\"23.028\" ry=\"23.028\"/>\n    <g transform=\"matrix(1, 0, 0, 1, -0.000009, 0.000015)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.866026, 0.5, -0.5, 0.866026, 7.386552, -105.261086)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.5, 0.866026, -0.866026, 0.5, 246.635941, -171.170502)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.5, 0.866026, -0.866026, -0.5, 641.934998, 245.84082)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.500001, -0.866026, 0.866026, -0.500001, 108.063393, 678.85083)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n  </g>\n</svg>\n",
      "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
    },
    "music---linux": {
      "README.md": "# music\n\nThe music library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "melodies.ts": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 The MicroPython-on-micro:bit Developers, as listed\nin the accompanying AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// Melodies from file microbitmusictunes.c https://github.com/bbcmicrobit/MicroPython\n\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    let _soundQueue: control.AnimationQueue;\n\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    function soundQueue(): control.AnimationQueue {\n        if (!_soundQueue) _soundQueue = new control.AnimationQueue();\n        return _soundQueue;\n    }\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    export function playSound(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        control.runInParallel(() => {\n            queue.cancel();\n            queue.runUntilDone(() => melody.playNextNote());\n        })\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    export function playSoundUntilDone(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        queue.runUntilDone(() => melody.playNextNote());\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=93\n    export function stopAllSounds() {\n        const queue = soundQueue();\n        queue.cancel();\n        music.rest(1);\n    }\n\n    class Melody {\n        static freqTable: number[];\n        notes: string;\n        duration: number;\n        octave: number;\n        pos: number;\n        tempo: number;\n\n        constructor(notes: string) {\n            this.notes = notes;\n            this.duration = 4; //Default duration (Crotchet)\n            this.octave = 4; //Middle octave\n            this.pos = 0;\n            this.tempo = 120; // default tempo\n            // TODO: use HEX literal\n            if (!Melody.freqTable)\n                Melody.freqTable = [31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 92, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902]\n        }\n\n        hasNextNote() {\n            return this.pos < this.notes.length;\n        }\n\n        scanNextNote(): string {\n            // eat space\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                    break;\n                this.pos++;\n            }\n\n            // read note\n            let note = \"\";\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                    break;\n                note += c;\n                this.pos++;\n            }\n            return note;\n        }\n\n        playNextNote(): boolean {\n            let currNote = this.scanNextNote();\n            if (!currNote)\n                return false;\n\n            enum Token {\n                Note = 0,\n                Octave = 1,\n                Beat = 2,\n                Tempo = 3\n            }\n\n            let note: number = 0;\n            let isrest: boolean = false;\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: this.octave = d; break;\n                        case Token.Beat: this.duration = Math.max(1, Math.min(16, d)); break;\n                        case Token.Tempo: this.tempo = Math.max(1, d); break;\n                    }\n                    token = \"\";\n                }\n            }\n            for (let i = 0; i < currNote.length; i++) {\n                let noteChar = currNote.charAt(i);\n                switch (noteChar) {\n                    case 'c': case 'C': note = 1; break;\n                    case 'd': case 'D': note = 3; break;\n                    case 'e': case 'E': note = 5; break;\n                    case 'f': case 'F': note = 6; break;\n                    case 'g': case 'G': note = 8; break;\n                    case 'a': case 'A': note = 10; break;\n                    case 'b': case 'B': note = 12; break;\n                    case 'r': case 'R': isrest = true; break;\n                    case '#': note++; break;\n                    case 'b': note--; break;\n                    case ':':\n                        consumeToken();\n                        tokenKind = Token.Beat;\n                        break;\n                    case '-':\n                        consumeToken();\n                        tokenKind = Token.Tempo;\n                        break;\n                    default:\n                        if(tokenKind == Token.Note)\n                            tokenKind = Token.Octave;\n                        token += noteChar;\n                        break;\n                }\n            }\n            consumeToken();\n            let beat = 15000 / this.tempo;\n            if (isrest) {\n                music.rest(this.duration * beat)\n            } else {\n                const keyNumber = note + (12 * (this.octave - 1));\n                const frequency = Melody.freqTable[keyNumber] || 0;\n                music.playTone(frequency, this.duration * beat);\n            }\n\n            return this.hasNextNote();\n        }\n    }\n}",
      "music.cpp": "#include \"pxt.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/soundcard.h>\n#include <pthread.h>\n\n#define NOTE_PAUSE 20\n\nnamespace music {\n\n#define BUFLEN 1000\nstatic int16_t soundBuf[BUFLEN];\nstatic volatile int freq;\nstatic int playerRunning;\nstatic int numBuffers = 0;\n// static volatile int timeout;\n\nvoid writeAll(int fd, void *dst, uint32_t length) {\n    while (length) {\n        int curr = write(fd, dst, length);\n        if (curr < 0) return;\n        length -= curr;\n        dst = (char *)dst + curr;\n    }\n}\n\nstatic void *musicPlayer(void *) {\n    int audio_fd = open(\"/dev/dsp\", O_WRONLY);\n\n    int format = AFMT_S16_LE;\n    ioctl(audio_fd, SNDCTL_DSP_SETFMT, &format);\n\n    int stereo = 0; // mono\n    ioctl(audio_fd, SNDCTL_DSP_STEREO, &stereo);\n\n    int speed = 44100;\n    ioctl(audio_fd, SNDCTL_DSP_SPEED, &speed);\n\n    //int frag = (15 << 16) | (  10);\n    //ioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &frag);\n\n    for (;;) {\n        int numsamples = BUFLEN - 10;\n        if (freq == 0) {\n            memset(soundBuf, 0, numsamples * 2);\n        } else {\n            numBuffers++;\n            double period = (double)speed / freq;\n            if (period < 2)\n                period = 2;\n            int numperiods = BUFLEN / period;\n            numsamples = numperiods * period;\n            double step = 2 * M_PI * numperiods / numsamples;\n            double ang = 0;\n            for (int i = 0; i < numsamples; ++i) {\n                soundBuf[i] = 0x7fff * sin(ang);\n                ang += step;\n            }\n        }\n#if 0\n        if (timeout) {\n            timeout -= 1000 * numsamples / speed;\n            if (timeout < 0) {\n                timeout = 0;\n                freq = 0;\n            }\n        }\n#endif\n        writeAll(audio_fd, soundBuf, numsamples * 2);\n        for (;;) {\n            int delay;\n            ioctl(audio_fd, SNDCTL_DSP_GETODELAY, &delay);\n            if (delay < (numsamples * 2))\n                break;\n            sleep_core_us(1000);\n        }\n    }\n\n    return NULL;\n}\n\n/**\n * Play a tone through the speaker for some amount of time.\n * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n */\n//% help=music/play-tone\n//% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n//% parts=\"headphone\" async\n//% blockNamespace=music\n//% weight=76 blockGap=8\nvoid playTone(int frequency, int ms) {\n    if (!playerRunning) {\n        playerRunning = true;\n        pthread_t upd;\n        pthread_create(&upd, NULL, musicPlayer, NULL);\n        pthread_detach(upd);\n    }\n\n    if (frequency <= 0) {\n        freq = 0;\n    } else {\n        freq = frequency;\n        if (ms > 0) {\n            int d = max(1, ms - NOTE_PAUSE); // allow for short rest\n            int r = max(1, ms - d);\n            sleep_ms(d);\n            freq = 0;\n            sleep_ms(r);\n        }\n    }\n}\n\n} // namespace music\n",
      "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
      "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\nnamespace music {\n}",
      "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
      "pxt.json": "{\n    \"name\": \"music---linux\",\n    \"description\": \"The music library\",\n    \"files\": [\n        \"README.md\",\n        \"music.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"melodies.ts\",\n        \"music.ts\",\n        \"piano.ts\",\n        \"ns.ts\",\n        \"speaker.svg\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "pxtparts.json": "{\n   \"headphone\": {\n       \"numberOfPins\": 2,\n       \"visual\": {\n           \"image\": \"speaker.svg\",\n           \"width\": 90,\n           \"height\": 100,\n           \"pinDistance\": 15,\n           \"pinLocations\": [\n               {\"x\": 30, \"y\": 0},\n               {\"x\": 60, \"y\": 0}\n           ]\n       },\n       \"pinDefinitions\": [\n           {\"target\": \"ground\", \"style\": \"male\", \"orientation\": \"-Z\"},\n           {\"target\": \"D0\", \"style\": \"male\", \"orientation\": \"-Z\"}\n       ],\n       \"instantiation\": {\n           \"kind\": \"singleton\"\n       },\n       \"assembly\": [\n           {\"part\": true, \"pinIndices\": [0]},\n           {\"pinIndices\": [1]}\n       ]\n   }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace music {\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8 shim=music::playTone\n    function playTone(frequency: int32, ms: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "speaker.svg": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<svg viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g transform=\"matrix(1, 0, 0, 1, -0.00023, -58.230297)\">\n    <ellipse style=\"fill: rgb(70, 70, 70);\" cx=\"250.58\" cy=\"308.81\" rx=\"215\" ry=\"215\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 1.000001, -232.069031, 248.780606)\" cx=\"482.069\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -232.067871, 110.041956)\" cx=\"482.067\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"389.12\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"110.88\" cy=\"308.23\" rx=\"23.028\" ry=\"23.028\"/>\n    <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"169.393\" rx=\"23.028\" ry=\"23.028\"/>\n    <g transform=\"matrix(1, 0, 0, 1, -0.000009, 0.000015)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.866026, 0.5, -0.5, 0.866026, 7.386552, -105.261086)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(0.5, 0.866026, -0.866026, 0.5, 246.635941, -171.170502)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(0.999999, 0, 0, 0.999999, -65.212313, 177.387415)\" cx=\"482.068\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"555.975\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"277.735\" cy=\"236.836\" rx=\"23.028\" ry=\"23.028\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"416.855\" cy=\"97.999\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.5, 0.866026, -0.866026, -0.5, 641.934998, 245.84082)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n    <g transform=\"matrix(-0.500001, -0.866026, 0.866026, -0.500001, 108.063393, 678.85083)\">\n      <ellipse style=\"fill: rgb(0, 0, 0);\" cx=\"250\" cy=\"238.513\" rx=\"23.028\" ry=\"23.028\" transform=\"matrix(1.000001, 0, 0, 0.999999, 69.996739, 69.71816)\"/>\n      <ellipse style=\"fill: rgb(0, 0, 0);\" transform=\"matrix(1, 0, 0, 0.999999, -302.064453, 110.043115)\" cx=\"482.064\" cy=\"198.188\" rx=\"23.028\" ry=\"23.028\"/>\n    </g>\n  </g>\n</svg>\n",
      "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
    },
    "local-multiplayer": {
      "info.ts": "//% groups='[\"other\",\"Multiplayer\"]'\nnamespace info {\n    export interface PlayerInfo {\n        _score: number;\n        _life: number;\n        _player: PlayerNumber;\n        bg: number; // background color\n        border: number; // border color\n        fc: number; // font color\n        showScore?: boolean;\n        showLife?: boolean;\n        showPlayer?: boolean;\n        _h?: () => void; // onPlayerLifeOver handler\n        x?: number;\n        y?: number;\n        left?: boolean; // if true banner goes from x to the left, else goes rightward\n        up?: boolean; // if true banner goes from y up, else goes downward\n    }\n\n    let _players: PlayerInfo[];\n    let _multiplayerHud: boolean = false; \n    let _heartImage: Image;\n    let _multiplierImage: Image;\n\n    function initMultiplayerHUD() {\n        if (_multiplayerHud) return;\n        _multiplayerHud = true;\n\n        // suppress standard score and life display\n        showScore(false);\n        showLife(false);\n\n        _heartImage = _heartImage || defaultHeartImage();\n\n        _multiplierImage = _multiplierImage || img`\n                1 . 1\n                . 1 .\n                1 . 1\n            `;\n\n        game.eventContext().registerFrameHandler(95, () => {\n            // First draw players\n            for (let player = PlayerNumber.One; player < _players.length; player++) {\n                drawPlayer(player);\n            }\n\n            // Then run life over events\n            for (let player = PlayerNumber.One; player < _players.length; player++) {\n                const p = _players[player];\n                if (p && p._life !== null && p._life <= 0) {\n                    p._life = null;\n                    if (p._h) p._h();\n                }\n            }\n        })\n    }\n\n    function defaultHeartImage() {\n        return screen.isMono ?\n                img`\n                    . . 1 . 1 . .\n                    . 1 . 1 . 1 .\n                    . 1 . . . 1 .\n                    . . 1 . 1 . .\n                    . . . 1 . . .\n                `\n                :\n                img`\n                    . . 1 . 1 . .\n                    . 1 2 1 4 1 .\n                    . 1 2 4 2 1 .\n                    . . 1 2 1 . .\n                    . . . 1 . . .\n                `;\n    }\n\n\n    function initPlayer(player: PlayerNumber) {\n        if (!_players) _players = [];\n        if (_players[player]) return;\n        initMultiplayerHUD();\n\n        if (player === PlayerNumber.One) {\n            // Top left, and banner is white on red\n            _players[player] = {\n                _score: null,\n                _life: null,\n                _player: player,\n                bg: screen.isMono ? 0 : 2,\n                border: 1,\n                fc: 1,\n                showScore: null,\n                showLife: null,\n                showPlayer: null,\n                x: 0,\n                y: 0\n            };\n        } else if (player === PlayerNumber.Two) {\n            // Top right, and banner is white on blue\n            _players[player] = {\n                _score: null,\n                _life: null,\n                _player: player,\n                bg: screen.isMono ? 0 : 8,\n                border: 1,\n                fc: 1,\n                showScore: null,\n                showLife: null,\n                showPlayer: null,\n                x: screen.width,\n                y: 0,\n                left: true\n            };\n        } else if (player === PlayerNumber.Three) {\n            // Not displayed by default, bottom left, banner is white on yellow\n            _players[player] = {\n                _score: null,\n                _life: null,\n                _player: player,\n                bg: screen.isMono ? 0 : 4,\n                border: 1,\n                fc: 1,\n                showLife: false,\n                showScore: false,\n                showPlayer: false,\n                x: 0,\n                y: screen.height,\n                up: true\n            };\n        } else {\n            // Not displayed by default, bottom left, banner is white on green\n            _players[player] = {\n                _score: null,\n                _life: null,\n                _player: player,\n                bg: screen.isMono ? 0 : 7,\n                border: 1,\n                fc: 1,\n                showLife: false,\n                showScore: false,\n                showPlayer: false,\n                x: screen.width,\n                y: screen.height,\n                left: true,\n                up: true\n            };\n        }\n    }\n\n    /**\n     * Get the PlayerInfo object for the given player\n     * @param player player to get representation of\n     */\n    export function playerInfo(player: PlayerNumber): PlayerInfo {\n        initPlayer(player);\n        return _players[player];\n    }\n\n    function initPlayerScore(player: PlayerNumber) {\n        initPlayer(player);\n        const p = _players[player];\n        if (p.showScore === null) p.showScore = true;\n        if (p.showPlayer === null) p.showPlayer = true;\n\n        if (!p._score) {\n            p._score = 0;\n            saveMultiplayerHighScore();\n        }\n    }\n\n    function initPlayerLife(player: PlayerNumber) {\n        initPlayer(player);\n        const p = _players[player];\n        if (p.showLife === null) p.showLife = true;\n        if (p.showPlayer === null) p.showPlayer = true;\n\n        if (p._life === null) {\n            p._life = 3;\n        }\n    }\n\n    /**\n     * Updates the high score based on the scores of all players\n     */\n    export function saveMultiplayerHighScore() {\n        if (_players) {\n            const oS = info.score();\n            const hS = info.highScore();\n            let maxScore = hS;\n            for (let player = PlayerNumber.One; player < _players.length; player++) {\n                const p = _players[player]\n                if (p && p._score) {\n                    maxScore = Math.max(maxScore, p._score);\n                }\n            }\n            if (maxScore > hS) {\n                setScore(maxScore);\n                saveHighScore();\n                setScore(oS);\n            }\n        }\n    }\n\n    /**\n     * Get the current score for the given player if any\n     */\n    //% weight=95 blockGap=8 group=\"Multiplayer\"\n    //% blockId=local_playerScore block=\"$player score\"\n    export function playerScore(player: PlayerNumber): number {\n        initPlayerScore(player);\n        return _players[player]._score;\n    }\n\n    /**\n     * Set the score of a given player\n     * @param player the player\n     * @param value the score to set the player to\n     */\n    //% weight=93 blockGap=8 group=\"Multiplayer\"\n    //% blockId=local_setPlayerScore block=\"set $player score to $value\"\n    export function setPlayerScore(player: PlayerNumber, value: number) {\n        initPlayerScore(player);\n        _players[player]._score = value | 0;\n    }\n\n    /**\n     * Change the score of a given player by the given amount\n     * @param player the player\n     * @param value the amount of change, eg: 1\n     */\n    //% weight=92 group=\"Multiplayer\"\n    //% blockId=local_changePlayerScoreBy block=\"change $player score by $value\"\n    export function changePlayerScoreBy(player: PlayerNumber, value: number) {\n        initPlayerScore(player);\n        setPlayerScore(player, _players[player]._score + value);\n    }\n\n    /**\n     * Get the number of lives for the given player\n     * @param player the chosen player\n     */\n    //% weight=85 blockGap=8 group=\"Multiplayer\"\n    //% blockId=local_life block=\"$player life\"\n    export function playerLife(player: PlayerNumber) {\n        initPlayerLife(player);\n        return _players[player]._life;\n    }\n\n\n    /**\n     * Set the number of lives for the given player\n     * @param player the chosen player\n     * @param value the number of lives, eg: 3\n     */\n    //% weight=84 blockGap=8 group=\"Multiplayer\"\n    //% blockId=local_setLife block=\"set $player life to %value\"\n    export function setPlayerLife(player: PlayerNumber, value: number) {\n        initPlayerLife(player);\n        _players[player]._life = value | 0;\n    }\n\n    /**\n     * Change the lives by the given amount\n     * @param player the chosen player\n     * @param value the change of lives, eg: -1\n     */\n    //% weight=83 group=\"Multiplayer\"\n    //% blockId=local_changeLifeBy block=\"change $player life by %value\"\n    export function changePlayerLifeBy(player: PlayerNumber, value: number) {\n        initPlayerLife(player);\n        setPlayerLife(player, _players[player]._life + value);\n    }\n\n    /**\n     * Run code when the given player's life is at or below 0\n     * @param player Player for the event to apply to\n     * @param handler code to run on life over\n     */\n    //% weight=82 group=\"Multiplayer\"\n    //% blockId=local_gamelifeevent block=\"on $player life zero\"\n    export function onPlayerLifeZero(player: PlayerNumber, handler: () => void) {\n        initPlayer(player);\n        _players[player]._h = handler;\n    }\n\n    /**\n     * Returns true if the given player currently has a value set for health,\n     * and false otherwise.\n     * @param player player to check life of\n     */\n    export function playerHasLife(player: PlayerNumber): boolean {\n        initPlayer(player);\n        return _players[player]._life !== null;\n    }\n\n    function drawPlayer(player: PlayerNumber) {\n        if (!_players || !_players[player]) return;\n\n        const font = image.font5;\n        const p = _players[player];\n        \n        let score: string;\n        let life: string;\n        let height = 4;\n        let scoreWidth = 0;\n        let lifeWidth = 0;\n        const offsetX = 1;\n        let offsetY = 2;\n        let showScore = p.showScore && p._score !== null\n        let showLife = p.showLife && p._life !== null;\n\n        if (showScore) {\n            score = \"\" + playerScore(player);\n            scoreWidth = score.length * font.charWidth + 3;\n            height += font.charHeight;\n            offsetY += font.charHeight + 1;\n        }\n        \n        if (showLife) {\n            life = \"\" + playerLife(player);\n            lifeWidth = _heartImage.width + _multiplierImage.width + life.length * font.charWidth + 3;\n            height += _heartImage.height;\n        }\n\n        const width = Math.max(scoreWidth, lifeWidth);\n\n        // bump size for space between lines\n        if (showScore && showLife) height++;\n\n        const x = p.x - (p.left ? width : 0);\n        const y = p.y - (p.up ? height : 0);\n\n        // Bordered Box\n        if (showScore || showLife) {\n            screen.fillRect(x, y, width, height, p.border);\n            screen.fillRect(x + 1, y + 1, width - 2, height - 2, p.bg);\n        }\n\n        // print score\n        if (showScore) {\n            const bump = p.left ? width - scoreWidth: 0;\n            screen.print(score, x + offsetX + bump + 1, y + 2, p.fc, font);\n        }\n\n        // print life\n        if (showLife) {\n            const xLoc = x + offsetX + (p.left ? width - lifeWidth : 0);\n            \n            let mult = _multiplierImage.clone();\n            mult.replace(1, p.fc);\n\n            screen.drawTransparentImage(_heartImage,\n                            xLoc,\n                            y + offsetY);\n            screen.drawTransparentImage(mult,\n                            xLoc + _heartImage.width,\n                            y + offsetY + font.charHeight - _multiplierImage.height - 1);\n            screen.print(life,\n                            xLoc + _heartImage.width + _multiplierImage.width + 1,\n                            y + offsetY,\n                            p.fc,\n                            font);\n        }\n\n        // print player icon\n        if (p.showPlayer) {\n            const pNum = \"\" + p._player;\n            \n            let iconWidth = pNum.length * font.charWidth + 1;\n            const iconHeight = Math.max(height, font.charHeight + 2);\n            let iconX = p.left ? (x - iconWidth + 1) : (x + width - 1);\n            let iconY = y;\n\n            // adjustments when only player icon shown\n            if (!showScore && !showLife) {\n                iconX += p.left ? -1 : 1;\n                if (p.up) iconY -= 3;\n            }\n\n            screen.fillRect(iconX, iconY, iconWidth, iconHeight, p.border);\n            screen.print(pNum, iconX + 1, iconY + (iconHeight >> 1) - (font.charHeight >> 1), p.bg, font);\n        }\n    }\n}",
      "local.ts": "enum PlayerNumber {\n    //% block=\"player one\"\n    One = 1,\n    //% block=\"player two\"\n    Two,\n    //% block=\"player three\"\n    Three,\n    //% block=\"player four\"\n    Four\n}\n\n//% groups='[\"other\",\"Multiplayer\"]'\nnamespace controller {\n\n    enum ButtonOffset {\n        Left = 0,\n        Up,\n        Right,\n        Down,\n        A,\n        B,\n        Menu\n    }\n\n    interface ControlledPlayer {\n        p: PlayerNumber;\n        s: Sprite;\n        vx: PlayerNumber;\n        vy: PlayerNumber;\n    }\n\n    let playerSprites: Sprite[];\n    let controlledPlayers: ControlledPlayer[];\n\n    /**\n     * Set the sprite for a player\n     */\n    //% weight=100 group=\"Multiplayer\"\n    //% blockId=local_setplayersprite block=\"set sprite for $player to $sprite\"\n    //% sprite.shadow=\"spritescreate\"\n    export function setPlayerSprite(player: PlayerNumber, sprite: Sprite) {\n        if (!playerSprites) playerSprites = [];\n        playerSprites[player] = sprite;\n\n        for (let i = 0; controlledPlayers && i < controlledPlayers.length; i++) {\n            if (controlledPlayers[i].p === player) {\n                controlledPlayers[i].s = sprite;\n                break;\n            }\n        }\n\n        // Set up events\n        multiLeft._initPlayer(player);\n        multiUp._initPlayer(player);\n        multiRight._initPlayer(player);\n        multiDown._initPlayer(player);\n        multiA._initPlayer(player);\n        multiB._initPlayer(player);\n    }\n\n    /**\n     * Get the sprite for a player\n     */\n    //% weight=20 group=\"Multiplayer\"\n    //% blockId=local_playersprite block=\"%player sprite\"\n    export function playerSprite(player: PlayerNumber): Sprite {\n        if (!playerSprites || !playerSprites[player]) return null;\n        return playerSprites[player];\n    }\n\n    /**\n     * Control a sprite using the direction buttons from the controller. Note that this\n     * control will take over the vx and vy of the sprite and overwrite any changes\n     * made unless a 0 is passed.\n     *\n     * @param player The Player to control\n     * @param vx The velocity used for horizontal movement when left/right is pressed\n     * @param vy The velocity used for vertical movement when up/down is pressed\n     */\n    //% blockId=\"local_game_control_player\" block=\"control $player with vx $vx vy $vy\"\n    //% weight=99 group=\"Multiplayer\"\n    //% vx.defl=100 vy.defl=100\n    export function controlPlayer(player: PlayerNumber, vx: number, vy: number) {        \n        if (!controlledPlayers) {\n            controlledPlayers = [];\n            game.currentScene().eventContext.registerFrameHandler(19, () => {\n                controlledPlayers.forEach(controlled => {\n                    if (!controlled.s) return;\n\n                    if (controlled.vx) {\n                        controlled.s.vx = 0;\n\n                        if (controller.multiRight.isPressed(controlled.p)) {\n                            controlled.s.vx = controlled.vx;\n                        }\n                        if (controller.multiLeft.isPressed(controlled.p)) {\n                            controlled.s.vx = -controlled.vx;\n                        }\n                    }\n\n                    if (controlled.vy) {\n                        controlled.s.vy = 0;\n\n                        if (controller.multiDown.isPressed(controlled.p)) {\n                            controlled.s.vy = controlled.vy;\n                        }\n                        if (controller.multiUp.isPressed(controlled.p)) {\n                            controlled.s.vy = -controlled.vy;\n                        }\n                    }\n                });\n            });\n        }\n\n        for (let i = 0; controlledPlayers && i < controlledPlayers.length; i++) {\n            if (controlledPlayers[i].p === player) {\n                controlledPlayers[i].vx = vx;\n                controlledPlayers[i].vy = vy;\n                return;\n            }\n        }\n\n        controlledPlayers.push({\n            p: player,\n            s: playerSprite(player),\n            vx: vx,\n            vy: vy\n        });\n    }\n\n    /**\n     * Run code for each player that has been assigned a sprite\n     * @param handler the code to run for each player\n     */\n    export function forEachPlayer(handler: (player: PlayerNumber) => void) {\n        if (!playerSprites) return;\n\n        for (let player = 0; player < playerSprites.length; ++player) {\n            if (playerSprites[player]) {\n                handler(player);\n            }\n        }\n    }\n\n    //% fixedInstances\n    export class MetaButton {\n        buttonOffset: ButtonOffset;\n        buttons: controller.Button[];\n        handlers: ((player: number, sprite: Sprite) => void)[];\n\n        constructor(button: ButtonOffset) {\n            this.buttonOffset = button;\n        }\n\n        _initPlayer(player: PlayerNumber) {\n            if (!this.buttons) this.buttons = [];\n            if (this.buttons[player]) return;\n\n            const b = new controller.Button(1 + 7 * (player - 1) + this.buttonOffset);\n            this.buttons[player] = b;\n            this.registerPlayerEvent(b, player, ControllerButtonEvent.Pressed);\n            this.registerPlayerEvent(b, player, ControllerButtonEvent.Released);\n            this.registerPlayerEvent(b, player, ControllerButtonEvent.Repeated);\n        }\n\n        /**\n         * Run some code when a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/on-event draggableParameters group=\"Multiplayer\"\n        //% blockId=local_keyonevent block=\"on $this **button** $event $player $playerSprite\"\n        onEvent(event: ControllerButtonEvent, handler: (player: number, playerSprite: Sprite) => void) {\n            if (!this.handlers) this.handlers = [];\n            this.handlers[event] = handler;\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=97 blockGap=8 group=\"Multiplayer\"\n        //% blockId=local_keypauseuntil block=\"pause until $player $this **button** is $event\"\n        pauseUntil(player: PlayerNumber, event: ControllerButtonEvent) {\n            this._initPlayer(player);\n            this.buttons[player].pauseUntil(event);\n        }\n\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=95 blockGap=8 group=\"Multiplayer\"\n        //% blockId=local_keyispressed block=\"is $player $this **button** pressed\"\n        isPressed(player: PlayerNumber) {\n            this._initPlayer(player);\n            return this.buttons[player].isPressed();\n        }\n\n        private registerPlayerEvent(b: controller.Button, player: PlayerNumber, event: ControllerButtonEvent) {\n            b.onEvent(event, () => this.handleEvent(event, player));\n        }\n\n        private handleEvent(event: ControllerButtonEvent, player: PlayerNumber) {\n            if (!this.handlers) return;\n\n            const s = playerSprites && playerSprites[player];\n            if (!s) return;\n\n            const h = this.handlers[event];\n            if (!h) return;\n\n            h(player, s);\n        }\n    }\n\n    //% fixedInstance block=\"left\"\n    export const multiLeft = new MetaButton(ButtonOffset.Left)\n    //% fixedInstance block=\"up\"\n    export const multiUp = new MetaButton(ButtonOffset.Up)\n    //% fixedInstance block=\"right\"\n    export const multiRight = new MetaButton(ButtonOffset.Right)\n    //% fixedInstance block=\"down\"\n    export const multiDown = new MetaButton(ButtonOffset.Down)\n    //% fixedInstance block=\"A\"\n    export const multiA = new MetaButton(ButtonOffset.A)\n    //% fixedInstance block=\"B\"\n    export const multiB = new MetaButton(ButtonOffset.B)\n}",
      "pxt.json": "{\n    \"name\": \"local-multiplayer\",\n    \"description\": \"Local multiplayer\",\n    \"files\": [\n        \"local.ts\",\n        \"info.ts\"\n    ],\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"game\": \"*\"\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    },\n    \"icon\": \"/arcade/docs/static/libs/local-multiplayer.png\"\n}"
    },
    "device": {
      "README.md": "# device\n\nThe core library for fantasy game console target.\n\n",
      "bigFood.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.food\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"bigBurger\": \"5CAgAAAAAAAA7v8AgPj//w8AAAAAAAAA7rvL73iHvmvGDwAAAAAA7mZmtvt2Z/++ZvwAAAAA4Gu2Zma7L2L4/232AAAAAL62u7tmtuxihv/daw8AAMC7u0S0a2b7Inb+37QPAAC8RFtLRLRm+yJ27t+9+wAATES0REREZsYid/9PTfsAwERERERERGu2LGf/703rAMBEREREtEtktiyH7/9Nuw/AREtERFtLtLYs9u7+TbQPTLS1RES7RLS2LIbv/k20D0y0S0REREREuyxm7/5NtA9MRERERERERLssduf/TbQPTERERERERES7LHfn/020D0xEREREREREtCx35u5NRA9GRES7RERERLQsd+bvTUQMRrtEW0tERES0LHfm701EDEZbS7REREREtCx36O5NRAxGtERERERERLQsZ+juTUQMRkRERES0S0S0LGbu/k1EDGBEREtEtLVEtCxm7/5NRA5gRLS1RES7RLQsdv/+TUQOYERES0RERES0LHfu/03kAABGRERERERExCJn7k9N5AAARkS0S0RERPQi9+7eS+QAALBEtLVERETLcvfu3kQOAAAAS0S7RERELGL/771EDgAAAGBEREREtCxm/75L5AAAAAAA5kREtPt2hv+7ZO4AAAAAAADuu8vveGe+ZuYOAAAAAAAAAO7/AIj4/+8OAAAA\",\r\n  \"bigDrumstick\": \"5CAgAAAAAAAiIiICAAAAAAAAAAAAAAAiu7u7IgIAAAAAAAAAAAAgu7u7u7viAAAAAAAAAAAAQkS7RLS76w4AAAAAAAAAIEREREtEu+sOAAAAAAAAAEJERERERLS77gAAAAAAAABCRERERES0u+4AAAAAAACwRERERES0RLvuDgAAAAAAsEREREREtEu76w4AAAAAALBERERERLS7u+sOAAAAAABLREREREREtLvrDgAAAAAAS0RERERERLu0Kw4AAAAAAEtNRERERES7RCviAAAAAABL3UREREREREsrIgAAAAAAS91ERERERES7uyIOAAAAAEvUTUREREREu7srDgAAAACw1E1ERERERLREuwIAAAAAsETdRERERERERLTrAAAAAABLRE1ERERERLu06wAAAAAA4EtERERERES0u+sAAAAAAAC+u7tEREREtLvrAAAAAAAA4L67S0S0RES77gAAAAAAAADg7rtEu0u0u84AAAAAAAAAAADu7u67u+7bDAAAAAAAAAAAAAAA7u7O3c0AAAAAAAAAAAAAAAAAANvRy8wAAAAAAAAAAAAAAACwERG9DAAAAAAAAAAAAAAAABsREQwAAAAAAAAAAAAAAAAb0R0MAAAAAAAAAAAAAAAA29HLAAAAAAAAAAAAAAAAALsRDAAAAAAAAAAAAAAAAACwzAAA\",\r\n  \"bigHam\": \"5CAgAAAAAAAAICIiIu7u7gAAAAAAAAAAIDLdERERET3uAAAAAAAAIDIdMTMzMzPdPQ4AAAAAADIRHTMzMzMzM93jAAAAACATPdPRMzMzMzPTPQ4AAAAyMTMz3d09MzMzMx0OAAAg0zEzMzMzPTMzMzMT7QAAMh0zMzMzM90dMTMzE+EAANIxMzMzMzPd0R0zMxO9DiDTMzMzMzMzEz3dMTMdMw4g0zMzMzMzMxMz09HT0TMOMh0zMzMzMzPdMRM93dM9DjIRPTMzMzPT3R3ROzPT0Q8yEdE9MzMzPTMzuzMzM9EPMtEdPdPd3TMzMzMzMzMRDzLR093dMzMzMzMzMzMzMQ+yEzPTPTMzMzMzMzMz07EPvtM90z0zMzMzMzMzM93jDu4zMTMzMzMzMzMzMzPd+w7gOxMzMzMzMzMzMzPds/4A4O473TMzMzMzMzMdPfv/AADu7jvd3d3d3R0RPev//gAA4O7uu9MRERHRs2b/7w8AAADgTkS7u2Zma2a77u8PAAAAAE5EtEa0RLS76+7/AAAAAADgTkRGZEa0a+brDwAAAAAAAO5EREa0RGa76wAAAAAAAADgTkRGZEa7uw4AAAAAAAAAAOBOZEa0u+4AAAAAAAAAAAAA4E5LZOYAAAAAAAAAAAAAAAC+ZuYOAAAAAAAAAAAAAAAA4O4OAAAAAAAA\",\r\n  \"bigPizza\": \"5CAgAAAAAAAAAAAAAAAAAAC7REQAAAAAAAAAAAAAAAC7XRVBAAAAAAAAAAAAAABLXVXR5QAAAAAAAAAAAABG1F1dQeUAAAAAAAAAAABrh1XVHV0EAAAAAAAAAAC7bYclLh1UDgAAAAAAAAC7XVVWIuJSVA4AAAAAAABL5C7VJSIi3tRNAAAAAAC7PSLi0iUjIt5N7gAAAABAXSUiIl4lMyLe5QAAAACwVFUlIyJeVSLi0+UAAAAAS13VJTMiXlXlPl0EAODuTl1V1VUi4lNVVVVUBADrS+tUVdVW7T5V1VUV1A4AvkO03lVth91VVdVdFVQOAL40Q0tVZYddVVXVXUFFAAC7NDNE3VVWVVVV1VZBRQAAu0szQ9RVVVXuUmWH1eUAAEu7RDNEXVUlIi5lhxHtBAC7tEQztFRVIiLiVRbR3U0AsEtLM0O7VTIi4lXRVOROAAC7RDNDu9QyI+JVQV0OAAAAsEtEQ0ROLSI+VU3lAAAAAAC+RDS069TuUxXU5AAAAAAA4EtEROu+3VVR1O0AAAAAAAC7RES0Tt3VRdTkAAAAAAAAsEtEROvU1UVNDgAAAAAAAAC7RES7S0TU7Q4AAAAAAAAA4E60u+vUTe4AAAAAAAAAAADuRLS77uTuAAAAAAAAAAAA4O676+7uDgAAAAAAAAAAAADr7u7u7gAAAAAA\",\r\n  \"bigTaco\": \"5CAgAAAAAAAAAAAA7u7u7u4AAAAAAAAAAADg7lRVVVVE7gAAAAAAAADgTlXl7v/k7lQOAAAAAABATlVVRO7/7v5O5QAAAAAARGZW5O7k/u/u7+UAAAAAQFV2Ru7u7v/+/+9UDgAAAFRld0hO/v7+///vXg4AAEAlcnfmTv7//u//7k4OAABOMnNEh/7/7+5UVVVFDgDgRCJyRXfm7lRV1d3d3Q4AToYufkV25lTVTd1VVd0OAG53d1dkZl7VXVVV1UXdDuB0RHdWdObVXVVVVVVV7QDgdUVnRndeXVXVVV1V1e0ATmVFZ2fn1dVVVVRVXdUOAF5lRXciXl1VVVVVVVVFDgBedkQnM1RdVVVVVUVV7QAAbnd3JuLVVVVV1VVV3Q4AAG4id+dC1VVdVVXV1U0OAAAuM3JnXl1VVVVVVd3tAAAA7i5yZ1RdRVXVVdXdDgAAACDiYmfVXVXVVVVF7QAAAADgdmfm1V1VVVXV3e0AAAAAAHh35tVVVdVVVd0OAAAAAAB4d+bd1VVdXd3tAAAAAAAAYHbn3VVV3d3d5AAAAAAAAGBn5t1VVd3U3Q4AAAAAAACAd4bd1FXd3e0AAAAAAAAAAIiG1N1V1d0OAAAAAAAAAAAAiNjdXdTtAAAAAAAAAAAAAABA1N3dDgAAAAAAAAAAAAAAAETu7gAAAAAAAAAA\",\r\n  \"bigCake\": \"5CAgAAAAAAAAsLu7u7u7u7sAAAAAAAAAALCzW9U7U1W9AAAAAAAAAADbM1tVtVPdtQAAAAAAAACw0z1bVbVTVV0LAAAAAAAAsN09W1U1U1VVCwAAAAAAALA9PTtVVdNV1QsAAAAAAAA7PT27VVU7XdULAAAAAACw2zM9s1VVO11VvQAAAAAAsNMzPbNVVTtVVb0AAAAAALA9M9OzVVUzVVW1AAAAAADbMzPTvVVVNVVdtQAAAAAA2zMz071VVTVTVVULAAAAsD0zM9MzU1W9U1VdCwAAALAzMzPTM1tVvVNVXQsAAAC7MzMzMz1bVbVTVV0LAAAAOzMzMzM9W9U121VVtQAAsDMzMzMz3VtVVdtdVbUAALszMzMzM93bVdU7XdW1AAA7MzMzMzM921XVO1VVtQAAOyPuOzMzPdtd3TtV3dULsDMyIr4zMz273dUzVd3VC7Az7iLiMzM9o13VvV3d1Qs7M+4i4jMzPaNd1b3dXVULOz3uIuIzM92j3V29293VvTvTLiK+MzPTo91dvdvdVb2wM+3uOzMz06Pd3b3b3VW9AKs73TMzMzO92929293drQAAqtPd3TMzPdvdPdvdXasAAACqM93d3d2z3d273bWjAAAAAKo60909s7u7u7szqwAAAAAAoKo7s7u7MzMzswoAAAAAAAAAqqqqqqqqqqoA\",\r\n  \"bigDonut\": \"5CAgAAAAAAAAAAC7qqqqAAAAAAAAAAAAALC7093ds+4AAAAAAAAAALA73d1t3T267gAAAAAAAAA73WM2djg9q+sOAAAAAACw0zObOHY407u67gAAAAAAOz1jiTN2ONOzur4OAAAAsDMzYzgzZjvTPavrDgAAADs0MzMzMzMzM92j6+sAALBDJTMzMzMzMyMzverrAAA7QyUzMzMzMzNUMj266wAAO0M0MzOzuzMzVDI9u7sOsDMzM9OzqrszM0TTo7S0DrAzMzM9O6M6IzMzM0q0tA5gNjPTvTOqM0I+MzNKtEQOa4cz07OjOjNCPjOzSrtEDmuHM9M7qjMzIzMzo0SzRA5rhzPTO7ozMzMz06tEs+QAOzYzM7s7MzMzZt1KNEPkADszMzO7MzMzY4k9SjRL5AA7MzMzMzMzM5Y4PUo0RA4AOzMzMzNjODOGM61Es0QOALCGM0QzY4czM9OjREPkAACgljhUMjN2ONM9SjRL5AAAoGOJVDIzYzYzo0S0RA4AAAA6ZiMzIzMzq0pES+QAAAAAOjMzM0I+q0pEtEQOAAAAAKAzMzNCvkpEREvkAAAAAACgutPdI7NERLtEDgAAAAAAAKqqqrpLtLtE5AAAAAAAAADg7ktEtO5L5A4AAAAAAAAAAODu7u676w4AAAAAAAAAAAAAAO7u7g4AAAAAAAAA\",\r\n  \"bigIceCream\": \"5CAgAAAAAAAAAAAAAAAAAEREAAAAAAAAAAAAAEBERETVXQQAAAAAADCzMwDU3URVVd1FAAAAALAT0RFL3d1VVFXVXQQAAAA7HdER3btdVUVVVd1FAAAA2x3RHdHdW1VVVFXVTQAAMzMdER0R3bFVVUVVVU0As93dExHdEd0RW1VVVFVFMNsR0dER0RHdHbFVVUXVRbDdEREdHREd0R3RW1VF3QSw3RER0dER0RHdEVtV1dQEMNEdEdHRHREdEd2xVdXUBBMRHRHR0d0R0RExPVvVTQATEdERER3dExHdETNb3U0AExHRHREd3T0R3R0x291NABMREd0R0dHdExHd0bPdTQDbvdvRHdER3dMR3RGz3QQAO9sRE90RHdE9Ed0dvU0AALAdET3RHd0RPR3RHTEEAAAwEd3dEx3RHd0T0R3RAwAAG9ER0RPREd3d09EdEQMAABsdERHdER3R3TPRHREDAADTERER3REd0d090R3RAwAAExHd3d0R3RHdPdEdPQAAABPRHRHdHdER3T3dETMAAAAT0RPd3R3REd293TEDAAAA0xHT3d0T0dHdszsDAAAAADARPdM9E9Ex3bsAAAAAAAAwETG7OxHdPT0LAAAAAAAAABMRswAz3TO7AAAAAAAAAAAwHdELALu7AAAAAAAAAAAAADO7AAAAAAAAAAAAAAAA\",\r\n  \"plate\": \"5DEYAAAAAACwu7sLAAAAAAAAALDbERG9CwAAAAAAANsRERERvQAAAAAAsB0RERER0QsAAAAA2xEREREREb0AAAAAGxEREREREbEAAACwHRER3R0REdELAACwERHd0d0RERELAADbEdER3d0dERG9AAAbEd3R3d3dERG9AAAbER3R3d3dHRGxALAd0R3dERHdGxHRC7AR0REdERHR2xHRC7AR0dEdERERvRERC7ARHdERERERvR0RC9sRHd0RERER0RsRC9sRHd0RERER0RsRvRvRER0RERERERsRvRvRER0REREREdsRvRvRER0REREREbsRsRvRER0REREREbsRsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREb0RsRvRER0REREREd0RsRvRER0REREREd0RsRvRER0REREREd0RvRsRHR0RERERER0RvdsRHd0RERER0R0RvdsRHd0RERER0R0RC7ARHdERERER3R0RC7AR0dEdERERvRERC7AR0REdERHRvRHRC7Ad0R3dERHd2xHRCwAbER3R3d3dGxGxAAAbEd3R3d29HRG9AADbEdER3d3bERG9AACwEREd0bsdERELAACwHRER3R0REdELAAAAGxEREREREbEAAAAA2xEREREREb0AAAAAsB0RERER0QsAAAAAANsRERERvQAAAAAAALDbERG9CwAAAAAAAACwu7sLAAAAAA==\"\r\n}",
      "bigFood.ts": "namespace sprites.food {\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigBurger = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigDrumstick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigHam = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigPizza = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigTaco = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigCake = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigDonut = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const bigIceCream = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const plate = image.ofBuffer(hex``);\n}\n",
      "ns.ts": "//% color=#8854d0\nnamespace game {\n    /**\n     * Returns the time since the game started in milliseconds\n     */\n    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n    //% group=\"Gameplay\" weight=11\n    //% help=game/runtime\n    export function runtime(): number {\n        return control.millis();\n    }\n\n    /**\n     * Reset the current game. This is usually equivalent to pressing\n     * the reset button to restart the current program\n     */\n    //% blockId=arcade_game_reset block=\"reset game\"\n    //% group=\"Gameplay\" weight=10\n    //% help=game/reset\n    export function reset() {\n        control.reset();\n    }\n}\n\n//% color=\"#4b6584\"\nnamespace scene {\n\n}\n\n//% color=\"#cf6a87\"\nnamespace info {\n\n}\n\n//% color=#E30FC0\nnamespace music {\n\n}\n\n//% color=#B09EFF\nnamespace player {\n\n}\n\n//% color=#FF5722 weight=90 advanced=true\nnamespace control {\n\n}\n",
      "pxt.json": "{\n    \"name\": \"device\",\n    \"description\": \"The fantasy game console library\",\n    \"files\": [\n        \"README.md\",\n        \"ns.ts\",\n        \"sprites.castle.jres\",\n        \"sprites.castle.ts\",\n        \"sprites.duck.jres\",\n        \"sprites.duck.ts\",\n        \"sprites.space.jres\",\n        \"sprites.space.ts\",\n        \"sprites.vehicle.ts\",\n        \"sprites.vehicle.jres\",\n        \"bigFood.jres\",\n        \"bigFood.ts\",\n        \"smallFood.jres\",\n        \"smallFood.ts\",\n        \"startup.ts\"\n    ],\n    \"core\": true,\n    \"dependencies\": {\n        \"hw\": \"*\"\n    },\n    \"palette\": [\n        \"#000000\",\n        \"#ffffff\",\n        \"#ff2121\",\n        \"#ff93c4\",\n        \"#ff8135\",\n        \"#fff609\",\n        \"#249ca3\",\n        \"#78dc52\",\n        \"#003fad\",\n        \"#87f2ff\",\n        \"#8e2ec4\",\n        \"#a4839f\",\n        \"#5c406c\",\n        \"#e5cdc4\",\n        \"#91463d\",\n        \"#000000\"\n    ],\n    \"screenSize\": {\n        \"width\": 160,\n        \"height\": 120\n    },\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "smallFood.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.food\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"smallBurger\": \"5BAQAAAA7g6I7u4AAOy763fG6w7ATES7Lma+DsBERUTucujLvEREROtiyMtMRERE5GLMxExERUTkcuzES0RERORy6MRLRURU5HLo5EtERETkYuzkS0RERORi7OS7VERE63LM5LBEVETuYujksEtEtC7Gvg4A7EvrdszrDgAA7A6I7u4A\",\r\n  \"smallApple\": \"5BAQAAAAwMzMDAAAAMDs7u7uAgAA7O7u7u4uAADu7iIi4u4C4O4uIiIi4gLg7iIiIiIiLuDuLiIiIiIuzswsIiIiIuR8ZywiIiIi5HfuIiIiIiLk4OJEIiIiQuLgIlUkIiJCDgAuVCQiIiQOAC4iIiJE4gAA4C4iIuIOAAAA4O7uDgAA\",\r\n  \"smallLemon\": \"5BAQAEQLsMzMAAAAVLRL3UTMAABUVV1F1UQMAEBVVVVV1cQAQFFVVUVVRAxUVVVVXUVNDFQRVVXVVUTLVBFVVVXdRMRUUVVVVU1ExFRVVVVVTUTEQBVVVVXVRMtAFVFVVVVNywBUEVVVVV20AEBVFVVVVbUAAERVVUVdRAAAAEREy0wE\",\r\n  \"smallDrumstick\": \"5BAQAAAiIiIAAAAAILK7KwIAAACyRES06wAAAEJERES7DgAAS0RERLsOAABLREREtOsAAEtNRES05AAAS01ERLTkAABL1EREu+sAALBETUS77gAAALtEtOvuAAAAALvu7r7LDAAAAAAA2xHBAAAAAACw0csAAAAAALDRDAAAAAAAALsA\",\r\n  \"smallHam\": \"5BAQAAAAACIi7g4AAAAi093d4wAAIBMxM9M9DgAy0T0zMxPjIBMz0zMzE+Mg3TMTETPR4zIxMzET3d3jMjEzETEzHeMyPdMzMzMT4zLdPTMzMx3rINMxMzMdse7gMhMRET277gDuOzO7u+vuAAC+RERE7g4AALBLRLTuAAAAALvu7gAA\",\r\n  \"smallPizza\": \"5BAQAAAAAAAAALtEAAAAAAC7XU0AAAAAuyNTTQAAALtdIlJNAAC7XVcjXQQAsD0yVVXVBLtLJSJVV9UES7s1MlVVRQBLtFVVI1NNAEu0VFciUk0AsERLVSNTTQAAS+RUVdUEAACwRO5V3QQAAABL5N7tAAAAALDk7k4AAAAAAO7uBAAA\",\r\n  \"smallDonut\": \"5BAQAAAAALurqgAAAAC7MzOjDgAAsDMzMzPqAADbPTMzM+oOsN0zMzMzug6wPTOzM9O6Dts9M6oz00oO2zOjOjPTSg7bM6MzM61EDjszOzMzrUQOOjMzM9NKtA46MzMzrUTkAKAzM91KRO4AoDozqkTkDgAAqqpERO4AAAAAu7vuAAAA\",\r\n  \"smallCake\": \"5BAQAAAAsLu7uwsAAACwsz0zCwAAADuz1dMLAAAAO7PVU7MAALAzvVVTvQAAsDO9VVO1AAA7M71dMzULADszPVs91Quw7jPTWzVVC+AjPtNbNVUL6yI+01o1VbM77jPT2j1VvTszM9Pavd29sDoz3dq93a0AoDo92r07qwAAoKqqqqoK\",\r\n  \"smallIceCream\": \"5BAQAAAAAAAAREQAAAAzS0RdVQQAMBG91N1VRQDTERG9VV1FMN0dEdFb1UUTEdEREb3VBBMRER0Rsd0E2xER0RHR2wQz3RHRERFLANPRHREREUsAHREdER0RvQAdEdERHRE9ABMdEREd0QMAEzMb0TszAAAwMTAzCwAAAAAzAAAAAAAA\",\r\n  \"smallStrawberry\": \"5BAQAAAAAO7u7u4OAADuIiIi7s4A4CJERCTizgAuQkUiIu7CAC5EIiIiIs4ALiQiQiLizoAoYmYmIiTMZuh3dyYiIs5ghndnIkLiDABmdyZC4u4MAGBnIiIi7gwAdndnLuLOAGBnaHfn7gwAgAiGdnfMAAAAAIBgZgYAAAAAAAAAAAAA\",\r\n  \"smallCherries\": \"5BAQAAAA4O4MAAAAAAAuIsIAAAAA4ELiLgwAAADgJeLu4gAAAOAkIuLCAAAA4CIi4sIAAADILiIi7gAAAGgsIuLOzAAAaMjsLiLiDGCHAOBCIu7OYIcA4CUi7sJ2CADgJCLiwnaIZsgiIuLCdnZ3Ziwi7sJ2iIiIyCIiDIYIAAAA7swA\",\r\n  \"smallTaco\": \"5BAQAAAAAODu7k4AAADgTlVVVQQAAF5VzOxORQDgZYbOzO5EAF4iZ+hVVeXgZCJnVUVV5eBlh1hFVVXkTnaGVVVFVQ5eIlZUVFXlAF4iVFVVVeQAXmdVVEVVDgDgRlVVVeUAAOBGVUVV5AAAAE5FVVUOAAAA4FRV5QAAAAAAQEQEAAAA\"\r\n}",
      "smallFood.ts": "namespace sprites.food {\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallBurger = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallApple = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallLemon = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallDrumstick = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallHam = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallPizza = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallDonut = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallCake = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallIceCream = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallStrawberry = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallCherries = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const smallTaco = image.ofBuffer(hex``);\n}\n",
      "sprites.castle.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.castle\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"heroFrontAttack1\": \"5BgYAAAAAAD/8P8AAAAAAAAA///v37sPAAAAAADw//7u37v8AAAAAAD/7/JP37v8AAAAAAD/Lv8b37v/DwAAAPAvLu///f/0DwAAAPAiLu/UTSL1AAAAAPAiLu/UTSL1AAAAAPAvLu//TSL0DwAAAAD/Lv8b7SL0DwAAAAD/7/JP7v8PAAAAAADw7/7u/tQEAAAAAAAA///vD04EAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroFrontAttack2\": \"5BgYAAAAAAAA//8AAAAAAAAAAAD/vcsPAAAAAAAA///v//8PAAAAAADw//7u/gQAAAAAAAD/7/JP7v//wMwAAAD/Lv8b7SL0380AAPAvLu//TSL03QwAAPAiLu/UTcLczQAAAPAiLu/UTcLdDAAAAPAvLu//7c7MDwAAAAD/Lv8b1O30DwAAAAD/7/JP3u3/AAAAAADw7/7uTw4AAAAAAAAA///v7wAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroFrontAttack3\": \"5BgYAAAAAAAA//8AAAAAAAAAAAD/vcsPAAAAAAAA8P////8PAAAAAAAA/+/+7u8EAAAAAAAA/+/yT/7/AAAAAADwL+LyGyT0DwAAAADwIuLi/y30DwAAAAAvIuLi1C31DwAAAAAvIuLi1C31D8AAAADwIuLi/y30DszMzADwL+LyG/Tf7RwREQAA/+/yT07U7czMzAAA/+/+7u/uDsAAAAAA8P///w4AAAAAAAAAAPD/DwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroFrontAttack4\": \"5BgYAAAAAAAA//8AAAAAAAAAAPD/vcsPAAAAAADw///v//8PAAAAAAD/7+/u/gQAAAAAAPD/Lv9P7v//AAAAAPDv8r/b7SL0DwAAAP/i8v7fTSL0DwAAAC/i8k7UTSL1AAAAAC/i8k7UTSL1AAAAAP/i8v7fTSL0DwAAAPDv8r/b5CL0DwAAAPD/Lv9P7v//AAAAAAD/7u/uTkEAAAAAAADw///v/04AAAAAAAAAAPD/3+0AAAAAAAAAAAAA3u0AAAAAAAAAAADAzA4AAAAAAAAAAADAzQAAAAAAAAAAAADczQAAAAAAAAAAAMDdDAAAAAAAAAAAANzNAAAAAAAAAAAAANwMAAAAAAAAAAAAAMwAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroSideAttackLeft1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAzAAAAAAAAAAAAADA3QwAAAAAAAAAAAAA3M0AAAAAAAAAAAAAwN3MAAAAAAAAAAAA/9zNDgAAAAAAAAD/Ls/M7QAAAAAAAPDi4u/e7f8AAAAAAC/i8k7tRFIPAAAAAP/i8k7dTl4PAAAAAO/v8v7fJEL/AAAAAO/+/r/RJEL/AAAAAO/+Lu9ELkL/AAAAAO/uL0/tLkIPAAAAAPDuL0/k//8AAAAAAPDv7+/uDwAAAAAAAAD////+AAAAAAAAAAAAAP8PAAAAAAAAAA==\",\r\n  \"heroSideAttackLeft2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMDAAAAAAAAAAAAADcDAAAAAAAAAAAAADAzQAAAAAAAAAAAADA3QwAAAAAAAAAAAAA3MwAAAAAAAAAAAAA3M0AAAAAAAAAAAAAwMwAAAAAAAAAAP//4N0OAAAAAAAA/y7v790OAAAAAADw7+Lv/k4OAAAAAADw4vJO3U4OAAAAAAAv4vJO3eL/AAAAAPAi4vL+31L/AAAAAPDv/v6/20IPAAAAAPDv/v6/20IPAAAAAADv/i7vREIPAAAAAADv7i9P7UL/AAAAAADv7i9P5EL/AAAAAADw7u/v7v//AAAAAADw7////gAAAAAAAAAA///vDwAAAAAAAAAAAPD/AAAAAAAAAA==\",\r\n  \"heroSideAttackLeft3\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwA0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAA8P8PzMwMAAAAAADw7/L+4A4AAAAAAAD/Lv7u3u0AAAAAAPAvLu/U3u0AAAAAAPAiLu/U7eQPAAAAAC//Lu//7eT/AAAAAP/u7/+7Lf7/AAAAAPDu7/JOJPQPAAAAAPDu/vLULvQPAAAAAPDu/vJELvT/AAAAAADv/v7u/v//AAAAAAD//v/vDwD/AAAAAADw///+AAAAAAAAAAAAAP8PAAAAAAAAAA==\",\r\n  \"heroSideAttackLeft4\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAzAAAAAAA//8AAADczQAAAAD/Lu8PAMDdDAAAAPDi4u/+z9zNAAAAAC/i8k7dzt0MAAAAAP/i8k7dxMwPAAAAAO/v8v7fJEL/AAAAAO/+/r/RJEL/AAAAAO/+Lu9E7k//AAAAAO/uL0/t3U4PAAAAAPDuL0/k3f4AAAAAAPDv7+/u/wAAAAAAAAD////+AAAAAAAAAAAAAP8PAAAAAAAAAA==\",\r\n  \"heroSideAttackRight4\": \"5BgYAAAAAP8PAAAAAAAAAAD////+AAAAAAAAAPDv7+/u/wAAAAAAAPDuL0/k3f4AAAAAAO/uL0/t3U4PAAAAAO/+Lu9E7k//AAAAAO/+/r/RJEL/AAAAAO/v8v7fJEL/AAAAAP/i8k7dxMwPAAAAAC/i8k7dzt0MAAAAAPDi4u/+z9zNAAAAAAD/Lu8PAMDdDAAAAAAA//8AAADczQAAAAAAAAAAAADAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroSideAttackRight3\": \"5BgYAAAAAP8PAAAAAAAAAADw///+AAAAAAAAAAD//v/vDwD/AAAAAADv/v7u/v//AAAAAPDu/vJELvT/AAAAAPDu/vLULvQPAAAAAPDu7/JOJPQPAAAAAP/u7/+7Lf7/AAAAAC//Lu//7eT/AAAAAPAiLu/U7eQPAAAAAPAvLu/U3u0AAAAAAAD/Lv7u3u0AAAAAAADw7/L+4A4AAAAAAAAA8P8PzMwMAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwM0AAAAAAAAAAAAAwA0AAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroSideAttackRight2\": \"5BgYAAAAAPD/AAAAAAAAAAAA///vDwAAAAAAAADw7////gAAAAAAAADw7u/v7v//AAAAAADv7i9P5EL/AAAAAADv7i9P7UL/AAAAAADv/i7vREIPAAAAAPDv/v6/20IPAAAAAPDv/v6/20IPAAAAAPAi4vL+31L/AAAAAAAv4vJO3eL/AAAAAADw4vJO3U4OAAAAAADw7+Lv/k4OAAAAAAAA/y7v790OAAAAAAAAAP//4N0OAAAAAAAAAAAAwMwAAAAAAAAAAAAA3M0AAAAAAAAAAAAA3MwAAAAAAAAAAADA3QwAAAAAAAAAAADAzQAAAAAAAAAAAADcDAAAAAAAAAAAAADMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroSideAttackRight1\": \"5BgYAAAAAPD/AAAAAAAAAADw///vDwAAAAAAAAD//v7u/gAAAAAAAADv/vJE/v8PAAAAAPDu/vLU7iL0AAAAAPDu7/JO5CL0DwAAAPDu7/8bTSL0DwAAAPD+Lu//TSL0DwAAAPAvLu/U7eT1AAAAAPAiLu/UTiT1AAAAAAAvLv7u3f4PAAAAAADw7/LM3A4AAAAAAAAA8M/d7AAAAAAAAAAAANzNDAAAAAAAAAAAwN0MAAAAAAAAAAAA3M0AAAAAAAAAAAAAzAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"heroWalkFront1\": \"5BAQAAAAAAAAAAAAAAAA8A8AAAAA8P///uBEAAD/7+/uT00A8P8u/+T+/wDw7/K/0S5C///i8v7fJEL/L+LyTt0kUg8v4vJO3SRSD//i8v7fJEL/8O/yv9EuQv/w/y7/5P7/AAD/7u/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkFront2\": \"5BAQAAAAAAAAAAAAAAAA/wAAAAAAAP////AOAADw//7u7wQAAP/v8k/+//8A/y7/GyRC//AvLu//LUL/8CIu79QtUg/wIi7v1C1SD/AvLu//7f4PAP8u/xvU7Q8A/+/yT97tAADw7/7uTw4AAAD////uAAAAAAD/AAAAAAAAAAAAAAAA\",\r\n  \"heroWalkFront3\": \"5BAQAAAAAAAAAAAAAAAA8A8AAAAA8P///uBEAAD/7+/uT00A8P8u/+T+/wDw7/K/0S5C///i8v7fJEL/L+LyTt0kUg8v4vJO3SRSD//i8v7fJEL/8O/yv9EuQv/w/y7/5P7/AAD/7u/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkFront4\": \"5BAQAAAAAAAAAAAAAAAA/wAAAAAAAP///+4AAADw7/7uTw4AAP/v8k/e7QAA/y7/G9TtD/AvLu//7f4P8CIu79QtUg/wIi7v1C1SD/AvLu//LUL/AP8u/xskQv8A/+/yT/7//wDw//7u7wQAAAD////wDgAAAAD/AAAAAAAAAAAAAAAA\",\r\n  \"heroWalkBack1\": \"5BAQAAAAAAAAAAAAAAAA8A8AAAAA8P///uBEAAD/7+/uT00A8P4u/+/+/wDw/vIi7/5C/+/+LvLu/kL/7y/y7u7+Qg/vL/Lu7v5CD+/+LvLu/kL/8P7yIu/+Qv/w/i7/7v7/AAD/7+/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkBack2\": \"5BAQAAAAAAAAAAAAAAAAAPAPAAAAAPD//w8AAADw//7u/k4OAO/v8vLu//8A7y8v/+4v//Du7/Lv7i//8P4i7+7uLw/w/iLv7u4vD/Du7y/y7i8PAO8vIu/u7w4A7+//7u7fDgDw//7u/tQEAADw//8PTgAAAAAA8A8AAAAAAAAAAAAA\",\r\n  \"heroWalkBack3\": \"5BAQAAAAAAAAAAAAAAAA8A8AAAAA8P///uBEAAD/7+/uT00A8P4u/+/+/wDw/vIi7/5C/+/+LvLu/kL/7y/y7u7+Qg/vL/Lu7v5CD+/+LvLu/kL/8P7yIu/+Qv/w/i7/7v7/AAD/7+/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkBack4\": \"5BAQAAAAAAAAAAAAAAAAAPAPAAAAAPD//w9OAADw//7u/tQEAO/v/+7u3w4A7y8i7+7vDvDu7y/y7i8P8P4i7+7uLw/w/iLv7u4vD/Du7/Lv7i//AO8vL//uL/8A7+/y8u7//wDw//7u/k4OAADw//8PAAAAAAAA8A8AAAAAAAAAAAAA\",\r\n  \"heroWalkShieldFront1\": \"5BAQAAAAAAAAAAAAAAAA8A//DwAA8P///r37AAD/7+/+vcsP8P8u//S9yw/w7/K/8b37///i8v7f/0//L+LyTt0kUg8v4vJO3SRSD//i8v7fJEL/8O/yv9EuQv/w/y7/5P7/AAD/7u/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldFront2\": \"5BAQAAAAAAAA//8AAAAA//C9yw8AAP//////DwDw//7u7wQAAP/v8k/+//8A/y7/GyRC//AvLu//LUL/8CIu79QtUg/wIi7v1C1SD/AvLu//7f4PAP8u/xvU7Q8A/+/yT97tAADw7/7uTw4AAAD////uAAAAAAD/AAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldFront3\": \"5BAQAAAAAAAAAAAAAAAA/wAAAAAAAP////7/AADw7/7u37sPAP/v8k/fu/wA/y7/G9+7/PAvLu//37sP8CIu79T9/w/wIi7v1C1SD/AvLu//LUL/AP8u/xskQv8A/+/yT/7//wDw//7u7wQAAAD////wDgAAAAD/AAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldFront4\": \"5BAQAAAAAAAAAAAAAAAA/wAAAAAAAP///+4AAADw7/7uTw4AAP/v8k/e7QAA/y7/G9TtD/AvLu//7f4P8CIu79QtUg/wIi7v1C1SD/AvLu//LUL/AP8u/xskQv8A/+/yT/7//wDw//7u7wQAAAD//////w8AAAD/8L3LDwAAAAAA//8A\",\r\n  \"heroWalkShieldBack1\": \"5BAQAAAAAAAAAAAAAAAA8A8AAAAA8P///uBEAAD/7+/uT00A8P4u/+/+/wDw/vIi7/5C/+/+LvLu/kL/7y/y7u7+Qg/vL/Lu7v5CD+/+LvLu/kL/8P7yIu/+Qv/w/i7/7v7/AAD/7+/uT00AAPD///7gRAAAAADwDwAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldBack2\": \"5BAQAAAAAADwDwAAAADw//8PAAAA8P/+7v5ODgDv7/Ly7v//AO8vL//uL//w7u/y7+4v//D+Iu/u7i8P8P4i7+7uLw/w7u8v8u4vDwDvLyLv7u8OAO/v/+7u3w4A8P/+7v7UBAAA8P////8PAAAAAPC9yw8AAAAAAP//AAAAAAAAAAAA\",\r\n  \"heroWalkShieldBack3\": \"5BAQAAAAAPAPAAAAAPD///7gRAAA/+/v7k9NAPD+Lv/v/v8A8P7yIu/+Qv/v/i7y7v5C/+8v8u7u/kIP7y/y7u7+Qg/v/i7y7v5C//D+8iLv/kL/8P4u/+7+/wAA/+/v7k9NAADw///+4EQAAAAA8A8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldBack4\": \"5BAQAAAAAAAAAAAAAADw/////w8A8P/+7v7UBADv7//u7t8OAO8vIu/u7w7w7u8v8u4vD/D+Iu/u7i8P8P4i7+7uLw/w7u/y7+4v/wDvLy//7i//AO/v8vLu//8A8P/+7v5ODgAA8P//DwAAAAAAAPAPAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideLeft1\": \"5BAQAAAAAAAAAAAAAADw/w8AAAAA8O/y/gDwDwAvLv7u////8CIu79TtUv/wLy7v1E1S//D+Lu//7f4P8O7v/xve7Q/w7u/yTt7tD/Du/vLUTv7/AO/+8kT+//8A//7+7g7wDwDw///vDwAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideLeft2\": \"5BAQAAAAAAAAAAAAAAAAAPD/AAAAAP//37sPAAD/Lu/fu/sA8OLi7/7v/gAv4vJO3d7tD//i8k7d3u0P7+/y/t9O/v/v/v6/0SRC/+/+Lu9ELkL/7+4vT+0uQg/w7i9P5P/+APDv7+/uDwAAAP////4AAAAAAAD/DwAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideLeft3\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAPD/DwAAAADw7/L+APAPAC8u/u7////wIi7v1O1S//AvLu/UTVL/8P4u7//t/g/w7u//G97tD/Du7/JO3u0P8O7+8tRO/v8A7/7yRP7//wD//v7uDvAPAPD//+8PAAAAAADw/wAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideLeft4\": \"5BAQAAAAAAAAAAAAAAAAAAD/DwAAAPD//737AADw7/L+vbsPAC8u/u7/7v/wIi7v1O3d/vAvLu/U7d3+8P4u7//t5A/w7u//G01CD/Du7/JO5EIP8O7+8tTuQv8A7/7yRP7//wD//v7uDvAPAPD//+8PAAAAAADw/wAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideRight4\": \"5BAQAAAAAAAAAAAAAAAA8P8AAAAA8P//7w8AAAD//v7uDvAPAO/+8kT+///w7v7y1O5C//Du7/JO5EIP8O7v/xtNQg/w/i7v/+3kD/AvLu/U7d3+8CIu79Tt3f4ALy7+7v/u/wDw7/L+vbsPAADw//+9+wAAAAAAAP8PAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideRight3\": \"5BAQAAAAAAAAAAAAAAAA8P8AAAAA8P//7w8AAAD//v7uDvAPAO/+8kT+///w7v7y1E7+//Du7/JO3u0P8O7v/xve7Q/w/i7v/+3+D/AvLu/UTVL/8CIu79TtUv8ALy7+7v///wDw7/L+APAPAADw/w8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideRight2\": \"5BAQAAAAAAAAAAAAAAAA/w8AAAAA/////gAAAPDv7+/uDwAA8O4vT+T//gDv7i9P7S5CD+/+Lu9ELkL/7/7+v9EkQv/v7/L+307+///i8k7d3u0PL+LyTt3e7Q/w4uLv/u/+AAD/Lu/fu/sAAAD//9+7DwAAAAAA8P8AAAAAAAAAAAAA\",\r\n  \"heroWalkShieldSideRight1\": \"5BAQAAAAAAAAAAAAAAAA8P8AAAAA8P//7w8AAAD//v7uDvAPAO/+8kT+///w7v7y1E7+//Du7/JO3u0P8O7v/xve7Q/w/i7v/+3+D/AvLu/UTVL/8CIu79TtUv8ALy7+7v///wDw7/L+APAPAADw/w8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideLeft1\": \"5BAQAAAAAAAAAAAAAAD//wAAAAAA/y7vDwAAAPDi4u/+//8AL+LyTt0uUg//4vJO3SRSD+/v8v7fJEL/7/7+v9Hk/v/v/i7vRN7t/+/uL0/t3u0P8O4vT+RP/gDw7+/v7g8AAAD////+AAAAAAAA/w8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideLeft2\": \"5BAQAAAAAAAAAAAAAADw/w8AAAAA8O/y/gDwDwAvLv7u////8CIu79TtUv/wLy7v1E1S//D+Lu//7f4P8O7v/xve7Q/w7u/yTt7tD/Du/vLUTv7/AO/+8kT+//8A//7+7g7wDwDw///vDwAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideLeft3\": \"5BAQAAAAAAAAAAAAAAD//wAAAAAA/y7vDwAAAPDi4u/+//8AL+LyTt0uUg//4vJO3SRSD+/v8v7fJEL/7/7+v9Hk/v/v/i7vRN7t/+/uL0/t3u0P8O4vT+RP/gDw7+/v7g8AAAD////+AAAAAAAA/w8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideLeft4\": \"5BAQAAAAAAAAAAAAAADw/w8AAAAA8O/y/gDwDwAvLv7u////8CIu79TtUv/wLy7v1E1S//D+Lu//TUIP8O7v/xtNQg/w7u/yTuT+D/Du/vLU3u3/AO/+8kTe7f8A//7+7k7+DwDw///vDwAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideRight4\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAADw///vDwAAAP/+/u5O/g8A7/7yRN7t//Du/vLU3u3/8O7v8k7k/g/w7u//G01CD/D+Lu//TUIP8C8u79RNUv/wIi7v1O1S/wAvLv7u////APDv8v4A8A8AAPD/DwAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideRight3\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAD/DwAAAAD////+AAAA8O/v7+4PAADw7i9P5E/+AO/uL0/t3u0P7/4u70Te7f/v/v6/0eT+/+/v8v7fJEL//+LyTt0kUg8v4vJO3S5SD/Di4u/+//8AAP8u7w8AAAAAAP//AAAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideRight2\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAADw///vDwAAAP/+/u4O8A8A7/7yRP7///Du/vLUTv7/8O7v8k7e7Q/w7u//G97tD/D+Lu//7f4P8C8u79RNUv/wIi7v1O1S/wAvLv7u////APDv8v4A8A8AAPD/DwAAAAAAAAAAAAAA\",\r\n  \"heroWalkSideRight1\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAD/DwAAAAD////+AAAA8O/v7+4PAADw7i9P5E/+AO/uL0/t3u0P7/4u70Te7f/v/v6/0eT+/+/v8v7fJEL//+LyTt0kUg8v4vJO3S5SD/Di4u/+//8AAP8u7w8AAAAAAP//AAAAAAAAAAAAAAAA\",\r\n  \"houseRed\": \"5DAwAAAAAEBGREZERkRGREZEbGZmZmbGzAAAAAAAAMBsxmzGbMZsxmzGTGZmZmZmxgwAAAAAAMBmxmbGZsZmxmbGTGxmZmZmZsYAAAAAACIuIuIiIi4i4iLCTMvm7u7ubmYMAAAAACIuIuIiIi4i4iJiTMQk3t3dbURkAAAAIO7u7u7u7u7u7u5sTMQk3s/9bOROBgAAIC4i4iIiLiLiIiJsTMQk3s/9bOROZAAAIC4i4iIiLiLiIiJmTMQk3t3dbeROzgAA7u7u7u7u7u7u7s7GRsQk3s/9bEREzgAALiLiIiIuIuIiIs7GRsQk3s/9bOROzgAALiLiIiIuIuIiIm7GRsQk3t3dbeROZADg7u7u7u7u7u7u7mxsRsTk7u7ubuROZAAgIuIiIi4i4iIi4mxMRsREREREREREZAAgIuIiIi4i4iIi4mZMZszMzMzMzMzMzADi7u7u7u7u7u7uzmZGxtsRYWZmZmZmZgAi4iIiLiIiLiIizsa0TBRhZmZmZmZmZgAi4iIiLiIiLiIibsbES2Hm/v/v7v7/7yDu7u7u7u7u7u7ubGbERGFORERERERERCDiIiLiIiLiIiLibExkRGHu7u7u7u7u7iDiIiLiIiLiIiLiZkxkRGFORP9ORERERO7u7u7u7u7u7u7OZkZkRGFO5P9OREREROIiIi4i4iIiLiLOxkRkRGHu/v/u7u7u7u7u7u7u7u7u7u5uxkRkRGFO9P9ORERERCIiIiIiIiIiIiJixkRkRGFO9P9ORERERCIiIiIiIiIiIiJixkRkRGHu/v/u7u7u7u7u7u7u7u7u7u5uxkRkRGFO9P9ORERERCIuIi4i4iIiLiLOxkRkRGFO9P9ORERERO7u7u7u7u7u7u7OZkZkRGHu7v/u/v/u7iDiIiLiIiLiIiLiZkxkRGFORP9O5E9PRCDiIiLiIiLiIiLibExkRGFORORO5E9PRCDu7u7u7u7u7u7ubGbERGHu7u7u7v/u7gAi4iIiLiIiLiIibsbES2Hm7u7u7u7u7gAi4iIiLiIiLiIizsa0TBRhZmZmZmZmZgDi7u7u7u7u7u7uzmZGxtsRYWZmZmZmZgAgIuIiIi4i4iIi4mZMZszMzMzMzMzMzAAgIuIiIi4i4iIi4mxMRsREREREREREZADg7u7u7u7u7u7u7mxsRsTk7u7ubuROZAAALiLiIiIuIuIiIm7GRsQk3t3dbeROZAAALiLiIiIuIuIiIs7GRsQk3s/9bOROzgAA7u7u7u7u7u7u7s7GRsQk3s/9bEREzgAAIC4i4iIiLiLiIiJmTMQk3t3dbeROzgAAIC4i4iIiLiLiIiJsTMQk3s/9bOROZAAAIO7u7u7u7u7u7u5sTMQk3s/9bOROBgAAACIuIuIiIi4i4iJiTMQk3t3dbURkAAAAACIuIuIiIi4i4iLCTMvm7u7ubmYMAAAAAMBmxmbGZsZmxmbGTGxmZmZmZsYAAAAAAMBsxmzGbMZsxmzGTGZmZmZmxgwAAAAAAEBGREZERkRGREZEbGZmZmbGzAAAAA==\",\r\n  \"houseBlue\": \"5DAwAAAAANDb3dvd293b3dvdvLu7u7vLzAAAAAAAAMC8y7zLvMu8y7zL3Lu7u7u7ywwAAAAAAMC7y7vLu8u7y7vL3Ly7u7u7u8sAAAAAAKqoqoqqqqiqiqrK3MuLiIiIuLsMAAAAAKqoqoqqqqiqiqq63M2tODMzs929AAAAoIiIiIiIiIiIiIi83M2tOM/zvL3bCwAAoKiqiqqqqKqKqqq83M2tOM/zvL3bvQAAoKiqiqqqqKqKqqq73M2tODMzs73bywAAiIiIiIiIiIiIiMjL282tOM/zvN3dywAAqKqKqqqoqoqqqsjL282tOM/zvL3bywAAqKqKqqqoqoqqqrjL282tODMzs73bvQCAiIiIiIiIiIiIiLy8282NiIiIuL3bvQCgqoqqqqiqiqqqirzc283d3d3d3d3dvQCgqoqqqqiqiqqqirvcu8zMzMzMzMzMzACKiIiIiIiIiIiIyLvby9sRsbu7u7u7uwCqiqqqqKqqqKqqyMu93B2xu7u7u7u7uwCqiqqqqKqqqKqquMvN27Hr/v/v7v7/76CIiIiIiIiIiIiIvLvN3bE+MzMzMzMzM6CKqqqKqqqKqqqKvNy93bG+u+u+u7u7u6CKqqqKqqqKqqqKu9y93bE+M/8+MzMzM4iIiIiIiIiIiIjIu9u93bE+4/8+MzMzM4qqqqiqiqqqqKrIy9293bG++/++u7u7u4iIiIiIiIiIiIi4y9293bE+8/8+MzMzM6qqqqqqqqqqqqq6y9293bE+8/8+MzMzM6qqqqqqqqqqqqq6y9293bG++/++u7u7u4iIiIiIiIiIiIi4y9293bE+8/8+MzMzM6qoqqiqiqqqqKrIy9293bE+8/8+MzMzM4iIiIiIiIiIiIjIu9u93bG+6/+++/+7u6CKqqqKqqqKqqqKu9y93bE+M/8+4z8/M6CKqqqKqqqKqqqKvNy93bE+M+M+4z8/M6CIiIiIiIiIiIiIvLvN3bG+u7u76/++uwCqiqqqqKqqqKqquMvN27Hr7u7u7u7u7gCqiqqqqKqqqKqqyMu93B2xu7u7u7u7uwCKiIiIiIiIiIiIyLvby9sRsbu7u7u7uwCgqoqqqqiqiqqqirvcu8zMzMzMzMzMzACgqoqqqqiqiqqqirzc283d3d3d3d3dvQCAiIiIiIiIiIiIiLy8282NiIiIuL3bvQAAqKqKqqqoqoqqqrjL282tODMzs73bvQAAqKqKqqqoqoqqqsjL282tOM/zvL3bywAAiIiIiIiIiIiIiMjL282tOM/zvN3dywAAoKiqiqqqqKqKqqq73M2tODMzs73bywAAoKiqiqqqqKqKqqq83M2tOM/zvL3bvQAAoIiIiIiIiIiIiIi83M2tOM/zvL3bCwAAAKqoqoqqqqiqiqq63M2tODMzs929AAAAAKqoqoqqqqiqiqrK3MuLiIiIuLsMAAAAAMC7y7vLu8u7y7vL3Ly7u7u7u8sAAAAAAMC8y7zLvMu8y7zL3Lu7u7u7ywwAAAAAANDb3dvd293b3dvdvLu7u7vLzAAAAA==\",\r\n  \"princessFront0\": \"5BAQAAAAAAAAAAAAAAAAAPAAAAAAAAD/b/8AAADw/2Zm3/8PAB9m//bdPw/wYfbdP/Mz/1Vl/z/9NVP/UGLf3f1TMw9VZd/d/VMzD/Bh/z/9NVP/8Bb23T/zM/8Ab2H/9t0/DwDw/2Zm3/8PAAAA/2//AAAAAAAA8AAAAAAAAAAAAAAA\",\r\n  \"princessFront1\": \"5BAQAAAAAAAAAAAAAAAAAPAAAAAAAAD/bw8AAADw/2Zm//8AAB9m//bT/Q/wYfbdP/M/D1Vl/z/9NVMPUGLf3f1TMw9VZd/d/VMzD/Bh/z/9NVP/8Bb23T/zM/8Ab2H/9v0/DwDw/2Zm3/8PAAAA/2//AAAAAAAA8AAAAAAAAAAAAAAA\",\r\n  \"princessFront2\": \"5BAQAAAAAAAAAAAAAAAAAPAAAAAAAAD/b/8AAADw/2Zm3/8PAB9m//b9Pw/wYfbdP/Mz/1Vl/z/9NVP/UGLf3f1TMw9VZd/d/VMzD/Bh/z/9NVMP8Bb23T/zPw8Ab2H/9tP9DwDw/2Zm//8AAAAA/28PAAAAAAAA8AAAAAAAAAAAAAAA\",\r\n  \"princessLeft0\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw//8AAAAAAG/W3Q//8A/wZvY//TU/D1Vi1t39M1PzUGVm1l3zP/NVFWZmP9/9//BmYWb//98PAG8WZmYP8AAA8P//bw8AAAAAAG9vDwAAAAAA8PAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"princessLeft1\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//w8AAAAA8Gbd/fAP/wBvZv/T3/3/UCVm3d3f/f8AVWZm3dP981BVYWb209/zAG8WZvb/U/8A8GZhZv8//wAA////9vAAAAAA8Pb2AAAAAAAADw8AAAAAAAAAAAAA\",\r\n  \"princessLeft2\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//w8AAAAA8Gbd/fAPDwBvZv/TX/PzUCVm3d0/M/MAVWZm3TNT81BVYWb20//zAG8WZvbf/f8A8GZhZv/9AAAA////9g8AAAAA8Pb2AAAAAAAADw8AAAAAAAAAAAAA\",\r\n  \"princessBack0\": \"5BAQAAAAAAAAAAAAAAAAAA8AAAAAAADw9vAAAADw///23w8AAG9mZvbd/w/wFmZmP/U/81AWZmb2MzXzVRZmZvYzU/NVZmZm9jNT81AWZmb2MzXz8GZmZj/1P/MAb2Zm9t3/DwDw///23w8AAAAA8PbwAAAAAAAADwAAAAAAAAAAAAAA\",\r\n  \"princessBack1\": \"5BAQAAAAAAAAAAAAAAAAAPAAAAAAAAAAbw8AAAAA//9v/wAAAPBmZmbf/w8Ab2Fm9vMzDwBlYWZmPzXzUGVhZmY/U/NQZWZmZj9TDwBlYWZmPz8PAG9mZvbV/QAA8GZmZt/9AAAA//9v/w8AAAAAAG8PAAAAAAAA8AAAAAAAAAAAAAAA\",\r\n  \"princessBack2\": \"5BAQAAAAAAAAAAAAAAAAAPAAAAAAAAAAbw8AAAAA//9v/w8AAPBmZmbf/QAAb2Fm9tX9AABlYWZmPz8PUGVhZmY/Uw9QZWZmZj9T8wBlYWZmPzXzAG9mZvbzMw8A8GZmZt//DwAA//9v/wAAAAAAAG8PAAAAAAAA8AAAAAAAAAAAAAAA\",\r\n  \"princess2Front\": \"5BAQAAAAAADwDwAAAADw///7AAAA8D+zu+vuAAC/M7O77/QP8D7j//7/vA9f5LO/Qb/d8U9FM/5P3r39VEXj7kTe3bFURePuRN69vU9FM/5P3t3xX+Szv0G/vf3wPuP//v+8DwC/M7O77/QPAPA/s7vr7gAAAPD///sAAAAAAADwDwAA\",\r\n  \"princess2WalkFront1\": \"5BAQAAAAAAD/AAAAAADw/78PAAAAAO+zu/sPAADwOzO7S/4PAO8z/u9O5A/wRT77G07k8fBUNOP/5N79T1U07k7U3fFPVTTuTtS9vfBUNOP/1N2x8EU++xu0vfEA7zP+7/+8DwDwOzO76/QPAADvs7v77gAAAPD/vw8AAAAAAAD/AAAA\",\r\n  \"princess2WalkFront2\": \"5BAQAAAAAADwDwAAAADw///7AAAA8D+zu+vuAAC/M7O77/QP8D7j//7/vA9f5LO/Qb/d8U9FM/5P3r39VEXj7kTe3bFURePuRN69vU9FM/5P3t3xX+Szv0G/vf3wPuP//v+8DwC/M7O77/QPAPA/s7vr7gAAAPD///sAAAAAAADwDwAA\",\r\n  \"princess2WalkFront3\": \"5BAQAAAAAAD/AAAAAADw/78PAAAAAO+zu/vuAADwOzO76/QPAO8z/u//vA/wRT77G7S98fBUNOP/1N2xT1U07k7Uvb1PVTTuTtTd8fBUNOP/5N798EU++xtO5PEA7zP+707kDwDwOzO7S/4PAADvs7v7DwAAAPD/vw8AAAAAAAD/AAAA\",\r\n  \"princess2Back\": \"5BAQAAAAAADwDwAAAADw/8/7AAAA8D+7u8vuAAC/M7O7y/QP8D4zM7u7vA9fMzMzu7vf8U8zMzO7u7/9VDMzM7u737FUMzMzu7u/vU8zMzO7u9/xXzMzM7u7v/3wPjMzu7u8DwC/M7O7y/QPAPA/u7vL7gAAAPD/z/sAAAAAAADwDwAA\",\r\n  \"princess2WalkBack1\": \"5BAQAAAAAADw/wAAAAAA/8/7DwAAAP+7u7sMAADwO7O7u/wPAO8zM7u7vA/wNTMzu7u/8fA0MzO7u9+xQDUzM7u7v71ANTMzu7vf8fA0MzO7u9/98DUzM7u77/4A7zMzu7tPDgDwO7O7y04PAAD/u7v87AAAAAD//w8AAAAAAAAAAAAA\",\r\n  \"princess2WalkBack2\": \"5BAQAAAAAADwDwAAAADw/8/7AAAA8D+7u8vuAAC/M7O7y/QP8D4zM7u7vA9fMzMzu7vf8U8zMzO7u7/9VDMzM7u737FUMzMzu7u/vU8zMzO7u9/xXzMzM7u7v/3wPjMzu7u8DwC/M7O7y/QPAPA/u7vL7gAAAPD/z/sAAAAAAADwDwAA\",\r\n  \"princess2WalkBack3\": \"5BAQAAAAAAAAAAAAAAAA//8PAAAAAP+7u/zsAADwO7O7y04PAO8zM7u7Tw7wNTMzu7vv/vA0MzO7u9/9QDUzM7u73/FANTMzu7u/vfA0MzO7u9+x8DUzM7u7v/EA7zMzu7u8DwDwO7O7u/wPAAD/u7u7DAAAAAD/z/sPAAAAAADw/wAA\",\r\n  \"princess2Left1\": \"5BAQAAAAAAAAAAAAAADw/wAAAADw/z8zDwDwD0/lM+P+/78PVEXj7kTe3fFURePuRN69/U9FM/5P3t2xX+Szv0Hvvr3/PuP//k/k8b8zM7O7T+T98DMzs7v7vg/wOzOzu7v/DwC/M7O7uw8AAPD////7AAAAAAAA8A8AAAAAAAAAAAAA\",\r\n  \"princess2Left2\": \"5BAQAAAAAAAAAAAAAADw/wAAAAAA/z8zDwDwD/BUPjPu/9/7QFU07k7U3f1AVTTuTtTd8fBUNOP/1L298EU++xvkvrHw7zP+70/k/fA7MzO7S+T9AD8zM7u7v/sAvzMzu7u/DwDwOzO7u/8AAAD//7/7AAAAAAAA/w8AAAAAAAAAAAAA\",\r\n  \"princess2Right1\": \"5BAQAAAAAAAAAAAAAAAAAPAPAAAA8P////sAAAC/M7O7uw8A8Dszs7u7/w/wMzOzu/u+D78zM7O7T+T9/z7j//5P5PFf5LO/Qe++vU9FM/5P3t2xVEXj7kTevf1URePuRN7d8U/lM+P+/78P8P8/Mw8A8A8AAPD/AAAAAAAAAAAAAAAA\",\r\n  \"princess2Right2\": \"5BAQAAAAAAAAAAAAAAAAAP8PAAAAAP//v/sAAADwOzO7u/8AAL8zM7u7vw8APzMzu7u/+/A7MzO7S+T98O8z/u9P5P3wRT77G+S+sfBUNOP/1L29QFU07k7U3fFAVTTuTtTd/fBUPjPu/9/7AP8/Mw8A8A8AAPD/AAAAAAAAAAAAAAAA\",\r\n  \"rock0\": \"5BAQAAAAAADMzAAAAAAAzMvLDAAAAADcu7zMAAAAzNy9vMwAwMy7vN3MzAC83bvL3cvMANzd3bvby8wM293du9vLvAzb3d2727u8y9vd3b3b27zLsN3dvdvbvMsA2929vdu8ywDb3bu9vbsMALC7u7vNuwwAAADb3czLAAAAALDLvAsA\",\r\n  \"rock1\": \"5BAQAAAAAAAAwMwAAAAAAMu8zAwAAACw28vLDAAAALvdzcsMALDLzN3Ny8wAsN3M3c3Ny7Db3cvbu83LsN3du9vby8uw3d3bu93My9vd3dvbu7zL2929vbu8u8vbvbvNy7y7y9u928vMvLsMsNu9zMy7ywwAAMvMvMvMAAAAAADMzAwA\",\r\n  \"rock2\": \"5BAQAAAAAMAMsAsAwAsAu8zbuwC7DLDdy9vNAN0MsN3LsM0A2wuw3buwywCwAMvbuwC8AACw3cwMAAC7ALDdywwAsL0Ay7vLvAvbvbDMvMzADNvNu73MALvM28vb3cuwvcu7zNu9y7Ddy7u8273LsN27ywuwuwwAuwu7AAAAAACwAAAA\",\r\n  \"saplingOak\": \"5BAQAAAAAMwMAAAAAADMxswMAAAAwGZmzMwAAADAZmdsxgAAAGx2Z2b2DAAAbHd2Z/xPAMBmd2dnZvwOwGdXd8Zm/O7Ad3dnZ8z87sBVZ2Zn9s8AYFV3Z2f8DOAAdnVnZsbvBADGdlZnxg8AAMBsdsb8AAAAAMxmxgwAAAAAwMzMAAAA\",\r\n  \"saplingPine\": \"5BAQAAAAAMwAAAAAAABgx8wMAAAAAGzHfAwAAABgbGd3DAAAwMzHZmbMAA7AxmdsZnfmDsB8d8d2x+8AbFV3bGb27u5cVXdmZv/u7sB8dWd3x+4AYMdnZnd37A5gZsd3Z8wADgBgzHd3DAAAAABmZ3wMAAAAAGBnxgwAAAAAAGYAAAAA\",\r\n  \"shrub\": \"5BAQAAAAZmBmDAAAAABmzHbGbAAAYHZsd8xmBgBgdWx3XHdmAMx1ZmdWdWbAxlVmbHdlxmZndmfMZmYMdlVnxsx8V2Z2V3XGzHxXZ2ZnVmXMZmZmwMZVZ2x3ZQwAzHVmZ1Z1xgBgd2x3XHdmAGB2bHfMZgYAAHbGdsZsAAAAZmBmDAAA\",\r\n  \"skellyFront\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAAAADAsQAAAAAAAAD//w8f+wAAAAAAAP/dvfwfsQAAAAAA8BsR3b0f+wAAAAAA8BERvRzM8Q8AAAAAHxER8R+9/w8AAAAAHxER0RH7//8AAAAAHxER0RGx//8AAAAAHxER8R/7//8AAAAA8BERvRzNsQ8AAAAA8BsR3b0f+wAAAAAAAP/dvfwfsQAAAAAAAAD//w8f+wAAAAAAAAAAAADPsQAAAAAAAAAAAADw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkFront1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAAAADAsQAAAAAAAAD//w8f+wAAAAAAAP/dvfwfsQAAAAAA8BsR3b0f+wAAAAAA8BERvRzM8Q8AAAAAHxER8R+9//8AAAAAHxER0RH7//8AAAAAHxER0RGx//8AAAAAHxER8R/7/w8AAAAA8BERvRwc+wAAAAAA8BsR3f2xDwAAAAAAAP/dvfwRCwAAAAAAAAD///+xDwAAAAAAAAAAAPAcCwAAAAAAAAAAAAD/DwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkFront2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAAAADAsQAAAAAAAAD//w8f+wAAAAAAAP/dvfwfsQAAAAAA8BsR3b0f+wAAAAAA8BERvRzM8Q8AAAAAHxER8R+9/w8AAAAAHxER0RH7//8AAAAAHxER0RGx//8AAAAAHxER8R/7//8AAAAA8BERvRzNsQ8AAAAA8BsR3b0f+wAAAAAAAP/dvfwfsQAAAAAAAAD//w8f+wAAAAAAAAAAAADPsQAAAAAAAAAAAADw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkFront3\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/DwAAAAAAAAAAAPAcCwAAAAAAAAD///+xDwAAAAAAAP/dvfwRCwAAAAAA8BsR3f2xDwAAAAAA8BERvRzM+wAAAAAAHxER8R+9/w8AAAAAHxER0RH7//8AAAAAHxER0RGx//8AAAAAHxER8R/7//8AAAAA8BERvRzN8Q8AAAAA8BsR3b0f+wAAAAAAAP/dvfwfsQAAAAAAAAD//w8f+wAAAAAAAAAAAADAsQAAAAAAAAAAAADw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackFront1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAAAADAsQAAAAAAAAAAAAAf+wAAAAAAAAAAAAAfsQ8AAAAAAAAAAPAf+8wPAAAAAAAAAL/M8c//DwAAAAAAAB/Ry7H//w8AAAAA8BER8dH7//8AAAAA8BEREbH///8PAAAA8BERERH7//8PAAAA8BER8bH///8PAAAAAB8RzRH9z7EPAAAAAL8R3fv/H/sAAAAAAPAf3csPH7EAAAAAAADw//8AH/sAAAAAAAAAAAAAz7EAAAAAAAAAAAAA8P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackFront2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHd3AAAAAAAAAAAABwB39/8AAAAAAAAAAABwx9EPAAAAAADw////v/wAAAAAAPDf3d3LH9EPAAAAAL8REdHdv/wAAAAAAB8REdHLy9EPAAAA8BERERH//f8AAAAA8BEREREd+/8AAAAA8BEREREd8f8AAAAA8BERERH/+/8AAAAAAB8REdHL/f8AAAAAAL8REdHd/w8AAAAAAPDf3d3LDwAAAAAAAADw////DAAAAAAAAAAAAPC8DwAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackFront3\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAD//wAAzw8AAAAAAP/dzf8Avw8AAAAA8BsR0fv/HwsAAAAA8BER0bz8vw8AAAAAHxEREd/7zw8AAAAAHxEREbH//wAAAAAAHxERERH7/wAAAAAAHxEREb///wAAAAAA8BER0dz9/wAAAAAA8BsR0fv/DwAAAAAAAP/Rzf8AAAAAAAAAAAD///sAAAAAAAAAAAAA8PsAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackFront4\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAD//wAAHA8AAAAAAP/dy//wuw8AAAAA8BvR3fv/EQsAAAAA8BERvbz8uw8AAAAAHxER8R/9HA8AAAAAHxER0RH7/wAAAAAAHxER0RHx/wAAAAAAHxER8R/7/wAAAAAA8BERvbz9/wAAAAAA8BvR3cv/DwAAAAAAAP/dvf/7AAAAAAAAAAD//7/LAAAAAAAAAAAAAM/7AAAAAAAAAAAAAPAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkLeft1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//w8AAAAAAAAAAP/d3fv/AAAAAAAA8BsRER2xDwAAAAAA8BER0R37/wAAAAAAHxER8R/BsQ8AAAAAHxERvRwf+w8AAAAAHxER3R0fsf8AAAAAHxER3bsf+/8AAAAA8BHR3bu///8AAAAA8Nvd3cv///8AAAAAAP/dvfwAAP8AAAAAAAD//w8A8A8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackLeft1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8PAAAAAAAAAP/dG7EPAAAAAAAA8BsREfsPAAAAAAAA8BEREbH//wAAAAAAHxERH/v//w8AAAAAHxHRHM3///8AAAAAHxHRvf////8AAAAAHxER/8z///8AAAAAvxHBsc////8AAAAA8BEf+88P8P8AAAAA8Bsfsf8AAP8AAAAAAP8f+w8AAP8AAAAAAAC//wAA8A8AAAAAAADwDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackLeft2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/wAAAAAAAAAAAADP0Q8AAAAAAPD///+/+wAAAAAA8N/d3b0f0Q8AAAAAvxEREdG//QAAAAAAHxER0d28DAAAAADwERER0f+8DwAAAADwERHR3cv9/wAAAADwERHR3d3N/wAAAADwERHR3b37/w8AAAAAHxHd3bv//w8AAAAAv93d3cv//w8AAAAA8Nvdvf///w8AAAAAAP///w8A/w8AAAAAAAAAAAAA8A8AAAAAAAAAAAAA8AAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkLeft2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPD/AAAAAAAAAAD//7+xDwAAAAAAAP/dHRH7DwAAAAAA8BsRERGxD/8AAAAAHxERER/7D7EAAAAAHxER3Rz9D/sAAAAAHxER3b3//7EAAAAAHxER3d38//sAAAAAHxHR3d3///8AAAAA8BHd3d3///8AAAAA8Nvd3b3///8AAAAAAL/d3f3w//8AAAAAAPD//w8A8P8AAAAAAAAAAAAA/w8AAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkRight1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAA/w8AAAAAAPD//w8A8P8AAAAAAL/d3f3w//8AAAAA8Nvd3b3///8AAAAA8BHd3d3///8AAAAAHxHR3d3///8AAAAAHxER3d38//sAAAAAHxER3b3//7EAAAAAHxER3Rz9D/sAAAAAHxERER/7D7EAAAAA8BsRERGxD/8AAAAAAP/dHRH7DwAAAAAAAAD//7+xDwAAAAAAAAAAAPD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackRight1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAA8AAAAAAAAAAAAAAA8A8AAAAAAP///w8A/w8AAAAA8Nvdvf///w8AAAAAv93d3cv//w8AAAAAHxHd3bv//w8AAADwERHR3b37/w8AAADwERHR3d3N/wAAAADwERHR3cv9/wAAAADwERER0f+8DwAAAAAAHxER0d28DAAAAAAAvxEREdG//QAAAAAA8N/d3b0f0Q8AAAAAAPD///+/+wAAAAAAAAAAAADP0Q8AAAAAAAAAAADw/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyAttackRight2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwDwAAAAAAAAAAAAC//wAA8A8AAAAAAP8f+w8AAP8AAAAA8Bsfsf8AAP8AAAAA8BEf+88P8P8AAAAAvxHBsc////8AAAAAHxER/8z///8AAAAAHxHRvf////8AAAAAHxHRHM3///8AAAAAHxERH/v//w8AAAAA8BEREbH//wAAAAAA8BsREfsPAAAAAAAAAP/dG7EPAAAAAAAAAAD///8PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"skellyWalkRight2\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//w8A8A8AAAAAAP/dvfwAAP8AAAAA8Nvd3cv///8AAAAA8BHR3bu///8AAAAAHxER3bsf+/8AAAAAHxER3R0fsf8AAAAAHxERvRwf+w8AAAAAHxER8R/BsQ8AAAAA8BER0R37/wAAAAAA8BsRER2xDwAAAAAAAP/d3fv/AAAAAAAAAAD//w8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"tileGrass1\": \"5BAQAHV3d3d3d3d3d3d3d3d3d3d1d2d3V3d3V3d3VXZ3d3d3d3dXZXd3d3d3V3V3d3d3d3d3VXd3d3d3d3d3VXd3d3d3d1dld3d1d3d3V3Z3d1V3d3d3d3dXV3d3d3d3d1V2d3d3dXd3ZXd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3dV\",\r\n  \"tileGrass2\": \"5BAQAHV3d3d3d3d3d3fRdncXdnd1NxFjd3FxV3cRdtF3F3Z3dxF20Xd3d3d3NxFjd3d3d3d30XYXdnd3d3d3d3Fxd3d3d3d3F3Z3d3dXZXd3d3d3d3d3V3UXbXd3d3dVdhMxdndhd2cXYRd9Fxd3dxdhF313YXd3dxMxdnd3d3d3F213\",\r\n  \"tilePath1\": \"5BAQAHd3d3d3d3d3d2d2Z3bWdmZ3d2bdbd1t3XfW3d3d3d3dZ93d3d3d3dt31t3d3d3d3XfW3b3b3d3dZ9bdvdvd3d1n3d3d3d3d3Wfd3d3d3d3dd9bd3d0d0d1n3d3d0R3R3XfW3d3d3d3dd93b3d3d3d1n193d3dHd3XfW3d3d3d3b\",\r\n  \"tilePath2\": \"5BAQAGfd3d3d3d3dZ90d0d3d3d131h3R3b3d3WfX3d3d3d3dd9cd3d3d3d1n1t3d3d3d3Xdn3d293d3dZ93d3d3d3dFn3d3d3d3d3dfd3d3d3d3dZ9cd3d3d3d131t3d3b3b3Xfd3d3dvdvdZ9bd3d3d3d13Z93dHd3dHXfW3d3d3d3d\",\r\n  \"tilePath3\": \"5BAQANfd3dHd3d3dZ93d3d3d3d131t3d3d3d3WfW3d29293dZ93b3b3b3d133d3d3d3d23fW3d3d3d3dd9bd3d3d3d1n1t3R3d3d3dfd3d3b3d3dZ90R3d3d0d131hHd3d3d3Wfd3d3W3d3dd9Zt3WfdZt13Z3Zmd2ZnbXd3d3d3d3d3\",\r\n  \"tileDarkGrass1\": \"5BAQAGdmZmZmZmZmZmZmZmZmZmZnZoZmdmZmdmZmd2hmZmZmZmZ2h2ZmZmZmdmdmZmZmZmZmd2ZmZmZmZmZmd2ZmZmZmZnaHZmZnZmZmdmhmZndmZmZmZmZ2dmZmZmZmZndoZmZmZ2Zmh2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZ3\",\r\n  \"tileDarkGrass2\": \"5BAQAGdmZmZmZmZmZmbRaGYWaGZnNhGDZmFhdmYRaNFmFmhmZhFo0WZmZmZmNhGDZmZmZmZm0WgWaGZmZmZmZmFhZmZmZmZmFmhmZmZ2h2ZmZmZmZmZmdmcWjWZmZmZ3aBMxaGaBZoYWgRZtFhZmZhaBFm1mgWZmZhMxaGZmZmZmFo1m\",\r\n  \"tilePath4\": \"5BAQAHd3d3d3d3d3Z2d3Z3bWdnZmZ2bdbd1t1t3W1t3dvd3W3d3d3d3d3d3d3d3d3d3d3RHd3d3d3d3dEd293d3d3d3d3d3d3R3d293d3d3dEdHd3dHd3d0d3d3d3d3d3d3d3d3d3d273d3d3d3d3bvd3d3d3d3d3d3d3d3d3dHd3d0d\",\r\n  \"tilePath5\": \"5BAQAN3d3d3dHdHd3d3d3d0d0d3d3dvd3d3d3R3R3d3d3d3dHdHd3d3d3d3d3d3d293d3d3d3d3d3R3d3d3d3d3d3d3d3d3d3d3d3d3du93d3d3d3d273d3d3d3d3d3d3d3d3d3d3d3d3dvdvd3d3d3d3d3d3d3d3d3dvd3d3d3d3d3d\",\r\n  \"tilePath6\": \"5BAQAN3d3d3R3d3d3R3d3d3d3d3dEdHd3d3d0d0d3d3d3d3d3d3d3b3b3d3d3d3dvdvd3d3d3d3d3d3d3d3d3d3d3d3dvd3d3d3d3d3d3d3d3d3d3d3d3d3d293d3d3R3d3d3d3d3d1t3d3d3dbdZn3WbdZmZ21ndnZtZ3d3d3d3d3d3\",\r\n  \"tileGrass3\": \"5BAQAHd3d3d3d3d3d3Z3d3d3d3dXZXd3d3d3d3dVdnd3VXZ3VXd3d3d3d3dXdXd3d3d3d3dXdXd3d3d3d1V2d3d3d3d3ZXd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3V2V3d3d3d3d3d3d3V3d3d3d3d3d3d3d3d3d3d3d3\",\r\n  \"tileDarkGrass3\": \"5BAQAGZmZmZmZmZmZmhmZmZmZmZ2h2ZmZmZmZmZ3aGZmd2hmd2ZmZmZmZmZ2Z2ZmZmZmZmZ2Z2ZmZmZmZndoZmZmZmZmh2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmdodmZmZmZmZmZmZmdmZmZmZmZmZmZmZmZmZmZmZm\",\r\n  \"tilePath7\": \"5BAQAHd3d3d3d3d31nZmd2ZndnfdZt123dZtd93d3W3d3d123d3d3b3bbXfd3d3dvdvddt0d3d3d3d193d3d3d3dbXbd3d3d3d1td93d3d3d3W133RHd3d3d3XfdEd3d293ddt3d3d3d3W123d3d3d0RbXfd3d3d3RHddt3d3dvd3d19\",\r\n  \"tilePath8\": \"5BAQAN3d3d3d3W130d3d0d3ddnfd3d3d3d1tdt3d3d3d29133d3d3d3dbXfd3d273d19dt3b3bvd3d193d3d3d3d3Xbd3d3d3d3ddt3d3d3d3XZ33d3d3d3dbXbd3d3d3dF9d90R3d3d3X123RHd3d3dbXfd3d293d3ddt3d3d3d3d12\",\r\n  \"tilePath9\": \"5BAQAL3d3d3d3W133d3dHdHdfXbd3d0d0b3dd93d3d3d3W133d3d3d3d3Xbd0d3d3d1td93d3d3d3d123d3d3dHd3Xbd3d3d3d1tdt3du93d3W133d273d3dbXfd3d3d3R3ddt3d3d3d3W133dbd1t1md3dmZ21ndmd2d3d3d3d3d3d3\",\r\n  \"treePine\": \"5CAgAAAAAAAAAADADAAAAAAAAAAAAAAAAABgxsYMAAAAAAAAAAAAAAAAYGdmDAAAAAAAAAAAAAAAAGxndmZsAAAAAAAAAAAAAMDMZ3dmzAAAAAAAAAAAAMBsx2Z3dscAAAAAAAAAAAB8fGfGZ3bGBgAAAAAAAAAAdmZnx2ZnzAwAAAAAAAAAzHZmdsdmxmbMAAAAAAAAYMfMbHZsx2Z2zAAAAAAAAGzHfGxmdsdmd8cA8AAAAGBsZ3dsZnfGZmZsDPAAAMDMx2ZmzGZmZmZmdgzvAADAxmdsZndmdmdsZndn7w8AwHx3x3bHZnd3bGZ3x+7+D2xVd2xmbHd3xmZmxmzu7v5cVXdmZnZ3Z2xmZmdm7v4PwHx1Z3dnd3d3ZnZ3Z+4PAGDHZ2Z3d3Z3Z2Z3d2fvDwBgZsdVZ2x3d8Z2ZnYG4A4AAGDMV3d8d3fHdndsBvAAAAAAZmV8dnd2Z2Z3xwAAAAAAAGBnZnZ3ZmdmdscAAAAAAAAAZnd2dsdsd8ZmAAAAAAAAAAB2dmbHZnd3DAAAAAAAAAAAdnZndmdmdwwAAAAAAAAAAGBmfHd3bGcAAAAAAAAAAAAAYHZnd8xmAAAAAAAAAAAAAABmd3bGbAAAAAAAAAAAAAAAYGdsxgAAAAAAAAAAAAAAAGBmxsYAAAAAAAAAAAAAAAAAYAYAAAAAAAAA\",\r\n  \"treeOak\": \"5CAgAAAAAAAGwMzGDAAAAAAAAAAAAABgZsxsxmwMAAAAAAAAAAAAYGZ2Z8ZnDAAAAAAAAAAAAGZmd2Z2Z8wMAAAAAAAAAABmd2ZmZ8bGzAwAAAAAAABmdndmdmdmxmYMAAAAAABgd3ZnZ3Z2d3bHzAAAAAAAYHdmdmdmdmd3xswMAAAAAGBmd3dnd2ZmxmzMDAAAAABmdnd3dnd2Z2Z3xgAADgBgd3Z3d3d3d3d2Z8wMAA4AYHd2d3d3d3dnZsZmzAAOAGB3d3d1d3d3dndmZsbw/gBmV3VXdXd3ZndnZsbM7/4AZldVV3d3d2d3Zndmxu7/AHZ3VXd3d3d3ZmZ2Z8zu/g92d1dVVXd3d2dmZsbM7u7uYHdVd1V1d3dndndmzO7uDmBXVVd3d3dmZmZ3Z8bu/wAAdndXdXd3Z3dnxszM/g8AYHd3V3V3d3d2d2bMzOAOAGB3d3d1d2dmZmZmxgwA7gBgd3Z3d3dnd2ZnxswMAOAAYGZ3d3d3Z3dnd2bMAAAAAABgd3Z3dnd2Z3ZmzAwAAAAAYGd2d2d3ZmZmbMYMAAAAAABmZnZnZndnZsbMAAAAAAAAdnZnZ2Z2Z2zGDAAAAAAAAHZ2d2ZnZmbMxgwAAAAAAABgYGZmd8bGzAwAAAAAAAAAAABmYHbGzMwMAAAAAAAAAAAAYMBsxgwAAAAAAAAA\",\r\n  \"treeSmallPine\": \"5BAYAAAAAAAAAMDMAAAAAAAAAADAzGzHDAAAAAAAYMxsZ3x3xgAAAAAAzGd8d2d3xwwAAADMbHbGd8d3ZgwAAMDGZnbHdsZ2Z8wADmxnbHZ3dmd2d8bgDlx3dnZndnd2Z8zu7nZ1dndndmd2Zsbu7mZndnZ3dmZ2Z8bgDsBmx3Znd2d2d8wADgBszHdmd2d3ZwwAAAAAbGd8d2Z3ZgwAAAAAwMZsZ3Z3xwAAAAAAAADAbHZnDAAAAAAAAAAAAGbGAAAAAA==\"\r\n}",
      "sprites.castle.ts": "namespace sprites.castle {\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroFrontAttack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroSideAttackRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkBack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldBack4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkShieldSideRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideLeft4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const heroWalkSideRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const houseRed = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const houseBlue = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princessBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Front = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Back = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2WalkBack3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Left1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Left2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Right1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const princess2Right2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const rock0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const rock1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const rock2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const saplingOak = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const saplingPine = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const shrub = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackFront4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackLeft1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkLeft2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackRight1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyAttackRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const skellyWalkRight2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileGrass1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileGrass2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileDarkGrass1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileDarkGrass2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileGrass3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tileDarkGrass3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath7 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath8 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tilePath9 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treePine = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treeOak = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const treeSmallPine = image.ofBuffer(hex``);\n}\n",
      "sprites.duck.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.duck\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"duck1\": \"5BAQAAAAAACwywwAAACwC7DdywAAALC9293dDAAAsFW93N3LAACwW1XN3c0AALu1VcXdzQCwW1Vbtd3NALBV1dFb1c0AsFUV/1VVzQC7VfW/VFXFALVVVUVUVcUAtVXVRFRVtQALW0VEVFW7AACw+0xU1QsAAAAAsLS7AAAAAAAACwAA\",\r\n  \"duck2\": \"5BAQAAAAAACwywwAAACwC7DdywAAALC9293dDAAAsFW93N3LAACwW1XN3c0AALu1VcXdzQCwW1Vbtd3NALBV1dFb1c0AsFUV/1VVzQC7VfW/VFXFsLVVVUVUVcVQu1XVRFRVtbAAW0VEVFW7AACw+0xU1QsAAAAAQLu7AAAAAACwAAAA\",\r\n  \"duck3\": \"5BAQAAAAAAC7ywwAAAAAAL3dywAAAAAA3dzdDAAAAABdxd3LAACwu1vV3M0AALtVW1XczQCwW1W9VdvNALDV0VW91c0AsBX/VVVVzbC79b9FVVXFW7xV1URVVcW1sFXdRFVVtQsA20REVVW7AADwTERb1QsAAAAAtLC7AAAAAAALAAAA\",\r\n  \"duck4\": \"5BAQAAAAAAAAywwLAAAAALDduwsAAAAA291bDAAAALDdvV3MAAC7291btcwAsFtV1VvNzQC7VVVV29zNAFsdXVXF3c0AW/FfVVVVzbBb/0tVVVXFW1vVRFVVVcW1W91EVVVVtQuwRERVVVW7AABMtFtV1QsAAEALsLu7AAAAsAAAAAAA\",\r\n  \"duck5\": \"5BAQAAAAAACwzLwAAAAAANu9uwAAAAAA273FAAAAALDd28UAAAC7271VywwAsFtVvdXcDAC7VVW1zd3NAFsdXVXc3c0AW/FfVVVVzbBb/0tVVVXFW1vVRFVVVcW1W91EVVVVtQuwRERVVVW7AABMtFtV1QsAAEALsLu7AAAAsAAAAAAA\",\r\n  \"duck6\": \"5BAQAAAAAAC7zAAAAAAAsL29DAAAAACw3dzNAAAAALBdxb0MAAC721vV3AwAsFtVW1XcDAC7VVW9VdsMAFsdXVW93QwAW/FfVVXVDLBb/1tUVVUMW1tVTVRVVQy1W9VNVFVVCwuwTURUVbULAADPRLRVvQAAAABAC7sLAAAAALAAAAAA\",\r\n  \"duckHurt\": \"5BAQAAAAAAAAywwAAACwC7DdywAAALC9293dDAAAsFW93N3LAAC7W1XN3c0AsFu1VcXdzQC7VVVbtd3NAFtbW9Vb1c0AW7xcVVVVzbtb9UtVVVXFVVvVRFVVVcW7W91EVVVVtQCwRERVVVW7AABMtFtV1QsAAEALsLu7AAAAsAAAAAAA\",\r\n  \"log1\": \"5BgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAGBnAAAAAAAAAAAAAHZnAAAAsMvs7szPYHeGAAAA29377u7O/3fo7gCwvbu97+7uzmbu7gDbu73b7+7u7m52ZwDb29vb++7u7m5357C9vb29/e7u7u5n7rC9vb29ze7u7u6G7rC9vb29ze7u7u6G7rC9vb29ze7u7u5n7gDb29vby+7u7m535wDbu73b7O7u7m53ZwCwvbu97O7u7m6G7gAA293L7u7u7maG7AAAsMvsDgAAYHdn/gAAAAAAAAAAAHZnDgAAAAAAAAAAAGBnAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log2\": \"5BgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAGAAAAAAAAAAAAAAAAdgYAAAAAYGcAAAAAAAAAAAAAAGB3BgAAAAB2ZwAAAAAAu8zuzvwMdmcIAAAAYHeGAAAAALDdve/u7vx/h+7u7sz/d+7uAAAA27vb++7u7mzm7u7u7u5m7u4AALC927v97u7u7mZ35u7u7m52ZwAAsL29vb3v7u7udnfu7u7ubnfnAADb29vb2+/u7u5+5u7u7u7uZ+4AANvb29vb7O7u7m7o7u7u7u6H7gAA29vb29vs7u7ubuju7u7u7ofuAADb29vb2+zu7u5+5u7u7u7uZ+4AALC9vb297O7u7nZ37u7u7m535gAAsL3bu83u7u7udnfm7u7ubndnAAAA27vby+7u7u5m6O7u7u5uhs4AAACw3b3s7u7ubmbI7s78/3aG7gAAAAC7zO4AAAB2d+b///9ud2cAAAAAAAAAAAAAAGB35gAAAAB2ZwAAAAAAAAAAAAAAAHYGAAAAAGBnAAAAAAAAAAAAAAAAYAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log3\": \"5Bg4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAGAAAAAAAAAGAAAAAAAAAAAAAAAAAGBnAAAAAAB2BgAAAABgZwAAAAAAAAAAAAAAAAB2ZwAAAABgdwYAAAAAdmcAAAAAAACwy+zuzM9gd4YAAAAAdmcIAAAAYHeGAAAAAAAA29377u7O/3fo7u7O/H/n7u7u7u5nzswAAAAAsL27ve/u7s5m7u7u7u5u5u7u7u7uZu7uAAAAANu7vdvv7u7ubnZn7u7u7mZ39szs7m53ZwAAAADb29vb++7u7m535+7u7u52d+7u7u5ud+cAAACwvb29vf3u7u7uZ+7u7u7ufubu7u7u7mfuAAAAsL29vb3N7u7u7obu7u7u7n7o7u7u7u6H7gAAALC9vb29ze7u7u6G7u7u7u5+6O7u7u7uh+4AAACwvb29vc3u7u7uZ+7u7u7ufubu7u7u7mfuAAAAANvb29vL7u7ubnfn7u7u7nZn7u7u7m535gAAAADbu73b7O7u7m53Z+7u7u52d+bu7u5+d2cAAAAAsL27vezu7u5uhu7u7u7uZujM/P/MbobuAAAAAADb3cvu7u7uZobs7sz/b2fo7u7u7maG7gAAAAAAsMvsDgAAYHdn/v//73Z3BgAAAGB3ZwAAAAAAAAAAAAAAAAB2Zw4AAABgdwYAAAAAdmcAAAAAAAAAAAAAAAAAYGcAAAAAAHYGAAAAAGBnAAAAAAAAAAAAAAAAAAAGAAAAAABgAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log4\": \"5BhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAYAAAAAAGAAAAAAAAAGAAAAAAAAAAAAAAB2BgAAAABgZwAAAAAAdgYAAAAAYGcAAAAAAAAAAAAAYHcGAAAAAHZnAAAAAGB3BgAAAAB2ZwAAAAC7zO7O/Ax2ZwgAAABgd4YAAAAAdmcIAAAAYHeGAAAAsN297+7u/H+H7u7uzP937u7u7u5+5szM////Z8zMAADbu9v77u7ubObu7u7u7mbu7u7u7m7m7u7MzMxmzMwAsL3bu/3u7u7uZnfm7u7ubnZnz8zu7nZ35szMzHx3ZwCwvb29ve/u7u52d+7u7u5ud+fu7u7udnfuzs7MbHfHANvb29vb7+7u7n7m7u7u7u5n7u7u7u5+5u7u7szMZ8wA29vb29vs7u7ubuju7u7u7ofu7u7u7n7o7u7uzMyHzADb29vb2+zu7u5u6O7u7u7uh+7u7u7ufuju7szOzIfMANvb29vb7O7u7n7m7u7u7u5n7u7u7u5+5u7OzMzMZ8wAsL29vb3s7u7udnfu7u7ubnfm7u7u7nZn7u7uzmx3xgCwvdu7ze7u7u52d+bu7u5ud2fu7u7ud3fmzMzOfHdnAADbu9vL7u7u7mbo7u7u7m6Gzsz/z+xm6O7OzMxshswAALDdvezu7u5uZsjuzvz/dobu7u7ubmbo7u7M/GaG/wAAALvM7gAAAHZ35v///253ZwAAAAB2dwYAAABgd2cAAAAAAAAAAAAAYHfmAAAAAHZnAAAAAGB3BgAAAAB2ZwAAAAAAAAAAAAAAdgYAAAAAYGcAAAAAAHYGAAAAAGBnAAAAAAAAAAAAAABgAAAAAAAABgAAAAAAYAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log5\": \"5BgQAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAB2BgAAAAAAYHcGAAAAAAB2ZwgAAAAAAH7mzO7u7r4Abubu7u7u7gvudnfu7u7uvu52d+7u7u7u7n7m7u7u7u7ufuju7u7u7u5+6O7u7u7u7n7m7u7u7u7udmfu7u7u7u53d+7u7u6+7Gbo7u7u7gtuZuju7u6+AHZ3BgAAAAAAYHcGAAAAAAAAdgYAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log6\": \"5BggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAGAAAAAAAAAAB2BgAAAABgZwAAAAAAAABgdwYAAAAAdmcAAAAAAAAAdmcIAAAAYHeGAAAAAAAAAH/n7u7u7u5nzuzu7u4LAABu5u7u7u7uZu7u7u7uvgAA7mZ39szs7m535+7u7u4LAO52d+7u7u5ud+fu7u7uDgDufubu7u7u7mfu7u7u7g4A7n7o7u7u7u6H7u7u7u4OAO5+6O7u7u7uh+7u7u7uDgDufubu7u7u7mfu7u7u7g4A7nZn7u7u7m535u7u7u4OAO52d+bu7u5+d+fu7u7uCwDuZujM/P/Mbobu7u7uvgAAb2fo7u7u7maG7u7u7gsAAHZ3BgAAAGB3ZwAAAAAAAABgdwYAAAAAdmcAAAAAAAAAAHYGAAAAAGBnAAAAAAAAAABgAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log7\": \"5BgwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAABgAAAAAAYAAAAAAAAAAAAAB2BgAAAABgZwAAAAAAdgYAAAAAAAAAAGB3BgAAAAB2ZwAAAABgdwYAAAAAAAAAAHZnCAAAAGB3hgAAAAB2ZwgAAAAAAAAAAH/n7u7u7v937u7u7u5+5szu7u6+AAAAAG7m7u7u7u5m7u7u7u5u5u7u7u7uCwAAAO5md+bu7u5udmfPzO7udnfu7u7uvgAAAO52d+7u7u5ud+fu7u7udnfu7u7u7gAAAO5+5u7u7u7uZ+7u7u7ufubu7u7u7gAAAO5+6O7u7u7uh+7u7u7ufuju7u7u7gAAAO5+6O7u7u7uh+7u7u7ufuju7u7u7gAAAO5+5u7u7u7uZ+7u7u7ufubu7u7u7gAAAO52Z+7u7u5ud+bu7u7udmfu7u7u7gAAAO52d+bu7u5ud2fu7u7ud3fu7u7uvgAAAO5m6Ozu7u5uhs7M/8/sZuju7u7uCwAAAG9n6O7O/P92hu7u7u5uZuju7u6+AAAAAHZ35v///253ZwAAAAB2dwYAAAAAAAAAAGB35gAAAAB2ZwAAAABgdwYAAAAAAAAAAAB2BgAAAABgZwAAAAAAdgYAAAAAAAAAAABgAAAAAAAABgAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"log8\": \"5Bg4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAGAAAAAABgAAAAAAAABgAAAAAAAAB2BgAAAABgZwAAAAAAdgYAAAAAYGcAAAAAAABgdwYAAAAAdmcAAAAAYHcGAAAAAHZnAAAAAAAAdmcIAAAAYHeGAAAAAHZnCAAAAGB3hgAAAAAAAH+H7u7uzP937u7u7v5/5+7u7u7uZ87s7u7uCwBs5u7u7u7uZu7u7u7ububu7u7u7mbu7u7u7r4A7mZ35u7u7m52Z+7u7u5md/bM7O5ud+fu7u7uC+52d+7u7u5ud+fu7u7udnfu7u7ubnfn7u7u7g7ufubu7u7u7mfu7u7u7n7m7u7u7u5n7u7u7u4O7m7o7u7u7u6H7u7u7u5+6O7u7u7uh+7u7u7uDu5u6O7u7u7uh+7u7u7ufuju7u7u7ofu7u7u7g7ufubu7u7u7mfu7u7u7n7m7u7u7u5n7u7u7u4O7nZ37u7u7m535u7u7u52Z+7u7u5ud+bu7u7uDu52d+bu7u5ud2fu7u7udnfm7u7ufnfn7u7u7gvuZuju7u7ubobO7u7u7mbozPz/zG6G7u7u7r4AbmbI7s78/3aG7u7M/29n6O7u7u5mhu7u7u4LAHZ35v///253Z/7//+92dwYAAABgd2cAAAAAAABgd+YAAAAAdmcOAAAAYHcGAAAAAHZnAAAAAAAAAHYGAAAAAGBnAAAAAAB2BgAAAABgZwAAAAAAAABgAAAAAAAABgAAAAAAYAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\r\n  \"tree\": \"5CQpAAAAAAAAAAAAAACAhgAAAAAAAAAAAAAAAAAAAAAAAAAAAAiAhogGAAAAAAAAAAAAAAAAAAAAAAAAgIZohmaGAAAAAAAAAAAAAAAAAAAAAAAAgIZmaGaIiAAAAAAAAAAAAAAAAAAAAGAAZmZnZoZoZggAAAAAAAAAAAAAAAAAAHYIaHZnZohmhggAAAAAAAAAAAAAAAAAgHeGaHZmZmhmiIgIAAAAAAAAAAAAAAAAhmd2Z2Z2ZmaGaGYIAAAAAAAAAAAAYABgZ2Z3Z2Z3Z2ZmZoaIAAAAAAAAAAAAdgZoZ2Z3Zmd3ZmZmZoiGAAAAAAAAAAAAeId2ZmdndmdmZmZmhmiGAAAAAAAAAGAIaGd2dmdmd2dmdmZmZmaGAAAAAAAAAGCGdmZmdmdmd2Zmd2dmZmaIAAAAAAAAAIBmdmZmdmZmZnZmd2ZmZoiIAAAAAAAAAICGd2ZmZ3Zndnd2ZmZmZmaGDgAAAAAAAIB4d3dmZndnd3dmdndmZmZm6Mz/DwAAAGh3d2dmdndmd2Zmd3dmZmaI6O7ODwAAAHZ3d2ZmZmZmdndmZmZmZoaI7u7uDAAAAIB2d3dmd2d2d3dmd2dmZmaG6P/vDgAAAIBod2Zmd3d3d2dmd2d2d2aGCMDsDgAAAGB4dnZmdnd2d3dmZmZ2Z2aGAOzODAAAAAB4hnZnZndmd3d2Z2ZmZmbI7s4AAAAAAABmaGhnZmZ3d2Z2d2ZmZoboDAAAAAAAAACIaIZnZ2Z3d2ZmZnZ3Z2aIAAAAAAAAAAAAYIh4Z2Z3d2ZnZmZ3Z2ZmCAAAAAAAAAAAAABgh2d3Z2Z3ZmZ2Z2aGAAAAAAAAAAAAAAAAhnZ2Z2Z3Z3dmZoYIAAAAAAAAAAAAAAAAAHhnZ3d2Z3dmZmYIAAAAAAAAAAAAAAAAAGBnZndmZnZmZoYIAAAAAAAAAAAAAAAAAACGZ3ZmdmZmhggAAAAAAAAAAAAAAAAAAACAd2ZmdmZmhgAAAAAAAAAAAAAAAAAAAAAAdmZmZmZmhgAAAAAAAAAAAAAAAAAAAAAAgGiGZmaICAAAAAAAAAAAAAAAAAAAAAAAAIAIaGYIAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgAAAAAAAAAAAAAAA==\"\r\n}",
      "sprites.duck.ts": "namespace sprites.duck {\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duck6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const duckHurt = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log6 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log7 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const log8 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const tree = image.ofBuffer(hex``);\n}\n",
      "sprites.space.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.space\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"spaceSmallAsteroid0\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALwMAAAAAADAu8sAAAAAALr7rwwAAADAq6uvzAAAAMD6v8sMAAAAwMq/ugwAAAAAoKq/AAAAAADArKwAAAAAAADMCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceSmallAsteroid1\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDMAAAAAADAqrsLAAAAAKC6q6sAAAAAoP/LrwAAAACs/6q/AAAAAKzLv7oAAAAAALq8ygAAAAAAALsMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceSmallAsteroid2\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAzAAAAAAAwKq7CwAAAACguqurAAAAAKD/y68AAAAArP+qvwAAAACsy7+6AAAAAAC6vMoAAAAAAAC7DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceSmallAsteroid3\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8ywAAAAAAwPy7CwAAAACg//q6AAAAAKC6u78AAAAArPu/zAAAAADAq68MAAAAAACsygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceAsteroid0\": \"5BAQAAAAyKzKAAAAAADM+qgKAAAAwMzKj8wAAADMvKusyswAAMz/q6q6ywwA+P+4yqy7zID4/7rM/7rKwP+Pq8z/v8vAzKzMyvpvy8yqzMysqmbM/K/KzKq7psyI/6rM/LjKDMD/rMz/z8sAwMyo/P/PxgAAzMz8j2zMAADAzMysygAA\",\r\n  \"spaceAsteroid1\": \"5BAQAADAzMwAAAAAAMyquwwAAAAArI+8CwAAAADM+q8LAAAAAMyqqqq8ywAAzKzKq7u7DADAzPq8zLoKAMyqir/Ku8YAjM+quqpqxgD8z8yqvGbLwPzMzKq8ygzAzKrMiKsAAMD/qoyoAAAAwPyvzMwAAAAAzK/MDAAAAADAzMwAAAAA\",\r\n  \"spaceSmallAsteroid4\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAqgwAAAAAAMD/uwAAAAAAvPu7DAAAAADLu6oLAAAAAPqr/wsAAAAArPqvAAAAAADAzAwAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceSmallAsteroid5\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMoAAAAAAAC8qqsAAAAAAPrP/woAAADA/7v/CwAAAMC7ursLAAAAAMz7vwwAAAAAwPq6DAAAAAAAvKsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\r\n  \"spaceRedShip\": \"5BAQAAAAAAAAAADMAAAAAAAAwMwAAAAAAADMzAAAAAAAAM/MAAAAAADgz8wAAAAAAOzvzAAAAADuLOzuzMzP7y4sLO7dvS8vRC4uIgAAAADuTi4iAAAAAADuLyIAAAAAAOBPJAAAAAAAAC5CAAAAAAAA7iIAAAAAAADg7gAAAAAAAADu\",\r\n  \"spaceAsteroid2\": \"5BAQAAAAAMDMDAAAAAAArKrMAAAAwMz8r8sMAADMzPzPugwAwP+qzP+6zAzA/K/K/7q7C8D8r8zMuqy7wPqsrKy7zGrMqrq7bLbMasyqyrpmu7vGzKr/b7urusvMzP+8u8q6DMCq/7q7y8sAAKyquqq7DAAAwKrMqqoAAAAAzMzMAAAA\",\r\n  \"spaceAsteroid3\": \"5BAQAAAAAMzMzAAAAMzMzKyqDADArKqsuoyrAMC6jKrL/7wMsMv/rIbPvAyw+v/Masq8DLD8j8zMvLwMrPvIzMysuwvMuqqqqvq/y6yqu8uv/7y7qrq7/K/Kurusu7v/vLy7y8C8u8q8zLsMAKy7u8vMugwAAKq8u8vMAAAAAKzKAAAA\",\r\n  \"spaceAsteroid4\": \"5BAQAAAAAADMursKAACsCsCsuqsAwLyrqsqspgCsqruqu8y7AMqsu6q7qsug/MymzLq7Cqz/b/rMaqsMrPqq+6+2qgDMqqq7rMoMAMD6zLqrCwAAwPrPqrrLAAAArP+susYAAADAqsqsqwAAAADM/8/LAAAAAMD/qgwAAAAAwMzMAAAA\",\r\n  \"spaceOrangeShip\": \"5BAQAAAAAAAAAADuAAAAAAAA4O4AAAAAAADu7gAAAAAAAO/uAAAAAADg7+4AAAAAAOwv7gAAAADuTCwizMzP705MTCLdvU9PVUJCRAAAAAAiUkJEAAAAAAAiT0QAAAAAACBfRQAAAAAAAEJUAAAAAAAAIkQAAAAAAAAgIgAAAAAAAAAi\",\r\n  \"spacePinkShip\": \"5BAQAAAAAAAAAACIAAAAAAAAgIgAAAAAAACIiAAAAAAAAI+IAAAAAACAj4gAAAAAAIyviAAAAACIPKyqzMzPjzg8PKrdvT8/ETo6MwAAAACqGjozAAAAAACqPzMAAAAAAKAfMQAAAAAAADoTAAAAAAAAqjMAAAAAAACgqgAAAAAAAACq\",\r\n  \"spaceBlueShip\": \"5BAQAAAAAAAAAACIAAAAAAAAgIgAAAAAAACIiAAAAAAAAI+IAAAAAACAj4gAAAAAAIyPiAAAAACIbIyIzMzPj2hsbIjdvW9vmWhuZgAAAACImG5mAAAAAACIb2YAAAAAAICfaQAAAAAAAGiWAAAAAAAAiGYAAAAAAACAiAAAAAAAAACI\",\r\n  \"spaceGreenShip\": \"5BAQAAAAAAAAAACIAAAAAAAAgIgAAAAAAACIiAAAAAAAAI+IAAAAAACAj4gAAAAAAIxviAAAAACIfGxmzMzPj3h8fGbdvX9/VXZ2dwAAAABmVnZ3AAAAAABmf3cAAAAAAGBfdQAAAAAAAHZXAAAAAAAAZncAAAAAAABgZgAAAAAAAABm\"\r\n}",
      "sprites.space.ts": "namespace sprites.space {\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid0 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceSmallAsteroid5 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceRedShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceAsteroid4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceOrangeShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spacePinkShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceBlueShip = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const spaceGreenShip = image.ofBuffer(hex``);\n}\n",
      "sprites.vehicle.jres": "{\r\n  \"*\": {\r\n    \"namespace\": \"sprites.vehicle\",\r\n    \"mimeType\": \"image/x-mkcd-f4\",\r\n    \"dataEncoding\": \"base64\"\r\n  },\r\n  \"carRedLeft\": \"5BAQAAAAAAAAAAAAAADQIiLtDgAAAC0i0u0OAAAAIiLS4u4AACBEJCLu/g8Awswr7u7/DyDMvO7y7v8PICLivuLv/w8gIuS74v7+ACAi5Lvi/u4AICLku/L/7gAgIuTu7u7+ACAi5Lvi7v8PIETku+Lu/w8Awiy+4u7/DwAgzOLu7v8A\",\r\n  \"carRedRight\": \"5BAQAAAAAAAAAAAAAAAiIu7uDgAAIMzi7u7/AADCLL7i7v8PIETku+Lu/w8gIuS74u7/DyAi5O7u7v4AICLku/L/7gAgIuS74v7uACAi5Lvi/v4AICLivuLv/w8gzLzu8u7/DwDCzCvu7v8PACBEJCLu/g8AACIi0uLuAAAALSLS7Q4A\",\r\n  \"carRedBack\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg///u7v8PACIiIiLi7v/gzCLC7O4t/i5CRCTO694OLiIiQrzr7g4sIiJCvOvuDiwiIiK86+4OLiIiIrzr7g4uIiIizuveDuDMLMLs7i3+ACIiIiLi7v8A4P//7u7/DwAAAAAAAAAA\",\r\n  \"carRedFront\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4P/v/g8AAAAi4iLuLg8AwszMLEvd4iBCRCSyTNItICQiIstMIiIgJCIiy0wiIiAiIiLLTCIiICIiIstMIiIgIiIiskzSLQDCzMwsS93iAAAi4iLuLg8AAOD/7/7/AAAAAAAAAAAA\",\r\n  \"carBlueLeft\": \"5BAQAAAAAAAAAAAAAADQZmaNCAAAAG1m1o0IAAAAZmbWhogAAGCZaWaI+A8AxsxriIj/D2DMvIj2iP8PYGaGuIaP/w9gZom7hvj4AGBmibuG+IgAYGaJu/b/iABgZomIiIj4AGBmibuGiP8PYJmJu4aI/w8Axmy4hoj/DwBgzIaIiP8A\",\r\n  \"carBlueRight\": \"5BAQAAAAAAAAAAAAAABmZoiICAAAYMyGiIj/AADGbLiGiP8PYJmJu4aI/w9gZom7hoj/D2BmiYiIiPgAYGaJu/b/iABgZom7hviIAGBmibuG+PgAYGaGuIaP/w9gzLyI9oj/DwDGzGuIiP8PAGCZaWaI+A8AAGZm1oaIAAAAbWbWjQgA\",\r\n  \"carBlueBack\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA//+IiP8PAGZmZmaGiP+AzGbGjIht+GiWmWnIi9gIaGZmlryLiAhsZmaWvIuICGxmZma8i4gIaGZmZryLiAhoZmZmyIvYCIDMbMaMiG34AGZmZmaGiP8AgP//iIj/DwAAAAAAAAAA\",\r\n  \"carBlueFront\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP+P+A8AAABmhmaIaA8AxszMbJvdhmCWmWm2nNZtYGlmZsucZmZgaWZmy5xmZmBmZmbLnGZmYGZmZsucZmZgZmZmtpzWbQDGzMxsm92GAABmhmaIaA8AAID/j/j/AAAAAAAAAAAA\",\r\n  \"carPinkLeft\": \"5BAQAAAAAAAAAAAAAADQMzOtCgAAAD0z060KAAAAMzPTo6oAADDdPTOq+g8Aw8w7qqr/DzDMvKrzqv8PMDOjuqOv/w8wM627o/r6ADAzrbuj+qoAMDOtu/P/qgAwM62qqqr6ADAzrbujqv8PMN2tu6Oq/w8Awzy6o6r/DwAwzKOqqv8A\",\r\n  \"carPinkRight\": \"5BAQAAAAAAAAAAAAAAAzM6qqCgAAMMyjqqr/AADDPLqjqv8PMN2tu6Oq/w8wM627o6r/DzAzraqqqvoAMDOtu/P/qgAwM627o/qqADAzrbuj+voAMDOjuqOv/w8wzLyq86r/DwDDzDuqqv8PADDdPTOq+g8AADMz06OqAAAAPTPTrQoA\",\r\n  \"carPinkBack\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg//+qqv8PADMzMzOjqv+gzDPDrKo9+jrT3T3Kq9oKOjMz07yrqgo8MzPTvKuqCjwzMzO8q6oKOjMzM7yrqgo6MzMzyqvaCqDMPMOsqj36ADMzMzOjqv8AoP//qqr/DwAAAAAAAAAA\",\r\n  \"carPinkFront\": \"5BAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoP+v+g8AAAAzozOqOg8Aw8zMPNvdozDT3T2z3NM9MD0zM8vcMzMwPTMzy9wzMzAzMzPL3DMzMDMzM8vcMzMwMzMzs9zTPQDDzMw8292jAAAzozOqOg8AAKD/r/r/AAAAAAAAAAAA\",\r\n  \"roadTurn1\": \"5BAQAADAzMzMzMzMALy7u7u7u7vAu93d3d3d3bzbu7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u9u7u8vbu7G9G7u7y9u7sRsbu7vL272xG7u7u8vbu7vbu7u7y9u7u7u7u7vL27u7u7u928vbu7u7vbu7y9u7u7u9vL\",\r\n  \"roadTurn2\": \"5BAQALy9u7u7u9vLvL27u7u727u8vbu7u7u73by9u7u7u7u7vL27u727u7u8vbvbEbu7u7y9u7sRsbu7vL27uxvRu7u8vbu7u727u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7zbu7u7u7u7wLvd3d3d3d0AvLu7u7u7uwDAzMzMzMzM\",\r\n  \"roadTurn4\": \"5BAQAMzMzMzMzAwAu7u7u7u7ywDd3d3d3d27DLu7u7u7u73Lu7u7u7u728u7u7u7u7vby7u7u7u7u9vLu7vbu7u728u7ux2xu7vby7u7GxG7u9vLu7u7Eb2728u7u7vbu7vby7u7u7u7u9vL3bu7u7u728u7vbu7u7vby7y9u7u7u9vL\",\r\n  \"roadIntersection1\": \"5BAQALu9u7u7u9vL27u7u7u728u9u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u9vLvbu7u7u728vbu7u7u7vby7u9u7u7u9vL\",\r\n  \"roadIntersection2\": \"5BAQAMzMzMzMzMzMu7u7u7u7u7vd3d3d3d3d3bu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7vbu7u7u7u9vbu7u7u7u7vbu9u7u7u9u7\",\r\n  \"roadVertical\": \"5BAQAMzMzMzMzMzMu7u7u7u7u7vd3d3d3d3d3bu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u72xERu9sREbsbEdG7GxHRu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u73d3d3d3d3d27u7u7u7u7u8zMzMzMzMzM\",\r\n  \"roadTurn3\": \"5BAQALy9u7u7u9vLu727u7u728vdu7u7u7vby7u7u7u7u9vLu7u727u728u7u7sRvbvby7u7GxG7u9vLu7sdsbu728u7u9u7u7vby7u7u7u7u9vLu7u7u7u728u7u7u7u7vby7u7u7u7u73L3d3d3d3duwy7u7u7u7vLAMzMzMzMzAwA\",\r\n  \"roadHorizontal\": \"5BAQALy9u7u7u9vLvL27G72728u8vbsbsbvby7y9uxuxu9vLvL27G7G728u8vbvbsbvby7y9u7u7u9vLvL27u7u728u8vbu7u7vby7y9uxu9u9vLvL27G7G728u8vbsbsbvby7y9uxuxu9vLvL2727G728u8vbu7u7vby7y9u7u7u9vL\",\r\n  \"roadIntersection3\": \"5BAQALu9u7u7u9u727u7u7u7u729u7u7u7u727u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u73d3d3d3d3d27u7u7u7u7u8zMzMzMzMzM\",\r\n  \"roadIntersection4\": \"5BAQALy9u7u7u9u7vL27u7u7u728vbu7u7u727y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u7u8vbu7u7u7u7y9u7u7u7u7vL27u7u7u9u8vbu7u7u7vby9u7u7u9u7\"\r\n}",
      "sprites.vehicle.ts": "namespace sprites.vehicle {\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carRedFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carBlueFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkLeft = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkRight = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkBack = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const carPinkFront = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadTurn1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadTurn2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadTurn4 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadIntersection1 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadIntersection2 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadVertical = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadTurn3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadHorizontal = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadIntersection3 = image.ofBuffer(hex``);\n    //% fixedInstance jres blockIdentity=images._image\n    export const roadIntersection4 = image.ofBuffer(hex``);\n}\n",
      "startup.ts": "// This is the last thing executed before user code\n\ngame.setWaitAnyButton(controller.pauseUntilAnyButtonIsPressed)\ngame.gameOverSound = () => music.playSound(music.sounds(Sounds.Wawawawaa));\n"
    },
    "jacdac": {
      "jacdac.cpp": "#include \"pxt.h\"\n#include \"JDProtocol.h\"\n\nnamespace jacdac {\n\n#ifndef CODAL_JACDAC_WIRE_SERIAL\n\nclass DummyDmaSingleWireSerial : public DMASingleWireSerial {\n    protected:\n    virtual void configureRxInterrupt(int enable) {}\n    virtual int configureTx(int) { return DEVICE_OK; }\n    virtual int configureRx(int) { return DEVICE_OK; }\n\n    public:\n    DummyDmaSingleWireSerial(Pin& p): DMASingleWireSerial(p) {}\n\n    virtual int sendDMA(uint8_t* data, int len) { return DEVICE_OK; }\n    virtual int receiveDMA(uint8_t* data, int len) { return DEVICE_OK; }\n    virtual int abortDMA() { return DEVICE_OK; }\n\n    virtual int putc(char c) { return DEVICE_OK; }\n    virtual int getc() { return DEVICE_OK; }\n\n    virtual int send(uint8_t* buf, int len) { return DEVICE_OK; }\n    virtual int receive(uint8_t* buf, int len) { return DEVICE_OK; }\n\n    virtual int setBaud(uint32_t baud) { return DEVICE_OK; }\n    virtual uint32_t getBaud() { return 0; }\n    virtual int sendBreak() { return DEVICE_OK; }\n};\n\n#define CODAL_JACDAC_WIRE_SERIAL DummyDmaSingleWireSerial \n#endif\n\n// Wrapper classes\nclass WProtocol {\n  public:\n    CODAL_JACDAC_WIRE_SERIAL sws;\n    codal::JACDAC jd;\n    codal::JDProtocol protocol; // note that this is different pins than io->i2c\n    WProtocol()\n#ifdef CODAL_JACDAC_SUPER_UGLY_CTOR\n        : sws(*LOOKUP_PIN(JACDAC), SERCOM0, 0, PINMUX_PA04D_SERCOM0_PAD0, 0)\n#else        \n        : sws(*LOOKUP_PIN(JACDAC))\n#endif       \n        , jd(*LOOKUP_PIN(JACDAC), sws) \n        , protocol(jd)\n    {\n        jd.start();\n    }\n};\n\nSINGLETON(WProtocol);\n\nclass JDProxyDriver : public JDDriver {\n  public:\n    RefCollection *methods;\n\n    JDProxyDriver(JDDevice d, RefCollection *m) \n        : JDDriver(d) {\n        this->methods = m;\n        incrRC(m);\n        registerGCPtr((TValue)m);\n    }\n\n    virtual int handleControlPacket(JDPkt *p) {\n        auto buf = pxt::mkBuffer((const uint8_t*)&p->crc, p->size + 4);\n        auto r = pxt::runAction1(methods->getAt(0), (TValue)buf);\n        auto retVal = numops::toBool(r) ? DEVICE_OK : DEVICE_CANCELLED;\n        decr(r);\n        decrRC(buf);\n        return retVal;\n    }\n\n    virtual int handlePacket(JDPkt *p) {\n        auto buf = pxt::mkBuffer((const uint8_t*)&p->crc, p->size + 4);\n        auto r = pxt::runAction1(methods->getAt(1), (TValue)buf);\n        auto retVal = numops::toBool(r) ? DEVICE_OK : DEVICE_CANCELLED;\n        decr(r);\n        decrRC(buf);\n        return retVal;\n    }\n\n    virtual int fillControlPacket(JDPkt *p) {\n        auto buf = pxt::mkBuffer((const uint8_t*)&p->crc, JD_SERIAL_DATA_SIZE + 4);\n        auto r = pxt::runAction1(methods->getAt(2), (TValue)buf);\n        memcpy(&p->crc, buf->data, JD_SERIAL_DATA_SIZE + 4);\n        (void)r;\n        // decr(r); // TODO compiler might return non-null on void functions, so better skip decr\n        decrRC(buf);\n        return DEVICE_OK;\n    }\n\n    virtual int deviceConnected(JDDevice device) {\n        auto r = JDDriver::deviceConnected(device);\n        pxt::runAction0(methods->getAt(3));\n        return r;\n    }\n\n    virtual int deviceRemoved() {\n        auto r = JDDriver::deviceRemoved();\n        pxt::runAction0(methods->getAt(4));\n        return r;\n    }\n\n    void sendPairing(int address, uint32_t flags, int serialNumber, uint32_t driverClass) {\n        sendPairingPacket(JDDevice(address, flags, serialNumber, driverClass));\n    }\n\n    JDDevice *getDevice() { return &device; }\n\n    ~JDProxyDriver() { \n        decrRC(methods); \n        unregisterGCPtr((TValue)methods);\n    }\n};\n\n//%\nJDProxyDriver *__internalAddDriver(int driverType, int driverClass, RefCollection *methods) {\n    getWProtocol();\n    return new JDProxyDriver(JDDevice((DriverType)driverType, driverClass), methods);\n}\n\n/**\n* Internal\n*/\n//%\nint __internalSendPacket(Buffer buf, int deviceAddress) {\n    getWProtocol();\n    return JDProtocol::send(buf->data, buf->length, deviceAddress);\n}\n\n} // namespace jacdac\n\nnamespace JacDacDriverStatusMethods {\n\n/**\n* Retrieves the serial number in use by this driver.\n*\n* @return the serial number\n**/\n//% property\nuint32_t serialNumber(JacDacDriverStatus d) {\n    return d->getSerialNumber();\n}\n\n\n/** Check if device is paired. */\n//% property\nbool isPaired(JacDacDriverStatus d) {\n    return d->isPaired();\n}\n\n/** Check if device is pairable. */\n//% property\nbool isPairable(JacDacDriverStatus d) {\n    return d->isPairable();\n}\n\n/** Check if driver is virtual. */\n//% property\nbool isVirtualDriver(JacDacDriverStatus d) {\n    return d->getDevice()->isVirtualDriver();\n}\n\n\n/** Check if driver is paired. */\n//% property\nbool isPairedDriver(JacDacDriverStatus d) {\n    return d->getDevice()->isPairedDriver();\n}\n\n/** Check if driver is connected. */\n//% property\nbool isConnected(JacDacDriverStatus d) {\n    return d->isConnected();\n}\n\n/** Get device class. */\n//% property\nuint32_t driverClass(JacDacDriverStatus d) {\n    return d->getClass();\n}\n\n/** Get device class. */\n//% property\nuint8_t driverAddress(JacDacDriverStatus d) {\n    return d->getAddress();\n}\n\n/** Get device id for events. */\n//% property\nbool id(JacDacDriverStatus d) {\n    return d->id;\n}\n\n/** If paired, paired instance address */\n//% property\nuint32_t isPairedInstanceAddress(JacDacDriverStatus d, uint8_t address) {\n    // TODO\n    return false;\n}\n\n} // namespace JacDacDriverStatusMethods\n",
      "jacdac.ts": "class JacDacDriver {\n    public device: JacDacDriverStatus;\n    public driverType: jacdac.DriverType;\n    public deviceClass: number;\n\n    constructor(driverType: jacdac.DriverType, deviceClass: number) {\n        this.driverType = driverType;\n        this.deviceClass = deviceClass || jacdac.programHash();\n    }\n\n    /**\n     * Called by the logic driver when a control packet is addressed to this driver.\n     * Return false when the packet wasn't handled here.\n     */\n    public handleControlPacket(pkt: Buffer): boolean {\n        return false\n    }\n\n    /**\n     * Called by the logic driver when a data packet is addressed to this driver\n     * Return false when the packet wasn't handled here.\n     */\n    public handlePacket(pkt: Buffer): boolean {\n        return false\n    }\n\n    /**\n     * Fill additional driver-specific info on the control packet for this driver.\n     **/\n    public fillControlPacket(pkt: Buffer): void { }\n\n    /**\n     * Called by the logic driver when a new device is connected to the serial bus\n     */\n    public deviceConnected(): void {\n        control.dmesg(`jd> device connected`)\n    }\n\n    /**\n     * Called by the logic driver when an existing device is disconnected from the serial bus\n     **/\n    public deviceRemoved(): void {\n        control.dmesg(`jd> device removed`)\n    }\n\n    /**\n     * Sends a pairing packet\n     */\n    public sendPairing(address: number, flags: number, serialNumber: number, driverClass: number) { }\n}\n\n/**\n * JACDAC protocol support\n */\nnamespace jacdac {\n    // This enumeration specifies that supported configurations that drivers should utilise.\n    // Many combinations of flags are supported, but only the ones listed here have been fully implemented.\n    export enum DriverType {\n        VirtualDriver = DAL.JD_DEVICE_FLAGS_REMOTE, // the driver is seeking the use of another device's resource\n        PairedDriver = DAL.JD_DEVICE_FLAGS_BROADCAST | DAL.JD_DEVICE_FLAGS_PAIR,\n        HostDriver = DAL.JD_DEVICE_FLAGS_LOCAL, // the driver is hosting a resource for others to use.\n        PairableHostDriver = DAL.JD_DEVICE_FLAGS_PAIRABLE | DAL.JD_DEVICE_FLAGS_LOCAL, // the driver is allowed to pair with another driver of the same class\n        BroadcastDriver = DAL.JD_DEVICE_FLAGS_LOCAL | DAL.JD_DEVICE_FLAGS_BROADCAST, // the driver is enumerated with its own address, and receives all packets of the same class (including control packets)\n        SnifferDriver = DAL.JD_DEVICE_FLAGS_REMOTE | DAL.JD_DEVICE_FLAGS_BROADCAST, // the driver is not enumerated, and receives all packets of the same class (including control packets)\n    };\n\n    export let log: (msg: string) => void = function () { };\n\n    //% shim=pxt::programHash\n    export function programHash(): number { return 0 }\n\n    //% shim=jacdac::__internalSendPairingPacket\n    function __internalSendPairingPacket(address: uint32, flags: uint32, serialNumber: uint32, driverClass: uint32): void {\n    }\n\n    /**\n     * Sends a pairing packet\n     * @param address \n     * @param flags \n     * @param serialNumber \n     * @param driverClass \n     */\n    //%\n    export function sendPairing(address: uint32, flags: uint32, serialNumber: uint32, driverClass: uint32): void {\n        __internalSendPairingPacket(address, flags, serialNumber, driverClass);\n    }\n\n\n    //% shim=jacdac::__internalAddDriver\n    function __internalAddDriver(driverType: number, deviceClass: number, methods: ((p: Buffer) => void)[]): JacDacDriverStatus {\n        return null\n    }\n\n    /**\n     * Adds a JacDac device driver\n     * @param n driver\n     */\n    export function addDriver(n: JacDacDriver) {\n        if (n.device) { // don't add twice\n            control.dmesg(`jd> driver already added ${n.driverType} ${n.deviceClass}`)\n            return;\n        }\n        control.dmesg(`jd> driver ${n.driverType} ${n.deviceClass}`)\n        n.device = __internalAddDriver(n.driverType, n.deviceClass, [\n            (p: Buffer) => n.handleControlPacket(p),\n            (p: Buffer) => n.handlePacket(p),\n            (p: Buffer) => n.fillControlPacket(p),\n            () => n.deviceConnected(),\n            () => n.deviceRemoved()])\n    }\n\n    /**\n     * Sends a packet\n     * @param pkt jackdack data\n     */\n    export function sendPacket(pkt: Buffer, deviceAddress: number) {\n        control.dmesg(`jd> send pkt to ${deviceAddress}`)        \n        __internalSendPacket(pkt, deviceAddress);\n    }\n\n    export class JDPacket {\n        protected buf: Buffer;\n        constructor(buf: Buffer) {\n            this.buf = buf;\n        }\n        get crc(): number {\n            return this.buf.getNumber(NumberFormat.UInt16LE, 0);\n        }\n        get address(): number {\n            return this.buf.getNumber(NumberFormat.UInt8LE, 2);\n        }\n        get size(): number {\n            return this.buf.getNumber(NumberFormat.UInt8LE, 3);\n        }\n        get data(): Buffer {\n            return this.buf.slice(4);\n        }\n\n        getNumber(format: NumberFormat, offset: number) {\n            return this.buf.getNumber(format, offset + 4);\n        }\n\n        setNumber(format: NumberFormat, offset: number, value: number) {\n            this.buf.setNumber(format, offset + 4, value);\n        }\n    }\n\n    export class ControlPacket {\n        private buf: Buffer;\n        constructor(buf: Buffer) {\n            this.buf = buf;\n        }\n        get packetType(): number {\n            return this.buf.getNumber(NumberFormat.UInt8LE, 0);\n        }\n        get address(): number {\n            return this.buf.getNumber(NumberFormat.UInt8LE, 1);\n        }\n        get flags(): number {\n            return this.buf.getNumber(NumberFormat.UInt16LE, 2);\n        }\n        get driverClass(): number {\n            return this.buf.getNumber(NumberFormat.UInt32LE, 4);\n        }\n        get serialNumber(): number {\n            return this.buf.getNumber(NumberFormat.UInt32LE, 8);\n        }\n        get data(): Buffer {\n            return this.buf.slice(12);\n        }\n    }\n\n    /**\n     * Pipes specific events through JACDAC\n     */\n    //%\n    let _eventBus: MessageBusDriver;\n    export function listenEvent(src: number, value: number) {\n        if (!_eventBus) {\n            control.dmesg(\"jd> starting message bus\")\n            _eventBus = new MessageBusDriver();\n            jacdac.addDriver(_eventBus);\n        }\n        _eventBus.listenEvent(src, value);\n    }\n}",
      "messagebusdriver.ts": "namespace jacdac {\n    /**\n     * A driver that listens for message bus events\n     */\n    export class MessageBusDriver extends JacDacDriver {\n        suppressForwarding: boolean;\n\n        constructor() {\n            super(DriverType.BroadcastDriver, DAL.JD_DRIVER_CLASS_MESSAGE_BUS);\n            this.suppressForwarding = false;\n        }\n\n        /**\n         * Pipes matching events to JacDac bus\n         * @param id \n         * @param value \n         */\n        listenEvent(id: number, value: number) {\n            control.dmesg(`jd> msgbus> listen event ${id} ${value}`)        \n            control.onEvent(id, value, () => {\n                if (this.suppressForwarding) return;\n\n                const event = control.createBuffer(4);\n                event.setNumber(NumberFormat.UInt16LE, 0, id);\n                event.setNumber(NumberFormat.UInt16LE, 2, value);\n                jacdac.sendPacket(event, this.device.driverAddress);\n\n            }, DAL.MESSAGE_BUS_LISTENER_IMMEDIATE)\n        }\n\n        public handlePacket(pkt: Buffer): boolean {\n            control.dmesg(`jd> msgbus> packet`)        \n            const packet = new JDPacket(pkt);\n            const id = packet.getNumber(NumberFormat.UInt16LE, 0);\n            const value = packet.getNumber(NumberFormat.UInt16LE, 2);\n            this.suppressForwarding = true;\n            control.raiseEvent(id, value);\n            this.suppressForwarding = false;\n            return true;\n        }\n\n        public handleControlPacket(pkt: Buffer): boolean {\n            control.dmesg(`jd> msgbus> control packet`)        \n            return true;\n        }\n    }\n}",
      "pindriver.ts": "namespace jacdac {\n    enum PinMode {\n        SetAnalog,\n        SetDigital,\n        SetServo\n    }\n    /**\n         */\n    export class PinDriver extends JacDacDriver {\n        private _pin: PwmOnlyPin; // might be null\n\n        constructor(pin: PwmOnlyPin = undefined) {\n            super(\n                !!pin ? DriverType.PairableHostDriver : DriverType.PairedDriver, \n                DAL.JD_DRIVER_CLASS_PIN);\n            this._pin = pin;\n        }\n\n        private sendPacket(mode: PinMode, value: number): boolean {\n            if (!this.device.isPaired || !this.device.isConnected)\n                return false;\n\n            const pkg = control.createBuffer(4);\n            pkg.setNumber(NumberFormat.UInt16LE, 0, mode);\n            pkg.setNumber(NumberFormat.Int16LE, 2, value);\n\n            jacdac.sendPacket(pkg, this.device.driverAddress);\n            return true;\n        }\n\n        //%\n        setAnalogValue(value: number) {\n            this.sendPacket(PinMode.SetAnalog, value >> 0);\n        }\n\n        //%\n        setDigitalValue(value: number) {\n            this.sendPacket(PinMode.SetDigital, value >> 0);\n        }\n\n        //%\n        setServoValue(value: number) {\n            this.sendPacket(PinMode.SetServo, value >> 0);\n        }\n\n        public handleControlPacket(pkt: Buffer): boolean {\n            const cp = new ControlPacket(pkt);\n            if (this.device.isPairedDriver && !this.device.isPaired) {\n                jacdac.log(\"need to pair\");\n                if (cp.flags & DAL.CONTROL_JD_FLAGS_PAIRABLE) {\n                    jacdac.sendPairing(cp.address, \n                        DAL.JD_DEVICE_FLAGS_REMOTE \n                        | DAL.JD_DEVICE_FLAGS_INITIALISED \n                        | DAL.JD_DEVICE_FLAGS_CP_SEEN, \n                        cp.serialNumber, \n                        cp.driverClass);\n                }\n            }\n            return true;\n        }\n       \n        public handlePacket(pkt: Buffer): boolean {\n            const packet = new JDPacket(pkt);\n            if (this.device.isVirtualDriver\n                || (this.device.isPaired && !this.device.isPairedInstanceAddress(packet.address)))\n                return true;\n        \n            const mode = <PinMode>packet.getNumber(NumberFormat.UInt16LE, 0);\n            const value = packet.getNumber(NumberFormat.Int16LE, 2);\n            \n            switch(mode) {\n                case PinMode.SetAnalog:\n                    this._pin.analogWrite(value); break;\n                case PinMode.SetDigital:\n                    this._pin.digitalWrite(!!value); break;\n                case PinMode.SetServo:\n                    this._pin.servoWrite(value); break;\n                default:\n                    jacdac.log(`unknown pin mode ${mode}`); break;\n            }\n\n            return true;\n        }\n\n    }\n}",
      "pxt.json": "{\n    \"name\": \"jacdac\",\n    \"description\": \"Plug and play single wire serial protocol.\",\n    \"files\": [\n        \"jacdac.cpp\",\n        \"jacdac.ts\",\n        \"messagebusdriver.ts\",\n        \"pindriver.ts\",\n        \"shims.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"targetVersions\": {\n        \"target\": \"0.1.0\"\n    }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace jacdac {\n\n    /**\n     * Internal\n     */\n    //% shim=jacdac::__internalSendPacket\n    function __internalSendPacket(buf: Buffer, deviceAddress: int32): int32;\n}\n\n\ndeclare interface JacDacDriverStatus {\n    /**\n     * Retrieves the serial number in use by this driver.\n     *\n     * @return the serial number\n     **/\n    //% property shim=JacDacDriverStatusMethods::serialNumber\n    serialNumber: uint32;\n\n    /** Check if device is paired. */\n    //% property shim=JacDacDriverStatusMethods::isPaired\n    isPaired: boolean;\n\n    /** Check if device is pairable. */\n    //% property shim=JacDacDriverStatusMethods::isPairable\n    isPairable: boolean;\n\n    /** Check if driver is virtual. */\n    //% property shim=JacDacDriverStatusMethods::isVirtualDriver\n    isVirtualDriver: boolean;\n\n    /** Check if driver is paired. */\n    //% property shim=JacDacDriverStatusMethods::isPairedDriver\n    isPairedDriver: boolean;\n\n    /** Check if driver is connected. */\n    //% property shim=JacDacDriverStatusMethods::isConnected\n    isConnected: boolean;\n\n    /** Get device class. */\n    //% property shim=JacDacDriverStatusMethods::driverClass\n    driverClass: uint32;\n\n    /** Get device class. */\n    //% property shim=JacDacDriverStatusMethods::driverAddress\n    driverAddress: uint8;\n\n    /** Get device id for events. */\n    //% property shim=JacDacDriverStatusMethods::id\n    id: boolean;\n\n    /** If paired, paired instance address */\n    //% property shim=JacDacDriverStatusMethods::isPairedInstanceAddress\n    isPairedInstanceAddress(address: uint8): uint32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "jacdac.listenEvent(9008, DAL.DEVICE_BUTTON_EVT_CLICK);\ncontrol.onEvent(9008, DAL.DEVICE_BUTTON_EVT_CLICK, function () {\n    console.log('click')\n})"
    }
  },
  "bundledcoresvgs": {}
}